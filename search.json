[{"date":"2021-06-01T15:29:08.000Z","url":"/2021/06/01/%E6%9D%82%E8%B0%88/","categories":[["undefined",""]],"content":"六一快乐！"},{"title":"PSW寄存器分析","date":"2021-05-31T23:51:22.000Z","url":"/2021/06/01/FLAG%E5%AF%84%E5%AD%98%E5%99%A8/","tags":[["CS","/tags/CS/"]],"categories":[["计算机组成原理","/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"]],"content":"FLAG寄存器 存储程序状态字（PSW，program status word），存储相关指令的执行结果，为相关指令提供行为依据，用来控制CPU的相关工作方式。flag寄存器是按位起作用的，每一位都有专门的含义记录特定信息。 在32位CPU中称为为EFLAGS寄存器，64为CPU中称为RFLAGS寄存器，它们扩展出的高位地址都不使用。现代计算机中一般也叫做PSW寄存器。下面以8086为基础处理器分析该寄存器的功能 ZF（Zero Flag） 第6位标志位，零标志位。计算指令执行后，若结果为0，则zf=1，否则zf=0 PF（Parity Flag） 第2位标志位，奇偶标志位。指令执行后，若所有bit位中1的个数为偶数，则pf=1，否则pf=0 SF（Symbol Flag） 第7位标志位，符号标志位。指令执行后，若结果为负，则sf=1，否则sf=0 CF（Carry Flag） 第0位标志位，进位标志位。无符号运算中指令执行后，若产生进位，则cf=1，否则cf=0，同时也可以用作表示借位。若其值被add设置则表示进位，被sub设置则表示借位 OF（Overflow Flag） 第11位标志位，溢出标志位。有符号运算时，若产生溢出，则of=1，否则of=0 AF（Auxiliary Flag） 第4位标志位，辅助进位标志位。若操作中发生了进位或借位，则af=1，否则af=0mov al，0Fhadd al，1计算过程0000111100000001——————00010000 位3中发生了进位，af=1 IF（Interrupt-Enable Flag） 第9位标志位，中断允许标志位。决定CPU是否能够响应外部可屏蔽中断请求，若响应则if=1，否则if=0 DF（Direction Flag） 第10位标志位，方向标志位。控制SI和DI自增还是自减。若自减，则df=1，否则df=0 TF（Trap Flag） 第8位标志位，追踪标志位。若CPU进入单步调试，则tf=1，否则tf=0 "},{"title":"CSMA/CD中重传时机的确定","date":"2021-05-29T15:14:31.000Z","url":"/2021/05/29/%E6%88%AA%E6%96%AD%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8C%87%E6%95%B0%E8%A7%84%E9%81%BF%E7%AE%97%E6%B3%95/","tags":[["CN","/tags/CN/"]],"categories":[["计算机网络","/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"]],"content":"截断二进制指数规避算法什么是截断二进制指数规避算法在CSMA/CD协议中，检测到碰撞我们要重传数据。那么如何选择碰撞后数据的重传的时机呢？该算法就是为了解决这个问题而提出的 如何使用该算法计算重传时机首先，发生碰撞后我们要确定一个基本的退避时间来延迟发送。假设从A发送到B的传播时延是 t ，我们将基本退避时间设置为 2t 。 其次，定义参数 k ，用于记录重传的次数。 k = min[ 重传次数，10 ]。当检测到数据碰撞时，在 0 ~ 2k - 1 的范围中随机取出一个数 r ，重传时间 R 即为 r 倍的基本退避时间 ， R = 2tr 最后，若重传 16 次仍然不能成功发送数据则向网络层发出错误信息表示网络拥挤并抛弃此帧"},{"title":"数据链路层中最小帧长问题","date":"2021-05-20T15:12:19.000Z","url":"/2021/05/20/%E6%9C%80%E5%B0%8F%E5%B8%A7%E9%95%BF/","tags":[["CN","/tags/CN/"]],"categories":[["计算机网络","/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"]],"content":"数据链路层中的最小帧长是如何计算出来的众所周知，Ethernet的最小帧长是64 Byte。那么这个最小帧长是如何得到的呢？ 数据碰撞问题当多个主机挂载在bus型半双工信道上时我们都会存在一个信道争用问题，为解决这个问题我们发明了CSMA/CD协议。 当两个主机同时在bus型半双工信道上发送数据就会产生数据碰撞。数据发送过程如图所示 我们假设单向传播时延为 t ，图中发生数据碰撞时，A知道碰撞检测的时间为 2 t1 ，而B检测到碰撞的时间为 2 t2。 t = t1 + t2 最差的情况下，当A即将到达B时，B才发送数据，此时发生碰撞。所以最迟我们检测到数据碰撞的时间是 2t 如何确定最小帧长因为如果我们自身数据全部发完后才检测到数据则数据会被误认为是正常的数据而被接收，所以我们要确保我们还没有发完数据时就检测到碰撞。 因此根据上面的时延计算，我们可以得出 帧长 / 数据传输速率 &gt;= 2 t 最小帧长 = 数据传输速率 x 传播时延 x 2"},{"title":"Cache设计","date":"2021-05-07T15:06:08.000Z","url":"/2021/05/07/Cache%E8%AE%BE%E8%AE%A1/","tags":[["CS","/tags/CS/"]],"categories":[["计算机组成原理","/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"]],"content":"Cache设计Cache原理 利用程序的局部性原理，缩减CPU的访存时间，让CPU能够更好的发挥性能 空间局部性：最近被访问的块邻近的块很有可能被访问 时间局部性：最近被的访问的块很有可能被再次访问 Cache设计的两大原则 高命中率，要求高命中率减少块的置换操作 对CPU透明，即CPU访问内存和访问Cache为同一种方式，无需改变 Cache设计的四个问题 从主存取得的块如何在Cache中存放 如何访问主存放入Cache中的块 当Cache未命中时置换数据块的策略 怎样保持Cache块中数据与主存块的数据同步 三种Cache与主存地址映射策略 通常Cache相对于主存都十分小，所以主存块的哪些部分放入有限的Cache空间中是一个很重要的问题。下面有三种策略用于解决主存块在Cache中的存放位置问题 全相联映射 Cache数据块称为行，主存数据块称为块，其中行大小==块大小。全相联映射中，主存一个块地址、块号、块内容都被一起存于Cache的行中 主存中的块被复制到Cache的任意行中 CPU访问一个主存地址时，为了快速检索，指令中的块号与Cache所有行号的标记同时在比较器中比较，若命中则从Cache中读取一个字，否则在主存地址中读取 全相联映射其主要缺点是高速比较器电路难于设计和实现，因此适合小容量Cache 直接映射主存被划分为n个和Cache大小相同的区，区内的块只能存入对应Cache行内 Cache行号 i 和主存块号 j 关系为 i = j mode m，其中m为Cache的大小 直接映射其优点是硬件简单，成本低，地址变换速度快，但其缺点是每个主存块有一个固定行号可以存放。 当连续两个访存指令要求访问块号相距m整数倍的两个块时，因两个块同时映射到同一个Cache行内，所以会产生冲突，需要置换行块，导致置换操作频繁，降低Cache效率 组相联将Cache划分为若干个大小相同的组，而主存不同区内，区内的对应块可以换入Cache对应的组中，在组中可以存放在任意行 当Cache分组的大小为1时，组内只有一个块，此时为直接映射；当Caceh分组大小为整个Cache大小时，只有一个分组，此时为全相联 组相联模式结合了适度兼顾了全相联和直接映射的优点，被普遍采用 Cache替换策略 当Cache存满需要换入新块时，有三种主流的替换算法分别是 LFU算法LFU，最不经常使用算法，将一段时间内被访问次数最少的行换出。每行设置一个计数器，当新行调入Cache，该新行计数器为0。当某个行被读取一次，该行的计数器+1，需要换出行时寻找到计数器最低的行将其换出。 LRU算法LRU，近期最少使用算法，将近期内最长久未被访问过的行换出。同样如LFU为每行设置一个计数器，但是Cache行每次被命中其计数器清零，其它各行计数器+1，与LFU算法相反，需要置换出行时将计数器值最高的行换出 随机替换随机换出行，无固定规则。研究表明随机替换的性能只是稍稍逊于前两种算法 Cache写操作策略 因为Cache中的数据时主存块中的副本，在任何系统中只要存在副本就存在各副本之间数据同步的问题。当前Cache中普遍采用的同步策略有以下三种： 写回法 write back,copy back：CPU命中Cache时，只修改Cache行中的数据内容，仅当Cache该块被换出时，将数据写回主存；CPU未命中Cache时，将该块从主存复制到Cache行中，再对其修改。Cache中每行都置一个修改位，记录该块是否被修改，若该行被换出是修改位为0，则直接抛弃 写回法优点是减少访问主存的次数，但是写回法会导致Cache行中的数据与对应主存块中的数据不一致，产生隐患 全写法 write through：CPU命中Cache时，同时修改Cache行和主存块中的内容，主存和Cache同步；当CPU未命中Cache时，有两种策略，一是WTWA法，将主存块置换如Cache行中，对Cache行修改，另一种是WTNWA法，直接修改主存块，不置换入Cache中 全写法的优点是简单，Cache和主存同步，不会发生数据不一致，但是其频繁的访问主存操作导致Cache性能降低 写一次法 write once：CPU第一次命中Cache时，同时修改Cache行中和主存块中的内容，后面再命中时采用写回法的策略；CPU未命中时采用写回法策略 写一次法结合了写回法和全写法"}]