<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Asuhe</title>
  
  <subtitle>Born in poverty, died of numbness</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-11-07T14:19:39.161Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Asuhe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TypeError:this.getOptions is not a function</title>
    <link href="http://example.com/2021/11/07/2021-11-07-webpack%E4%B8%AD%E6%89%93%E5%8C%85css%E7%9A%84%E5%9D%91/"/>
    <id>http://example.com/2021/11/07/2021-11-07-webpack%E4%B8%AD%E6%89%93%E5%8C%85css%E7%9A%84%E5%9D%91/</id>
    <published>2021-11-07T03:29:37.000Z</published>
    <updated>2021-11-07T14:19:39.161Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="webpack-中打包-css、less、sass文件的坑"><a href="#webpack-中打包-css、less、sass文件的坑" class="headerlink" title="webpack 中打包 css、less、sass文件的坑"></a>webpack 中打包 css、less、sass文件的坑</h2><p>vscode用import语法引入css文件不显示css路径：安装一个路径显示插件即可，推荐使用<a href="https://marketplace.visualstudio.com/items?itemName=ionutvmi.path-autocomplete">Path Autocomplete</a>即可解决</p><p>原本安装好css-loader准备用webpack打包css文件时出现一堆底层报错说<code>TypeError: this.getOptions is not a function</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ERROR <span class="keyword">in</span> ./src/css/index.css</span><br><span class="line">Module build failed (from ./node_modules/style-loader/dist/cjs.js):</span><br><span class="line">TypeError: this.getOptions is not a <span class="keyword">function</span></span><br><span class="line">    at Object.loader (C:\Users\12071\Desktop\练习\webpack-test\node_modules\style-loader\dist\index.js:19:24)</span><br><span class="line"> @ ./src/js/app.js 8:0-25</span><br></pre></td></tr></table></figure><p>原因：loader版本不匹配</p><p>解决方案：安装配套版本的style-loader和css-loader</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//安装2.0版本的style-loader</span><br><span class="line">npm i style-loader@2.0.0</span><br><span class="line"></span><br><span class="line">//安装5.2.7版本的css-loader</span><br><span class="line">npm i css-loader@5.2.7</span><br></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/68580273/type-error-this-getoptions-is-not-a-function-for-style-loader">stackoverflow YYDS</a></p><p>less文件无法打包</p><p>原因：less-loader版本过高</p><p>解决方案：安装低于5.0版本的less-loader</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install less-loader@5.0 -D</span><br></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/66792368/less-files-not-getting-picked-up-by-less-loader/66793018#66793018">stackoverflow YYDS</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="报错处理" scheme="http://example.com/categories/%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86/"/>
    
    
    <category term="tools" scheme="http://example.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Promise</title>
    <link href="http://example.com/2021/11/05/2021-11-05-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAPromise/"/>
    <id>http://example.com/2021/11/05/2021-11-05-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAPromise/</id>
    <published>2021-11-05T00:26:46.000Z</published>
    <updated>2021-11-06T00:52:02.865Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>在学习Promise之前我们需要先明白一些基础知识，首先我们要知道什么叫实例对象，什么叫函数对象。所谓实例对象就是我们使用 new 关键字创建出来的对象，称为实例对象，一般简称对象。而函数对象是指当我们把一个函数当作对象使用时，此时我们称这个函数为函数对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数的两种身份：函数、函数对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// ok 当我们用()调用函数时，此时函数称为一个函数</span></span><br><span class="line">foo.a = <span class="number">20</span> <span class="comment">// 当我们像这样给函数添加属性或者方法时，此时函数称为一个函数对象</span></span><br></pre></td></tr></table></figure><p>按函数的调用者分类我们可以将某些函数称为回调函数，<strong>回调函数就是我们定义的，我们没调用，最终执行了。</strong>最典型的例子就是定时器里我们传入的函数。根据回调函数执行时机的不同，我们又可以将回调函数分为<strong>同步回调函数和异步回调函数</strong>。</p><p>同步回调函数的特点就是<strong>立即执行</strong>，完全执行完了才结束，不会放入回调队列中。<strong>换言之就是它是在主线程上执行的</strong>。例如数组遍历相关的回调函数、Promise的excutor函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]</span><br><span class="line">arr.forEach(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value))  </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;主线程&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出顺序为: 10 20 30 主线程</span></span><br></pre></td></tr></table></figure><p>上述例子中可以明显看到，数组forEach方法里的回调函数先于主线程上的 console.log 输出，这表明这个回调函数就是一个同步回调</p><p>与同步回调函数相反，异步回调函数的特点就是<strong>延迟执行</strong>，它会被放入回调队列里，等主线程上的函数都执行完以后将来再根据条件执行。例如定时器上的回调函数、ajax回调、Promise的成功 | 失败回调</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>(<span class="built_in">console</span>.log(<span class="string">&#x27;hello!&#x27;</span>)),<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;主线程&#x27;</span>)</span><br><span class="line"><span class="comment">//输出顺序为: 主线程 hello!</span></span><br></pre></td></tr></table></figure><p>即便定时器的延迟设为 0 ，它里面的回调函数依然要等待主线程执行完毕才能执行。这就是一个典型的异步回调</p><p>通过理解同步回调和异步回调的例子，我们可以明白。所谓同步就是绝对的串行执行，只有上一步执行完了下一步才能继续执行。想象这样的一个场景，我们去做饭，电饭煲在煮饭的同时我们可以继续处理我们的菜，我们不必等饭完全煮好了才开始做菜，这样太浪费时间了。这种就是异步执行。如果我们必须等到饭煮好了才开始炒菜之类的，那这种就是同步执行。</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>有了上面同步异步的概念以后，接下来我们就可以开始学习Promise了。我们先来看看它是什么，官方给的定义是啥。</p><ul><li><p>抽象表达: </p><ul><li>Promise是JS中进行<strong>异步编程</strong>的<strong>新方案</strong>(旧的是谁?—纯回调)</li></ul></li><li><p> 具体表达:</p></li><li><p>从语法上来说: Promise是一个构造函数</p></li><li><p> 从功能上来说: promise对象用来封装一个异步操作并可以获取其结果</p></li></ul><p>其实看了上面的表达我们还是不懂什么是Promise。从异步这个词入手，我们都知道ajax就是一个典型的异步操作。那么我们就可以用Promise来封装ajax请求。那我们为什么非要用Promise来封装异步操作，我们用普通的回调函数形式不一样可以吗？这就涉及到回调地狱这个问题，关于[Promise的优越性](# 回调地狱 )我们后面再谈。首先来明确一些基础的Promise知识</p><ul><li>Promise不是回调，是一个内置的构造函数，是程序员自己new调用的。</li><li>new Promise的时候，要传入一个回调函数，它是同步的回调，会立即在主线程上执行，它被称为executor函数</li><li>每一个Promise实例都有3种状态：初始化(pending)、成功(fulfilled)、失败(rejected)</li><li>每一个Promise实例在刚被new出来的那一刻，状态都是初始化(pending)</li><li>executor函数会接收到2个参数，它们都是函数，分别用形参：resolve、reject接收<ul><li>调用resolve函数会：<ul><li>让Promise实例状态变为成功(fulfilled)</li><li>可以指定成功的value。</li></ul></li><li>调用reject函数会：<ul><li>让Promise实例状态变为失败(rejected)</li><li>可以指定失败的reason。</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//new 一个实例</span></span><br><span class="line"><span class="keyword">const</span> p  = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据上面描述这个Promise必须传入一个excutor函数，而这个excutor函数又两个形参也是函数,我们不必定义该两个形参函数，可以直接调用</span></span><br><span class="line">(resolve,reject)=&gt;&#123;&#125;  <span class="comment">//excutor</span></span><br></pre></td></tr></table></figure><p>当我们使用一个Promise管理异步操作的时候，我们要在excutor函数内启动异步任务然后再用它的 then 方法来指定异步任务结束后根据Promise实例的状态来调用相应的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用Promise封装一个自己的get请求ajax</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myAjax</span>(<span class="params">url,datas</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">        <span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> xhr = <span class="keyword">new</span> XHLHttpRequest();</span><br><span class="line">            xhr.onreadystatuschange = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(xhr.status === <span class="number">200</span>) resolve(<span class="string">&#x27;ok&#x27;</span>) <span class="comment">//请求成功将Promise状态置为fulfilled</span></span><br><span class="line">                    <span class="keyword">else</span> reject(<span class="string">&#x27;falure&#x27;</span>)  <span class="comment">//请求失败将Promise状态置为rejected</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            xhr.opne(<span class="string">&#x27;GET&#x27;</span>,url);</span><br><span class="line">            xhr.send();</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = myAjax(<span class="string">&#x27;http://127.0.0.1/get&#x27;</span>,&#123;<span class="attr">test</span>:<span class="string">&#x27;test&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">p.then( <span class="comment">//为Promise实例指定成功与失败的回调函数</span></span><br><span class="line">    <span class="function">(<span class="params">value</span>)=&gt;</span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;请求成功1&#x27;</span>,value); &#125;, <span class="comment">//fulfilled状态调用</span></span><br><span class="line">    <span class="function">(<span class="params">reason</span>)=&gt;</span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;请求失败1&#x27;</span>,reason); &#125; <span class="comment">//rejected状态调用</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个promise指定多个成功/失败回调函数, 则会依次调用并不会覆盖</span></span><br><span class="line">p.then( <span class="comment">//为Promise实例指定成功与失败的回调函数</span></span><br><span class="line">    <span class="function">(<span class="params">value</span>)=&gt;</span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;请求成功2&#x27;</span>,value); &#125;, <span class="comment">//fulfilled状态调用</span></span><br><span class="line">    <span class="function">(<span class="params">reason</span>)=&gt;</span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;请求失败2&#x27;</span>,reason); &#125; <span class="comment">//rejected状态调用</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//若该次请求失败则依次输出:请求失败1 请求失败2</span></span><br></pre></td></tr></table></figure><ul><li>关于状态的注意点：<ul><li>三个状态:<ul><li>pending: 未确定的——初始状态</li><li>fulfilled: 成功的——调用resolve()后的状态</li><li>rejected: 失败的——-调用reject()后的状态</li></ul></li><li>两种状态改变<ul><li>pending ==&gt; fulfilled</li><li>pending ==&gt; rejected</li></ul></li><li>状态只能改变一次！</li></ul></li></ul><h2 id="Promise基本方法"><a href="#Promise基本方法" class="headerlink" title="Promise基本方法"></a>Promise基本方法</h2><h3 id="Promise构造函数-new-Promise-executor"><a href="#Promise构造函数-new-Promise-executor" class="headerlink" title="Promise构造函数: new Promise (executor) {}"></a>Promise构造函数: new Promise (executor) {}</h3><ul><li>executor函数: 是同步执行的，(resolve, reject) =&gt; {}</li><li>resolve函数: 调用resolve将Promise实例内部状态改为成功(fulfilled)。</li><li>reject函数: 调用reject将Promise实例内部状态改为失败(rejected)。</li><li>说明: excutor函数会在Promise内部立即同步调用,异步代码放在excutor函数中。</li></ul><h3 id="Promise-prototype-then方法-Promise实例-then-onFulfilled-onRejected"><a href="#Promise-prototype-then方法-Promise实例-then-onFulfilled-onRejected" class="headerlink" title="Promise.prototype.then方法: Promise实例.then(onFulfilled,onRejected)"></a>Promise.prototype.then方法: Promise实例.then(onFulfilled,onRejected)</h3><ul><li>onFulfilled: 成功的回调函数 (value) =&gt; {}</li><li>onRejected: 失败的回调函数 (reason) =&gt; {}</li><li>特别注意(难点)：then方法会返回一个新的Promise实例对象</li><li>如果上一个回调返回的是一个非promise对象，则这个新的Promise实例状态为fulfilled</li><li>当上一个回调返回一个Promise对象则该新返回的Promise对象的状态与回调返回的Promise对象一致</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span>&#123; resolve(<span class="string">&#x27;ok&#x27;</span>); &#125;) </span><br><span class="line"><span class="keyword">const</span> x = p.then(</span><br><span class="line"><span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="number">1</span>&#125;, <span class="comment">//返回非Promise值</span></span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>.reject(<span class="number">996</span>)&#125;</span><br><span class="line">)</span><br><span class="line">x.then(</span><br><span class="line"><span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功了&#x27;</span>), <span class="comment">//x状态为fulfilled,输出成功了</span></span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;失败了&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> z = p.then(</span><br><span class="line"><span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;&#125;)&#125;, <span class="comment">//返回Promise值</span></span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>.reject(<span class="number">996</span>)&#125;</span><br><span class="line">)</span><br><span class="line">z.then( <span class="comment">//z状态为 pending ,不调用回调函数</span></span><br><span class="line"><span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功了&#x27;</span>), </span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;失败了&#x27;</span>) </span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Promise-prototype-catch方法-Promise实例-catch-onRejected"><a href="#Promise-prototype-catch方法-Promise实例-catch-onRejected" class="headerlink" title="Promise.prototype.catch方法: Promise实例.catch(onRejected)"></a>Promise.prototype.catch方法: Promise实例.catch(onRejected)</h3><ul><li>onRejected: 失败的回调函数 (reason) =&gt; {}</li><li>说明: catch方法是then方法的语法糖, 相当于: then(undefined, onRejected)</li></ul><h3 id="Promise-resolve方法-Promise-resolve-value"><a href="#Promise-resolve方法-Promise-resolve-value" class="headerlink" title="Promise.resolve方法: Promise.resolve(value)"></a>Promise.resolve方法: Promise.resolve(value)</h3><ul><li>说明: 用于快速返回一个状态为fulfilled或rejected的Promise实例对象</li><li>备注：value的值可能是：(1)非Promise值  (2)Promise值</li><li>当传入的值为非Promise值时或空值时，直接返回一个 fulfilled 状态的 Promise实例</li><li>当传入的值为 Promise 时，返回的Promise状态跟随传入的Promise</li></ul><h3 id="Promise-reject方法-Promise-reject方法-reason"><a href="#Promise-reject方法-Promise-reject方法-reason" class="headerlink" title="Promise.reject方法: Promise.reject方法(reason)"></a>Promise.reject方法: Promise.reject方法(reason)</h3><ul><li>说明: 用于快速返回一个状态必为rejected的Promise实例对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="built_in">Promise</span>.reject(<span class="number">996</span>);</span><br><span class="line">x.then(</span><br><span class="line"><span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功了&#x27;</span>,value),</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;失败了&#x27;</span>,reason) <span class="comment">//调用该函数 输出:失败了 996</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Promise-all方法-Promise-all-promiseArr"><a href="#Promise-all方法-Promise-all-promiseArr" class="headerlink" title="Promise.all方法: Promise.all(promiseArr)"></a>Promise.all方法: Promise.all(promiseArr)</h3><ul><li>promiseArr: 包含n个Promise实例的数组</li><li>说明: 返回一个新的Promise实例, 只有所有的promise都成功才成功, 只要有一个失败了就直接失败。</li><li>若没有失败的值，且没有pending的值即全都成功返回的新Promise状态为fulfilled</li><li>若没有失败的值，但存在pending的值即数组内仅有pending和fulfilled两种值，则返回的新Promise状态为pending</li></ul><h3 id="Promise-race方法-Promise-race-promiseArr"><a href="#Promise-race方法-Promise-race-promiseArr" class="headerlink" title="Promise.race方法: Promise.race(promiseArr)"></a>Promise.race方法: Promise.race(promiseArr)</h3><ul><li>promiseArr: 包含n个Promise实例的数组</li><li>说明: 返回一个新的Promise实例, 成功还是很失败？以最先出结果的promise为准。</li><li>若最先出结果的promise为pending则跳过该promise</li><li>这也就意味着race返回的Promise实例仅有fulfilled和rejected两种状态，不存在pending状态的值</li></ul><h2 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h2><p>上面我们学习了基本Promise使用，但是我们依然没有看出来Promise的优越性在哪里。现在我们有这么一个需求，连发三次Ajax请求，仅当上次请求成功时才发送下一次请求，若请求失败则中断以后的所有请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用纯回调的方式封装ajax</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendAjax</span>(<span class="params">url,data,success,error</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    xhr.onreadystatechange = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) success(xhr.response);</span><br><span class="line">            <span class="keyword">else</span> error(<span class="string">&#x27;请求出了点问题&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//整理参数</span></span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data)&#123;</span><br><span class="line">        str += <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;data[key]&#125;</span>&amp;`</span></span><br><span class="line">    &#125;</span><br><span class="line">    str = str.slice(<span class="number">0</span>,-<span class="number">1</span>)</span><br><span class="line">    xhr.open(<span class="string">&#x27;GET&#x27;</span>,url+<span class="string">&#x27;?&#x27;</span>+str)</span><br><span class="line">    xhr.responseType = <span class="string">&#x27;json&#x27;</span></span><br><span class="line">    xhr.send()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传统解决方案，链式连发三个请求</span></span><br><span class="line">sendAjax(</span><br><span class="line">    <span class="string">&#x27;https://api.apiopen.top/getJoke&#x27;</span>,</span><br><span class="line">    &#123;<span class="attr">page</span>:<span class="number">1</span>,<span class="attr">count</span>:<span class="number">2</span>,<span class="attr">type</span>:<span class="string">&#x27;video&#x27;</span>&#125;,</span><br><span class="line">    <span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;第1次成功了&#x27;</span>,response);</span><br><span class="line">        sendAjax(</span><br><span class="line">            <span class="string">&#x27;https://api.apiopen.top/getJoke&#x27;</span>,</span><br><span class="line">            &#123;<span class="attr">page</span>:<span class="number">1</span>,<span class="attr">count</span>:<span class="number">2</span>,<span class="attr">type</span>:<span class="string">&#x27;video&#x27;</span>&#125;,</span><br><span class="line">            <span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;第2次成功了&#x27;</span>,response);</span><br><span class="line">                sendAjax(</span><br><span class="line">                    <span class="string">&#x27;https://api.apiopen.top/getJoke&#x27;</span>,</span><br><span class="line">                    &#123;<span class="attr">page</span>:<span class="number">1</span>,<span class="attr">count</span>:<span class="number">2</span>,<span class="attr">type</span>:<span class="string">&#x27;video&#x27;</span>&#125;,</span><br><span class="line">                    <span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">&#x27;第3次成功了&#x27;</span>,response);   <span class="comment">//回调地狱</span></span><br><span class="line">                    &#125;, </span><br><span class="line">                    <span class="function"><span class="params">err</span> =&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;第3次失败了&#x27;</span>,err);&#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;, </span><br><span class="line">            <span class="function"><span class="params">err</span> =&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;第2次失败了&#x27;</span>,err);&#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="function"><span class="params">err</span> =&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;第1次失败了&#x27;</span>,err);&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以看到当我们要进行三次链式的异步请求时，采用纯回调的方式来处理就导致了回调地狱的问题。要对代码进行维护十分困难。而如果我们采用Promise去封装异步请求，则可以解决回调地狱的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Promsie封装ajax</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendAjax</span>(<span class="params">url,data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        xhr.onreadystatechange = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) resolve(xhr.response);</span><br><span class="line">                <span class="keyword">else</span> reject(<span class="string">&#x27;请求出了点问题&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//整理参数</span></span><br><span class="line">        <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data)&#123;</span><br><span class="line">            str += <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;data[key]&#125;</span>&amp;`</span></span><br><span class="line">        &#125;</span><br><span class="line">        str = str.slice(<span class="number">0</span>,-<span class="number">1</span>)</span><br><span class="line">        xhr.open(<span class="string">&#x27;GET&#x27;</span>,url+<span class="string">&#x27;?&#x27;</span>+str)</span><br><span class="line">        xhr.responseType = <span class="string">&#x27;json&#x27;</span></span><br><span class="line">        xhr.send()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用Promise进行三次链式ajax请求</span></span><br><span class="line">sendAjax(<span class="string">&#x27;https://api.apiopen.top/getJoke&#x27;</span>,&#123;<span class="attr">page</span>:<span class="number">1</span>&#125;)</span><br><span class="line">    .then(</span><br><span class="line">        <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;第1次请求成功了&#x27;</span>,value);</span><br><span class="line">            <span class="comment">//发送第2次请求</span></span><br><span class="line">            <span class="keyword">return</span> sendAjax(<span class="string">&#x27;https://api.apiopen.top/getJoke&#x27;</span>,&#123;<span class="attr">page</span>:<span class="number">1</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">    .then(</span><br><span class="line">        <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;第2次请求成功了&#x27;</span>,value);</span><br><span class="line">            <span class="comment">//发送第3次请求</span></span><br><span class="line">            <span class="keyword">return</span> sendAjax(<span class="string">&#x27;https://api.apiopen.top/getJoke&#x27;</span>,&#123;<span class="attr">page</span>:<span class="number">1</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">)</span><br><span class="line">    .then(</span><br><span class="line">        <span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;第3次请求成功了&#x27;</span>,value);&#125;</span><br><span class="line">)</span><br><span class="line">.cathe(</span><br><span class="line"><span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err);  <span class="comment">//利用错误穿透进行兜底</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以明显地对比出来，利用Promise进行链式异步操作能清晰地看到调用结构，维护起来相比纯回调方便了很多。这就解决了回调地狱的问题。</p><h2 id="Promise的优势"><a href="#Promise的优势" class="headerlink" title="Promise的优势"></a>Promise的优势</h2><ul><li><p>指定回调函数的方式更加灵活: </p><ul><li>旧的: 必须在启动异步任务前指定</li><li>Promise: 启动异步任务 =&gt; 返回promie对象 =&gt; 给promise对象绑定回调函数(甚至可以在异步任务结束后指定)</li></ul></li><li><p>支持链式调用, 可以解决回调地狱问题</p><ul><li>什么是回调地狱：回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调函数执行的条件</li><li>回调地狱的弊病：代码不便于阅读、不便于异常的处理</li><li>一个不是很优秀的解决方案：then的链式调用</li><li>终极解决方案：async/await（底层实际上依然使用then的链式调用）</li></ul></li></ul><h2 id="Promise关键问题"><a href="#Promise关键问题" class="headerlink" title="Promise关键问题"></a>Promise关键问题</h2><h3 id="如何改变一个Promise实例的状态"><a href="#如何改变一个Promise实例的状态" class="headerlink" title="如何改变一个Promise实例的状态?"></a>如何改变一个Promise实例的状态?</h3><ul><li>执行resolve(value): 如果当前是pending就会变为fulfilled</li><li>执行reject(reason): 如果当前是pending就会变为rejected</li><li>执行器函数(executor)抛出异常: 如果当前是pending就会变为rejected</li></ul><h3 id="改变Promise实例的状态和指定回调函数谁先谁后"><a href="#改变Promise实例的状态和指定回调函数谁先谁后" class="headerlink" title="改变Promise实例的状态和指定回调函数谁先谁后?"></a>改变Promise实例的状态和指定回调函数谁先谁后?</h3><ul><li>都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调</li><li>如何先改状态再指定回调? <ul><li>延迟一会再调用then()</li></ul></li><li>Promise实例什么时候才能得到数据?<ul><li>如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据</li><li>如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据</li></ul></li></ul><h3 id="Promise实例-then-返回的是一个【新的Promise实例】，它的值和状态由什么决定"><a href="#Promise实例-then-返回的是一个【新的Promise实例】，它的值和状态由什么决定" class="headerlink" title="Promise实例.then()返回的是一个【新的Promise实例】，它的值和状态由什么决定?"></a>Promise实例.then()返回的是一个【新的Promise实例】，它的值和状态由什么决定?</h3><ul><li>简单表达: 由then()所指定的回调函数执行的结果决定</li><li>详细表达:<ul><li>如果then所指定的回调返回的是非Promise值a:<ul><li>那么【新Promise实例】状态为：成功(fulfilled), 成功的value为a</li></ul></li><li>如果then所指定的回调返回的是一个Promise实例p:<ul><li>那么【新Promise实例】的状态、值，都与p一致</li></ul></li><li>如果then所指定的回调抛出异常:<ul><li>那么【新Promise实例】状态为rejected, reason为抛出的那个异常</li></ul></li></ul></li></ul><h3 id="如何中断promise链："><a href="#如何中断promise链：" class="headerlink" title="如何中断promise链："></a>如何中断promise链：</h3><ul><li>当使用promise的then链式调用时, 在中间中断, 不再调用后面的回调函数。</li><li>办法: 在失败的回调函数中返回一个pendding状态的Promise实例。</li></ul><h3 id="Promise错误穿透的原理："><a href="#Promise错误穿透的原理：" class="headerlink" title="Promise错误穿透的原理："></a>Promise错误穿透的原理：</h3><ul><li>当使用promise的then链式调用时, 可以在最后用catch指定一个失败的回调,</li><li>前面任何操作出了错误, 都会传到最后失败的回调中处理了</li><li>备注：如果不存在then的链式调用，就不需要考虑then的错误穿透。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        reject(-<span class="number">100</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;成功了1&#x27;</span>,value);<span class="keyword">return</span> <span class="string">&#x27;b&#x27;</span>&#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;<span class="comment">//底层帮我们补上的这个失败的回调</span></span><br><span class="line">)</span><br><span class="line">    .then(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;成功了2&#x27;</span>,value);<span class="keyword">return</span> <span class="built_in">Promise</span>.reject(-<span class="number">108</span>)&#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;<span class="comment">//底层帮我们补上的这个失败的回调</span></span><br><span class="line">)</span><br><span class="line">    .catch(</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="async-amp-await"><a href="#async-amp-await" class="headerlink" title="async &amp; await"></a>async &amp; await</h2><ul><li><p>async修饰的函数</p><p>函数的返回值为promise对象</p><p>Promise实例的结果由async函数执行的返回值决定，返回非Promise值则返回的Promise对象状态为fulfilled，返回Promise则状态跟随返回的Promise，但是不能返回一个 rejected的Promise，否则报错</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = (<span class="keyword">async</span> () =&gt;&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(p) <span class="comment">//输出fulfilled</span></span><br><span class="line">p.then(</span><br><span class="line"><span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功了&#x27;</span>,value), <span class="comment">//执行成功回调</span></span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;失败了&#x27;</span>,reason)</span><br><span class="line">)</span><br><span class="line">----------</span><br><span class="line"><span class="keyword">const</span> p = (<span class="keyword">async</span> () =&gt;&#123;<span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="number">996</span>);&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(p) <span class="comment">//输出pending ,同时也说明了Promise.reject()是个异步函数</span></span><br><span class="line">p.then(</span><br><span class="line"><span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功了&#x27;</span>,value), </span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;失败了&#x27;</span>,reason)<span class="comment">//执行失败回调</span></span><br><span class="line">)</span><br><span class="line">----------</span><br><span class="line"><span class="keyword">const</span> p = (<span class="keyword">async</span> () =&gt;&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">()=&gt;</span>&#123;&#125;);&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(p) </span><br><span class="line">p.then(</span><br><span class="line"><span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功了&#x27;</span>,value), </span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;失败了&#x27;</span>,reason)</span><br><span class="line">)<span class="comment">//不调用任何一个,说明最后状态为pending</span></span><br><span class="line">----------</span><br><span class="line"><span class="keyword">const</span> p = (<span class="keyword">async</span> () =&gt;&#123;<span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">200</span>);&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(p) <span class="comment">//输出pending ,同时也说明了Promise.resolve()是个异步函数</span></span><br><span class="line">p.then(</span><br><span class="line"><span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功了&#x27;</span>,value), <span class="comment">//执行成功回调</span></span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;失败了&#x27;</span>,reason)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><p>await表达式</p><p>await右侧的表达式一般为Promise实例对象, 但也可以是其它的值</p><p>(1).如果表达式是Promise实例对象, await后的返回值是promise成功的值</p><p>(2).如果表达式是其它值, 直接将此值作为await的返回值</p></li><li><p>注意:</p><p>await必须写在async函数中, 但async函数中可以没有await</p><p>如果await的Promise实例对象失败了, 就会抛出异常, 需要通过try…catch来捕获处理</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reason</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;ok了&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;中断&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reason</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;Ok啊&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">4000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">;(<span class="keyword">async</span>()=&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> x1 = <span class="keyword">await</span> p1;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>,x1); <span class="comment">//输出:1 ok了</span></span><br><span class="line">        <span class="keyword">const</span> x2 = <span class="keyword">await</span> p2; <span class="comment">//该点直接失败转入失败回调 throw error</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>,x2);</span><br><span class="line">        <span class="keyword">const</span> x3 = <span class="keyword">await</span> p3;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>,x3);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err); <span class="comment">//catch接收上面throw 的 error 输出:中断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">------</span><br><span class="line"><span class="comment">//上面try里面的代码被浏览器翻译为</span></span><br><span class="line">p1.then(</span><br><span class="line"><span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>,value) <span class="keyword">return</span> p2;&#125; <span class="comment">//输出:1 ok了</span></span><br><span class="line">    <span class="comment">// 不写失败回调底层补上了 reason =&gt; throw reason</span></span><br><span class="line">).then(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>,value); <span class="keyword">return</span> p3;&#125;</span><br><span class="line">).then(</span><br><span class="line"><span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>,value);&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>重绘与回流</title>
    <link href="http://example.com/2021/11/03/2021-11-03-%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81/"/>
    <id>http://example.com/2021/11/03/2021-11-03-%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81/</id>
    <published>2021-11-03T13:15:11.000Z</published>
    <updated>2021-11-03T13:16:22.798Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>重绘：样式改变重绘</p><p>回流：DOM改变回流</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="DOM" scheme="http://example.com/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>身份认证技术</title>
    <link href="http://example.com/2021/11/02/2021-11-02-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/"/>
    <id>http://example.com/2021/11/02/2021-11-02-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/</id>
    <published>2021-11-02T00:34:25.000Z</published>
    <updated>2021-11-02T01:46:40.406Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="身份认证的由来"><a href="#身份认证的由来" class="headerlink" title="身份认证的由来"></a>身份认证的由来</h2><p>平时我们在网页上进行交互时，例如登入自己的账号进行信息修改，往往需要服务器对我们进行身份的辨别，好让服务器能够拿到专属于我们自己账号的数据并返回给我们。由于http协议是无状态的，它并不会对会话进行控制。任何一个http请求对服务器来说都是独立的，毫不相干的请求。<a href="/2021/10/28/2021-10-28-http%E5%8D%8F%E8%AE%AE/" title="http协议">http协议</a>的这种特性就导致了我们需要自己想办法对用户进行识别，于是便有了身份认证技术。</p><p>现在流行的身份认证认证手段主要有三种，分别是：cookie、session和 JWT。这三种身份认证技术都有各自的适用场景，所以在前端中均有大量使用。下面就让我们深入了解一下这三种技术</p><h2 id="Cookie认证"><a href="#Cookie认证" class="headerlink" title="Cookie认证"></a>Cookie认证</h2><p>首先我们要明确什么是cookie。cookie实际上就是<strong>一份服务器给浏览器客户端设置的文本信息</strong>。当用户第一次登录进系统时，服务器会给用户设置一个cookie，后续用户每次发送http请求中都会携带cookie用于身份识别。</p><p>cookie信息都携带在请求头中，而且一个cookie的大小一般不超过4KB。</p><p><img src="https://i.loli.net/2021/11/02/uvhOaopbYzlVLrm.png" alt="请求头中的cookie"></p><p>它的内容由<strong>名称、值和一些用于控制有效期、安全性、使用范围的可选属性组成</strong>。不同域名下的cookie时各自独立的，不能拿一个网站的cookie去另一个网站做身份认证。每当客户端发起请求时，会<strong>自动</strong>把<strong>当前域名下</strong>所有<strong>未过期的</strong> <strong>Cookie</strong> 一同发送到服务器。</p><p>我们可以在浏览器的设置中查看cookie的内容</p><p><img src="https://i.loli.net/2021/11/02/vXBxOJRNS9u4Pqn.png" alt="某度的一个cookie"></p><p>因为cookie认证是用户单方面认证，用户完全可以自己伪造一个cookie发送给服务器来欺骗服务器，这使得cookie安全性较低。为了解决cookie的这个缺陷，进一步提高系统的安全性，所以又有了session机制来辅助身份认证。</p><h2 id="Session认证"><a href="#Session认证" class="headerlink" title="Session认证"></a>Session认证</h2><p>session认证即是在服务器上设置一个标识用户的信息，当用户拿cookie来认证时，服务器这边根据cookie拿出相应的session来必对认证。若服务器这边没有对应的session则说明该cookie是伪造的，拒绝响应。</p><p><img src="https://i.loli.net/2021/11/02/K75ZGYXQ6RJMjOC.png" alt="session认证原理"></p><p>有了session就可以防止用户伪造cookie登录进系统。进一步提高了安全性。</p><p>Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持 <a href="/2021/10/29/2021-10-29-%E5%90%8C%E6%BA%90%E4%B8%8E%E8%B7%A8%E5%9F%9F/" title="跨域访问">跨域访问</a>，所以，当涉及到前端跨域请求后端接口的时候，<strong>需要做很多额外的配置</strong>，才能实现跨域 Session 认证。</p><p>为了解决这个跨域问题，我们又升级了身份认证技术，采用JWT技术可以解决跨域认证的问题。</p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JWT（英文全称：JSON Web Token）是目前<strong>最流行</strong>的<strong>跨域认证解决方案</strong>。针对跨域问题，JWT采用Token加密字符串来实现身份认证。用户的信息通过 Token 字符串的形式，保存在客户端浏览器中。服务器通过还原 Token 字符串的形式来认证用户的身份。</p><p><img src="https://i.loli.net/2021/11/02/ZVlX2zeU5kWOug8.png" alt="JWT工作原理"></p><p>JWT 通常由三部分组成，分别是 Header（头部）、Payload（有效荷载）、Signature（签名）。</p><p>三者之间使用英文的“.”分隔，格式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Header.Payload.Signature</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><strong>Payload</strong> 部分<strong>才是真正的用户信息</strong>，它是用户信息经过加密之后生成的字符串。</li><li>Header 和 Signature 是<strong>安全性相关</strong>的部分，只是为了保证 Token 的安全性。</li></ul><p><img src="https://i.loli.net/2021/11/02/HCj5Ra2xt4MTiDz.png" alt="Payload部分"></p><p>客户端收到服务器返回的 JWT 之后，通常会将它储存在 <strong>localStorage 或 sessionStorage</strong> 中。</p><p>此后，客户端每次与服务器通信，都要带上这个 JWT 的字符串，从而进行身份认证。推荐的做法是<strong>把</strong> <strong>JWT</strong> <strong>放在</strong> <strong>HTTP</strong> <strong>请求头的</strong> <strong>Authorization</strong> <strong>字段中</strong>，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer &lt;token字符串&gt;</span><br></pre></td></tr></table></figure><h2 id="三种认证技术的区别与特点"><a href="#三种认证技术的区别与特点" class="headerlink" title="三种认证技术的区别与特点"></a>三种认证技术的区别与特点</h2><table><thead><tr><th align="center"><strong>认证技术</strong></th><th align="center"><strong>工作原理</strong></th><th align="center"><strong>生命周期</strong></th><th align="center">适用场景</th></tr></thead><tbody><tr><td align="center">cookie</td><td align="center">单向认证</td><td align="center">未设置expire属性的cookie关闭浏览器即失效</td><td align="center">服务器端渲染数据、同源认证</td></tr><tr><td align="center">session</td><td align="center">双向认证</td><td align="center">服务器未清除即一直生效</td><td align="center">服务器端渲染数据、同源认证</td></tr><tr><td align="center">JWT</td><td align="center">密钥认证</td><td align="center">服务器未更换secret就一直生效</td><td align="center">前后端分离架构、跨域认证</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Git快速上手指北</title>
    <link href="http://example.com/2021/10/29/2021-10-29-Git%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2021/10/29/2021-10-29-Git%E5%9F%BA%E7%A1%80/</id>
    <published>2021-10-29T11:36:37.000Z</published>
    <updated>2021-10-29T12:40:00.725Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Git基础使用"><a href="#Git基础使用" class="headerlink" title="Git基础使用"></a>Git基础使用</h2><h3 id="用户信息配置"><a href="#用户信息配置" class="headerlink" title="用户信息配置"></a>用户信息配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置自己的用户名和邮件地址 将用于记录谁操作了仓库</span></span><br><span class="line">git config --global user.name <span class="string">&quot;Asuhe&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;sphinx@asuhe.fun&quot;</span></span><br></pre></td></tr></table></figure><h3 id="配置信息检查"><a href="#配置信息检查" class="headerlink" title="配置信息检查"></a>配置信息检查</h3><p>通过 git config –global user.name 和 git config –global user.email 配置的用户名和邮箱地址，会被写<br>入到 C:/Users/用户名文件夹/.gitconfig文件中。这个文件是Git 的全局配置文件，配置一次即可永久生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有的全局配置</span></span><br><span class="line">git config --list --global</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定的全局配置项</span></span><br><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><h3 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取 config 命令的帮助手册，将会打开网页</span></span><br><span class="line">git <span class="built_in">help</span> config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 config 命令的快速参考手册</span></span><br><span class="line">git config -h</span><br></pre></td></tr></table></figure><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>在想要创建仓库的目录下启动 git 然后将文件跟踪提交即可在本地创建 git 仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化仓库</span></span><br><span class="line">git init</span><br><span class="line"><span class="comment"># 简要的显示文件状态</span></span><br><span class="line">git status -s | --short</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 跟踪会将文件放到暂存区</span></span><br><span class="line"><span class="comment"># 跟踪单个文件</span></span><br><span class="line">git add 文件名</span><br><span class="line"><span class="comment"># 跟踪目录下所有文件</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交文件,将会提交所有在暂存区的文件</span></span><br><span class="line">git commit -m <span class="string">&quot;更新描述&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 回滚，即将git仓库中文件版覆盖现有的文件版本</span></span><br><span class="line">git checkout -- 文件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件从暂存区移出</span></span><br><span class="line">git reset HEAD 文件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制提交所有已跟踪文件，跳过暂存阶段</span></span><br><span class="line">git commit -a -m <span class="string">&quot;更新描述&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时从git仓库和工作区中删除文件</span></span><br><span class="line">git rm -f 文件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅删除git仓库中的文件</span></span><br><span class="line">git rm --cached 文件名</span><br></pre></td></tr></table></figure><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>可以将不想提交的文件设置为忽略，这样文件就不会被 git 跟踪</p><p>创建一个名为.gitignore的配置文件，列出要忽略的文件的匹配模式。 文件 .gitignore 的格式规范如下： </p><p>① 以# 开头的是注释<br>② 以/结尾的是目录<br>③ 以/开头防止递归<br>④ 以!开头表示取反<br>⑤ 可以使用glob 模式进行文件和文件夹的匹配（glob 指简化了的正则表达式）</p><p>所谓的glob 模式是指简化了的正则表达式：<br>① 星号* 匹配零个或多个任意字符<br>② [abc] 匹配任何一个列在方括号中的字符（此案例匹配一个a或匹配一个b 或匹配一个c）<br>③ 问号?只匹配一个任意字符<br>④ 在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如[0-9] 表示匹配<br>所有0 到9 的数字）<br>⑤ 两个星号 ** 表示匹配任意中间目录（比如a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略所有的.a文件</span></span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跟踪所有的lib.a，即使前面设置了忽略.a文件</span></span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略当前目录下的TODO文件，而不忽略子目录下的TODO</span></span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略任何目录下名为build的文件夹</span></span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略doc/下的txt文件,但不忽略其子目录下的txt文件</span></span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略doc/目录及其所有子目录下的.pdf文件</span></span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure><h3 id="查看操作日志"><a href="#查看操作日志" class="headerlink" title="查看操作日志"></a>查看操作日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按时间降序列出提交历史</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示最近两条提交历史</span></span><br><span class="line">git <span class="built_in">log</span> -2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一行展示最近两条提交历史</span></span><br><span class="line">git <span class="built_in">log</span> -2 --pretty=oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义提交历史输出格式</span></span><br><span class="line"><span class="comment"># %h 提交的简写哈希值 %an作者名字 %ar作者修改日期 %s更新描述</span></span><br><span class="line">git <span class="built_in">log</span> -2 ---pretty=format:<span class="string">&quot;%h | %an | %ar | %s&quot;</span></span><br></pre></td></tr></table></figure><h3 id="回滚至指定版本"><a href="#回滚至指定版本" class="headerlink" title="回滚至指定版本"></a>回滚至指定版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回滚至指定ID的版本</span></span><br><span class="line">git reset --hard &lt;CommitID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br></pre></td></tr></table></figure><h3 id="将本地仓库推送至GitHub仓库"><a href="#将本地仓库推送至GitHub仓库" class="headerlink" title="将本地仓库推送至GitHub仓库"></a>将本地仓库推送至GitHub仓库</h3><p><strong>基于HTTPS</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关联远程仓库</span></span><br><span class="line">git remote add origin 远程仓库的地址</span><br><span class="line"><span class="comment"># 首次推送初始化</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p><strong>基于SSH</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成密钥对</span></span><br><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;github账号的邮箱&quot;</span></span><br><span class="line"><span class="comment"># 连续敲击 3 次回车，即可在 C:\Users\用户名文件夹\.ssh目录中生成id_rsa 和 id_rsa.pub 两个文件</span></span><br><span class="line"><span class="comment"># 复制id_rsa.pub的内容</span></span><br><span class="line"><span class="comment"># 在GitHub账号中添加公钥 Settings -&gt; SSH and GPG Keys -&gt; New SSH key</span></span><br><span class="line"><span class="comment"># 测试是否添加成功</span></span><br><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化操作类似HTTPS</span></span><br></pre></td></tr></table></figure><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前git仓库中的所有分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建分支</span></span><br><span class="line">git branch 分支名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换分支</span></span><br><span class="line">git checkout 分支名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建分支并切换到上面</span></span><br><span class="line">git checkout -b 分支名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并分支</span></span><br><span class="line">git merge 分支名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">git branch -d 分支名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送分支至远程仓库,仅第一次推送时要带-u参数</span></span><br><span class="line">git push -u 远程仓库别名(默认origin) 本地分支名称:远程分支名称</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例</span></span><br><span class="line">git push -u origin payment:pay <span class="comment"># 若不填写远程分支名称，远程分支名称将与本地分支一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看远程仓库分支信息</span></span><br><span class="line">git remote show 远程仓库名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载远程分支,本地分支名称默认与远程分支一致</span></span><br><span class="line">git checkout 远程分支名称</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从远程仓库把远程分支下载至本地，并对下载至本地的分支重命名</span></span><br><span class="line">git checkout -b 本地分支名称 远程仓库名:远程分支名称</span><br><span class="line"><span class="comment"># 实例</span></span><br><span class="line">git checkout -b payment origin/pay</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取当前分支中的远程分支代码</span></span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定远程分支</span></span><br><span class="line">git push 远程仓库名称 --delete 远程分支名称</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例</span></span><br><span class="line">git push origin --delete pay</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="tools" scheme="http://example.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>同源与跨域</title>
    <link href="http://example.com/2021/10/29/2021-10-29-%E5%90%8C%E6%BA%90%E4%B8%8E%E8%B7%A8%E5%9F%9F/"/>
    <id>http://example.com/2021/10/29/2021-10-29-%E5%90%8C%E6%BA%90%E4%B8%8E%E8%B7%A8%E5%9F%9F/</id>
    <published>2021-10-29T08:05:28.000Z</published>
    <updated>2021-11-02T01:53:12.464Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="域"><a href="#域" class="headerlink" title="域"></a>域</h2><p>在了解什么是同源和跨域之前我们首先要明确在浏览器中什么是域。浏览器中由协议名、服务器地址、端口号组成一个域。<img src="https://i.loli.net/2021/10/29/lLjnOkM3rZ6Q4m2.png" alt="默认网站的端口为80可以省略"></p><p><strong>同源</strong>指的是两个 URL 的协议、域名、端口一致，反之，则是<strong>跨域</strong>。</p><p>出现跨域的根本原因：<strong>浏览器的同源策略</strong>不允许非同源的 URL 之间进行资源的交互。</p><p>网页访问资源时，只要 url 的协议名、服务器地址、端口号中任何一个发生了改变就会产生跨域问题。</p><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>为了确保用户的上网安全，浏览器采用了同源策略来防止入侵。如果两个页面的协议，域名和端口都相同，则两个页面具有<strong>相同的源</strong>。。同源策略就是浏览器规定网页请求数据只能在同源站点中请求，不能跨域请求资源。浏览器规定，A 网站的 JavaScript，不允许和非同源的网站 C 之间，进行资源的交互。虽然我们的网络请求可以正常发送，服务器也会正常响应资源，但到浏览器这层资源就会被拦截下来，我们的 js 代码无法得到数据。例如：</p><p>①无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB</p><p>②无法接触非同源网页的 DOM</p><p>③无法向非同源地址发送 Ajax 请求</p><p><img src="https://i.loli.net/2021/10/29/nFq7L2iQuZzObN8.png" alt="数据被拦截"></p><h2 id="跨域解决方法"><a href="#跨域解决方法" class="headerlink" title="跨域解决方法"></a>跨域解决方法</h2><p>现如今，实现跨域数据请求，最主要的两种解决方案，分别是 JSONP 和 CORS。</p><p>JSONP：出现的早，兼容性好（兼容低版本IE）。是前端程序员为了解决跨域问题，被迫想出来的一种临时解决方案。缺点是只支持 GET 请求，不支持 POST 请求。</p><p>CORS：出现的较晚，它是 W3C 标准，属于跨域 Ajax 请求的根本解决方案。支持 GET 和 POST 请求。缺点是不兼容某些低版本的浏览器。</p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP (JSON with Padding) 是 JSON 的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。</p><p>由于浏览器同源策略的限制，网页中无法通过 Ajax 请求非同源的接口数据。但是 &lt;script&gt;标签不受浏览器同源策略的影响，可以通过 src 属性，请求非同源的 js 脚本。</p><p>因此，JSONP 的实现原理，就是通过 &lt;script&gt; 标签的 src 属性，请求跨域的数据接口，并通过<strong>函数调用</strong>的形式，接收跨域接口响应回来的数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//在这个标签页面定义函数</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> a + b;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//在另一个标签页调用函数</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://函数定义地址?callback=foo&amp;a=10s&amp;b=20&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于 JSONP 是通过 &lt;script&gt; 标签的 src 属性，来实现跨域数据获取的，所以，<strong>JSONP 只支持 GET 数据请求</strong>，不支持 POST 请求。</p><p><strong>JSONP</strong> <strong>和</strong> <strong>Ajax</strong> <strong>之间没有任何关系</strong>，不能把 JSONP 请求数据的方式叫做 Ajax，因为 JSONP 没有用到 XMLHttpRequest 这个对象。</p><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS （Cross-Origin Resource Sharing，跨域资源共享）由一系列 HTTP 响应头组成，<strong>这些</strong> <strong>HTTP</strong> <strong>响应头决定浏览器是否阻止前端</strong> <strong>JS</strong> <strong>代码跨域获取资源</strong>。</p><p>①CORS 主要在服务器端进行配置。客户端浏览器<strong>无须做任何额外的配置</strong>，即可请求开启了 CORS 的接口。</p><p>②CORS 在浏览器中有兼容性。只有支持 XMLHttpRequest Level2 的浏览器，才能正常访问开启了 CORS 的服务端接口（例如：IE10+、Chrome4+、FireFox3.5+）。</p><h3 id="CORS响应头部-Access-Control-Allow-Origin"><a href="#CORS响应头部-Access-Control-Allow-Origin" class="headerlink" title="CORS响应头部- Access-Control-Allow-Origin"></a>CORS响应头部- Access-Control-Allow-Origin</h3><p>响应头部中可以携带一个 <strong>Access-Control-Allow-Origin</strong> 字段，其语法如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin:&lt;origin&gt; | * //*为通配符</span><br></pre></td></tr></table></figure><p>其中，origin 参数的值指定了允许访问该资源的外域 URL。</p><p>例如，下面的字段值将<strong>只允许</strong>来自 <a href="http://asuhe.fun/">http://asuhe.fun</a> 的请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>,<span class="string">&#x27;http://asuhe.fun&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="CORS响应头部-Access-Control-Allow-Headers"><a href="#CORS响应头部-Access-Control-Allow-Headers" class="headerlink" title="CORS响应头部- Access-Control-Allow-Headers"></a>CORS响应头部- Access-Control-Allow-Headers</h3><p>默认情况下，CORS <strong>仅</strong>支持客户端向服务器发送如下的 9 个请求头：</p><p><strong>Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type （值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一）</strong></p><p>如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 Access-Control-Allow-Headers 对额外的请求头进行声明，否则这次请求会失败！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//允许客户端额外向服务器发送Content-Type请求头和X-Custom-Header请求头</span></span><br><span class="line">res.setHeader(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>,<span class="string">&#x27;Content-Type,X-Custon-Header&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="CORS响应头部-Access-Control-Allow-Methods"><a href="#CORS响应头部-Access-Control-Allow-Methods" class="headerlink" title="CORS响应头部- Access-Control-Allow-Methods"></a>CORS响应头部- Access-Control-Allow-Methods</h3><p>默认情况下，CORS 仅支持客户端发起 <strong>GET、POST、HEAD</strong> 请求。</p><p>如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 Access-Control-Alow-Methods来指明实际请求所允许使用的 HTTP 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//仅允许POST,GET,DELETE,HEAD方法</span></span><br><span class="line">res.setHeader(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>,<span class="string">&#x27;POST,GET,DELETE,HEAD&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//允许所有HTTP方法</span></span><br><span class="line">res.setHeader(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>,<span class="string">&#x27;*&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="CORS请求的分类"><a href="#CORS请求的分类" class="headerlink" title="CORS请求的分类"></a>CORS请求的分类</h3><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>同时满足以下两大条件的请求，就属于简单请求：</p><p>① 请求方式：GET、POST、HEAD 三者之一</p><p>② HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值application/x-www-form-urlencoded、multipart/form-data、text/plain）</p><h4 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h4><p>只要符合以下任何一个条件的请求，都需要进行预检请求：</p><p>① 请求方式为 GET、POST、HEAD 之外的请求 Method 类型</p><p>② 请求头中包含自定义头部字段</p><p>③ 向服务器发送了 application/json 格式的数据</p><p>在浏览器与服务器正式通信之前，浏览器会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求，所以这一次的 OPTION 请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据。</p><p><strong>其中OPTION预检请求的请求体为空，若预检成功则服务器返回的响应体也为空</strong></p><p><strong>简单请求的特点</strong>：客户端与服务器之间只会发生一次请求。</p><p><strong>预检请求的特点</strong>：客户端与服务器之间会发生两次请求，OPTION 预检请求成功之后，才会发起真正的请求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="BOM" scheme="http://example.com/tags/BOM/"/>
    
  </entry>
  
  <entry>
    <title>防抖与节流</title>
    <link href="http://example.com/2021/10/29/2021-10-29-%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
    <id>http://example.com/2021/10/29/2021-10-29-%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</id>
    <published>2021-10-29T07:11:24.000Z</published>
    <updated>2021-10-29T08:04:31.404Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>什么是防抖，在操作系统中如果一块数据在短时间内频繁地由内存换出到外存，再由外存换入内存。这种内存频繁进行换入换出的现象我们称之为内存抖动。类似的在前端中，如果一个页面过于地进行频繁地触发事件我们也将这种行为称之为抖动。</p><p><strong>防抖策略</strong>（debounce）是当事件被触发后，延迟 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。</p><p><img src="https://i.loli.net/2021/10/29/EYTveZJrRH21wV8.png" alt="防抖"></p><p>防抖最典型的应用例子就是我们在淘宝上进行商品搜索的时候，每当我们输入一个关键字，搜索框下面就会弹出相应关键字的搜索结果。</p><p><img src="https://i.loli.net/2021/10/29/YRlbuQnFfctiPZ6.png" alt="淘宝搜索匹配"></p><p>这里如果我们设置的是每当用户弹起键盘我们就发送一次ajax请求去刷新数据，那么在输入过程中就会导致太多的ajax请求被发送，造成抖动。所以我们需要减少一些不必要的网络请求来减轻服务器压力。</p><p><strong>代码实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置一个定时器记录</span></span><br><span class="line"><span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">ipt.addEventListener(<span class="string">&#x27;keyup&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//每次键盘按下就清除定时器,延迟触发</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    <span class="comment">//设置200ms后触发事件</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">/*进行相应操作*/</span></span><br><span class="line">    &#125;,<span class="number">200</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>和防抖类似减少事件触发的概念就是节流，节流的目的是让事件在规定的时间间隔内只能触发一次。和操作系统里同步问题使用互斥锁的思想类似。我们可以在触发某类事件时，先让它判断目前是否可以进入，若可以进入就让它进入后立即将flag置为false使后续事件不能继续进入，退出前在将flag置为true。</p><p><strong>节流策略</strong>（throttle），顾名思义，可以减少一段时间内事件的触发频率。</p><p><img src="https://i.loli.net/2021/10/29/iedsbl8ULn5Qyrq.png" alt="节流"></p><p>节流最典型的应用就是懒加载时要监听计算滚动条的位置，但不必每次滑动都触发，可以降低计算的频率，而不必去浪费 CPU 资源</p><p><strong>代码实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个节流阀</span></span><br><span class="line"><span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="comment">//关闭节流阀</span></span><br><span class="line">        flag = flase;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">/*进行相应操作*/</span></span><br><span class="line">            <span class="comment">//1000ms后开启节流阀</span></span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>防抖：如果事件被频繁触发，防抖能保证只有最后一次触发生效，前面 N 多次的触发都会被忽略！</p><p>节流：如果事件被频繁触发，节流能够减少事件触发的频率，因此，节流是有选择性地执行一部分事件！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="BOM" scheme="http://example.com/tags/BOM/"/>
    
  </entry>
  
  <entry>
    <title>http协议</title>
    <link href="http://example.com/2021/10/28/2021-10-28-http%E5%8D%8F%E8%AE%AE/"/>
    <id>http://example.com/2021/10/28/2021-10-28-http%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-10-28T00:43:22.000Z</published>
    <updated>2021-11-02T01:46:50.776Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是HTTP协议"><a href="#什么是HTTP协议" class="headerlink" title="什么是HTTP协议"></a>什么是HTTP协议</h2><p><strong>HTTP 协议</strong>即超文本传送协议 (HyperText Transfer Protocol) ，使用经典的<a href="https://en.wikipedia.org/wiki/Client%E2%80%93server_model">C/S模式</a>交互，它规定了客户端与服务器之间进行网页内容传输时，所必须遵守的传输格式。</p><p>在<a href="https://en.wikipedia.org/wiki/Internet_protocol_suite">TCP/IP网络模型</a>中，它位于<a href="https://en.wikipedia.org/wiki/Application_layer">应用层</a>采用传输层采用的是<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a>协议，端口号默认是<strong>80</strong>。虽然它采用的是TCP协议，但它实际上是一个<strong>无连接</strong>协议，这里的无连接是指服务器每次处理完客户端请求并收到客户端的响应回答后就会马上断开连接，并不会一直维持会话连接状态。同时它是一个<a href="https://en.wikipedia.org/wiki/Stateless_protocol">无状态协议</a>，即它并不会记录前后报文之间的关系。每一个请求报文在它看来都是独立的，没有上下文联系。这就给我们实际运用的时候带来了一些麻烦，例如在购物网站购买商品时，我们商品加入自己账号的购物车这就需要上下文联系。为了解决这个问题于是就有了<a href="/2021/11/02/2021-11-02%20%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/" title="cookie-session机制">cookie-session机制</a>来帮助我们建立上下文联系。</p><h2 id="为什么要HTTP协议"><a href="#为什么要HTTP协议" class="headerlink" title="为什么要HTTP协议"></a>为什么要HTTP协议</h2><p>它是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的，例如现在的电子邮箱流行使用http协议去传输内容。</p><h2 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h2><p>http的报文可以大致分为请求报文和响应报文两种，请求报文即为客户端向服务器发送的请求消息，而响应报文则是服务器根据客户端的请求响应回去的消息。</p><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p>HTTP 请求消息由请求行（request line）、请求头部（ header ） 、空行 和 请求体 4 个部分组成。</p><p><img src="https://i.loli.net/2021/10/28/MtukAIinQ2JCNvs.png" alt="请求报文基本格式"></p><h3 id="常见的请求头部"><a href="#常见的请求头部" class="headerlink" title="常见的请求头部"></a>常见的请求头部</h3><table><thead><tr><th><strong>头部字段</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Host</td><td>要请求的服务器域名</td></tr><tr><td>Connection</td><td>客户端与服务器的连接方式(close  或  keepalive)</td></tr><tr><td>Content-Length</td><td>用来描述请求体的大小</td></tr><tr><td><strong>Accept</strong></td><td>客户端可识别的响应内容类型列表</td></tr><tr><td><strong>User-Agent</strong></td><td>产生请求的浏览器类型</td></tr><tr><td><strong>Content-Type</strong></td><td>客户端告诉服务器实际发送的数据类型</td></tr><tr><td>Accept-Encoding</td><td>客户端可接收的内容压缩编码形式</td></tr><tr><td><strong>Accept-Language</strong></td><td>用户期望获得的自然语言的优先顺序</td></tr></tbody></table><p>我们可以在浏览器里具体抓一个请求报头来看看</p><p><img src="https://i.loli.net/2021/10/28/u236vDXOYrzJGZA.png" alt="GET请求头"></p><p><img src="https://i.loli.net/2021/10/28/dF9bL3phfgrlaRK.png" alt="POST请求头"></p><p>从上面请求头的对比中里我们可以得知一个结论。GET请求和POST请求的一个重要区别就是<strong>GET请求方式中，我们要发送的数据会携带在请求报头中，实际的请求体是为空的。而在POST请求方式中，我们要提交的数据会携带在请求体中，并不会夹带在请求头中。</strong></p><h3 id="响应报头"><a href="#响应报头" class="headerlink" title="响应报头"></a>响应报头</h3><p>HTTP响应消息由状态行、响应头部、空行 和 响应体 4 个部分组成，如下图所示：</p><p><img src="https://i.loli.net/2021/10/28/tq61CS3xo5hWckb.png" alt="响应报文基本格式"></p><p>实际浏览器中的响应报头</p><p><img src="https://i.loli.net/2021/10/28/rk643O5sEK9ljdp.png" alt="GET响应报头"></p><p><img src="https://i.loli.net/2021/10/28/2MERcynikH4O8T3.png" alt="POST响应报头"></p><h2 id="http请求方法"><a href="#http请求方法" class="headerlink" title="http请求方法"></a>http请求方法</h2><table><thead><tr><th><strong>序号</strong></th><th align="center"><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>1</td><td align="center"><strong>GET</strong></td><td>(查询)发送请求来获得服务器上的资源，请求体中不会包含请求数据，请求数据放在协议头中。</td></tr><tr><td>2</td><td align="center"><strong>POST</strong></td><td>(新增)向服务器提交资源（例如提交表单或上传文件）。数据被包含在请求体中提交给服务器。</td></tr><tr><td>3</td><td align="center"><strong>PUT</strong></td><td>(修改)向服务器提交资源，并使用提交的新资源，替换掉服务器对应的旧资源。</td></tr><tr><td>4</td><td align="center"><strong>DELETE</strong></td><td>(删除)请求服务器删除指定的资源。</td></tr><tr><td>5</td><td align="center">HEAD</td><td>HEAD  方法请求一个与 GET 请求的响应相同的响应，但没有响应体。</td></tr><tr><td>6</td><td align="center">OPTIONS</td><td>获取http服务器支持的http请求方法，允许客户端查看服务器的性能，比如ajax跨域时的预检等。</td></tr><tr><td>7</td><td align="center">CONNECT</td><td>建立一个到由目标资源标识的服务器的隧道。</td></tr><tr><td>8</td><td align="center">TRACE</td><td>沿着到目标资源的路径执行一个消息环回测试，主要用于测试或诊断。</td></tr><tr><td>9</td><td align="center">PATCH</td><td>是对  PUT 方法的补充，用来对已知资源进行局部更新 。</td></tr></tbody></table><h2 id="http响应状态码"><a href="#http响应状态码" class="headerlink" title="http响应状态码"></a>http响应状态码</h2><p>http的状态码可以分为5大类型</p><table><thead><tr><th align="center">分类</th><th align="left"><strong>分类描述</strong></th></tr></thead><tbody><tr><td align="center">1**</td><td align="left">信息，服务器收到请求，需要请求者继续执行操作（实际开发中很少遇到  1**  类型的状态码）</td></tr><tr><td align="center">2**</td><td align="left">成功，操作被成功接收并处理</td></tr><tr><td align="center">3**</td><td align="left">重定向，需要进一步的操作以完成请求</td></tr><tr><td align="center">4**</td><td align="left">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td align="center">5**</td><td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><h3 id="成功相关的响应状态码"><a href="#成功相关的响应状态码" class="headerlink" title="成功相关的响应状态码"></a>成功相关的响应状态码</h3><p>2** 范围的状态码，表示服务器已成功接收到请求并进行处理。常见的 2** 类型的状态码如下：</p><table><thead><tr><th align="center"><strong>状态码</strong></th><th align="center"><strong>状态码英文名称</strong></th><th><strong>中文描述</strong></th></tr></thead><tbody><tr><td align="center">200</td><td align="center">OK</td><td>请求成功。一般用于  GET 与 POST  请求</td></tr><tr><td align="center">201</td><td align="center">Created</td><td>已创建。成功请求并创建了新的资源，通常用于  POST 或 PUT  请求</td></tr></tbody></table><h3 id="重定向相关的响应状态码"><a href="#重定向相关的响应状态码" class="headerlink" title="重定向相关的响应状态码"></a>重定向相关的响应状态码</h3><p>3** 范围的状态码，表示表示服务器要求客户端重定向，需要客户端进一步的操作以完成资源的请求。常见的 3** 类型的状态码如下：</p><table><thead><tr><th align="center">状态码</th><th align="center"><strong>状态码英文名称</strong></th><th><strong>中文描述</strong></th></tr></thead><tbody><tr><td align="center">301</td><td align="center">Moved  Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td align="center">302</td><td align="center">Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td align="center">304</td><td align="center">Not  Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源（响应消息中不包含响应体）。客户端通常会缓存访问过的资源。</td></tr></tbody></table><h3 id="客户端错误相关的响应状态码"><a href="#客户端错误相关的响应状态码" class="headerlink" title="客户端错误相关的响应状态码"></a>客户端错误相关的响应状态码</h3><p>4** 范围的状态码，表示客户端的请求有非法内容，从而导致这次请求失败。常见的 4** 类型的状态码如下：</p><table><thead><tr><th align="center"><strong>状态码</strong></th><th align="center"><strong>状态码英文名称</strong></th><th><strong>中文描述</strong></th></tr></thead><tbody><tr><td align="center">400</td><td align="center">Bad  Request</td><td>语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。</td></tr><tr><td align="center">401</td><td align="center">Unauthorized</td><td>当前请求需要用户验证。</td></tr><tr><td align="center">403</td><td align="center">Forbidden</td><td>服务器已经理解请求，但是拒绝执行它。</td></tr><tr><td align="center">404</td><td align="center">Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。</td></tr><tr><td align="center">408</td><td align="center">Request  Timeout</td><td>请求超时。服务器等待客户端发送的请求时间过长，超时。</td></tr></tbody></table><h3 id="服务端错误相关的响应状态码"><a href="#服务端错误相关的响应状态码" class="headerlink" title="服务端错误相关的响应状态码"></a>服务端错误相关的响应状态码</h3><p>5** 范围的状态码，表示服务器未能正常处理客户端的请求而出现意外错误。前端甩锅码，只要出现5开头的响应码全部甩锅后端哈哈。常见的 5** 类型的状态码如下：</p><table><thead><tr><th align="center"><strong>状态码</strong></th><th align="center"><strong>状态码英文名称</strong></th><th><strong>中文描述</strong></th></tr></thead><tbody><tr><td align="center">500</td><td align="center">Internal  Server Error</td><td>服务器内部错误，无法完成请求。</td></tr><tr><td align="center">501</td><td align="center">Not  Implemented</td><td>服务器不支持该请求方法，无法完成请求。只有  GET 和 HEAD  请求方法是要求每个服务器必须支持的，其它请求方法在不支持的服务器上会返回501</td></tr><tr><td align="center">503</td><td align="center">Service  Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="CN" scheme="http://example.com/tags/CN/"/>
    
  </entry>
  
  <entry>
    <title>模板引擎的使用</title>
    <link href="http://example.com/2021/10/26/2021-10-26-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2021/10/26/2021-10-26-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2021-10-26T09:40:51.000Z</published>
    <updated>2021-10-27T00:41:16.535Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是模板引擎"><a href="#什么是模板引擎" class="headerlink" title="什么是模板引擎"></a>什么是模板引擎</h2><p>在我们要渲染相同的UI结构，如新闻列表、博客的文章列表时，用传统的方法我们需要大量拼接字符串。这使得代码运行效率低，页面加载也慢。不仅如此，当我们需要修改结构时，也需要在字符串中修改这使得代码维护起来十分麻烦而且灵活性非常差。</p><p>为了解决传统的方法的缺点，于是我们发明了模板引擎技术。使用模板引擎我们可以快速渲染出UI，同时由于清晰的模板结构我们要修改代码时也十分容易。</p><h2 id="art-template"><a href="#art-template" class="headerlink" title="art - template"></a>art - template</h2><p>art-template 是一个简约、超快的模板引擎，使用这个模板引擎我们可以很方便地生成一些UI结构。</p><h2 id="模板使用步骤"><a href="#模板使用步骤" class="headerlink" title="模板使用步骤"></a>模板使用步骤</h2><p>①导入 art-template</p><p>②定义数据</p><p>③定义模板</p><p>④调用 template 函数</p><p>⑤渲染HTML结构</p><h2 id="art-template基础语法"><a href="#art-template基础语法" class="headerlink" title="art-template基础语法"></a>art-template基础语法</h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>在标准语法中，可以进行变量的输出、对象属性的输出、三元表达式输出、逻辑或输出、加减乘除等表达式输出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;value&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;obj.key&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;obj[<span class="string">&#x27;key&#x27;</span>]&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;a ? b : c&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;a || b&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;a + b&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="原文输出"><a href="#原文输出" class="headerlink" title="原文输出"></a>原文输出</h3><p>如果要输出的 value 值中，包含了 HTML 标签结构，则需要使用<strong>原文输出</strong>语法，才能保证 HTML 标签被正常渲染。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;@ value &#125;&#125;  //类似innerHTML,会将value的文本内容当作HTML渲染</span><br></pre></td></tr></table></figure><h3 id="条件输出"><a href="#条件输出" class="headerlink" title="条件输出"></a>条件输出</h3><p>如果要实现条件输出，则可以在双花括号中使用 <strong>if</strong> … <strong>else if</strong> … <strong>/if</strong> 的方式，进行按需输出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;<span class="keyword">if</span> value&#125;&#125; 按需输出的内容 &#123;&#123;/<span class="keyword">if</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;<span class="keyword">if</span> v1&#125;&#125; 按需输出的内容 &#123;&#123;<span class="keyword">else</span> <span class="keyword">if</span> v2&#125;&#125; 按需输出的内容 &#123;&#123;/<span class="keyword">if</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>如果要实现循环输出，则可以在标准语法内，通过 each 语法循环数组，当前循环的索引使用 <strong>$index</strong> 进行访问，当前的循环项使用 <strong>$value</strong> 进行访问。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;each arr&#125;&#125;</span><br><span class="line">    &#123;&#123;$index&#125;&#125; &#123;&#123;$value&#125;&#125;</span><br><span class="line">&#123;&#123;/each&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>过滤器语法类似<strong>管道操作符</strong>，它的上一个输出作为下一个输入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;value | 处理函数名称&#125;&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//js文件中定义好处理函数的操作</span></span><br><span class="line">template.defaults.imports.处理函数名称 = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123; <span class="comment">//传入值为模板的value</span></span><br><span class="line">    <span class="comment">/*Code*/</span></span><br><span class="line">    <span class="keyword">return</span> res <span class="comment">//返回处理结果</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>注册时间：&#123;&#123;regTime | dateFormat&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template.defaults.imports.dateFormat = <span class="function"><span class="keyword">function</span>(<span class="params">date</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> y = date.getFullYear()</span><br><span class="line">   <span class="keyword">var</span> m = date.getMonth() + <span class="number">1</span></span><br><span class="line">   <span class="keyword">var</span> d = date.getDate()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> y + <span class="string">&#x27;-&#x27;</span> + m + <span class="string">&#x27;-&#x27;</span> + d <span class="comment">// 注意，过滤器最后一定要 return 一个值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="tips" scheme="http://example.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的继承</title>
    <link href="http://example.com/2021/10/23/2021-10-23-JavaScript%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
    <id>http://example.com/2021/10/23/2021-10-23-JavaScript%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/</id>
    <published>2021-10-23T00:33:54.000Z</published>
    <updated>2021-10-27T00:27:40.038Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="ES6以前"><a href="#ES6以前" class="headerlink" title="ES6以前"></a>ES6以前</h2><p>在es6以前 js 并没有专门的关键字可以实现继承特性，但是那时候我们又需要使用继承。于是就产生了一些方法可以实现继承的效果</p><h3 id="call调用实现继承父属性"><a href="#call调用实现继承父属性" class="headerlink" title="call调用实现继承父属性"></a>call调用实现继承父属性</h3><p>我们都知道<code>call</code>可以改变函数内<code>this</code>的指向，利用这个特性我们可以在子构造函数里面调用父构造函数，并利用<code>call</code>让父构造函数内的<code>this</code>指向子构造函数。这样就完成了继承操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = uname;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line">    Father.call(<span class="built_in">this</span>,uname,age); <span class="comment">//调用父构造函数，利用call传入自身的this实现继承</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用原型对象实现继承父方法"><a href="#利用原型对象实现继承父方法" class="headerlink" title="利用原型对象实现继承父方法"></a>利用原型对象实现继承父方法</h3><p>我们还可以通过让子构造函数的<code>prototype</code>指向一个父构造函数的实例的形式实现继承，不过需要注意的是在赋值完成后我们需要让<code>constructor</code>属性重新指回子构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = uname;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line">Father.prototype.say = <span class="function">()=&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;hello!&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = uname;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Son.prototype = Father.prototype 若我们直接赋值，会导致Son的原型对象和Father的原型对象是同一个，在Son中修改原型对象同时也会修改Father的。所以这样赋值是错误的</span></span><br><span class="line"></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();  <span class="comment">//通过一个Father实例化对象可以间接访问到Father的prototype</span></span><br><span class="line">Son.prototype.constructor = Son; <span class="comment">//让constructor指回Son构造函数，不然其会指向Father构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son(<span class="string">&#x27;Asuka&#x27;</span>,<span class="number">16</span>);</span><br><span class="line">son.say(); <span class="comment">//hello！</span></span><br></pre></td></tr></table></figure><h2 id="ES6以后"><a href="#ES6以后" class="headerlink" title="ES6以后"></a>ES6以后</h2><p>es6中引入了<code>class</code>关键字同时也引入了<code>extends</code>关键字，利用这些关键字我们可以很轻易的实现继承。同时若我们想要调用父类的方法和属性只需要使用<code>super</code>关键字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = uname;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;hello!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">uname,age,sex</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(uname,age); <span class="comment">//直接使用，调用父类constructor.一定要在this之前，不然SyntaxError</span></span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>.say();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;hi!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son(<span class="string">&#x27;Asuhe&#x27;</span>,<span class="number">16</span>,<span class="string">&#x27;male&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(son); <span class="comment">//Son &#123; name: &#x27;Asuhe&#x27;, age: 16, sex: &#x27;male&#x27; &#125;</span></span><br><span class="line">son.say();  <span class="comment">// hello! hi!</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>ES6新增特性</title>
    <link href="http://example.com/2021/10/22/2021-10-22-ES6%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2021/10/22/2021-10-22-ES6%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7/</id>
    <published>2021-10-22T00:14:57.000Z</published>
    <updated>2021-10-27T00:29:09.501Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="let关键字"><a href="#let关键字" class="headerlink" title="let关键字"></a>let关键字</h2><h3 id="作用域绑定在最近的-…-块中"><a href="#作用域绑定在最近的-…-块中" class="headerlink" title="作用域绑定在最近的{…}块中"></a>作用域绑定在最近的{…}块中</h3><p><code>let</code>在使用时会绑定离它最近的{…}作为作用域。原本在ES6以前是没有块级作用域的概念，在ES6引入了<code>let、const</code>关键字之后就有了块级作用域。<strong>实际上这个块级作用域并不是我们平常理解的块级作用域，仅当变量是由<code>let、const</code>关键字声明时，这些关键字声明的变量其作用域会绑定在这个块上，若是使用<code>var</code>关键字声明，其变量依然会成为全局变量。</strong></p><p>使用这个特性我们可以很好的解决 for 循环全局变量污染的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><h3 id="无变量提升"><a href="#无变量提升" class="headerlink" title="无变量提升"></a>无变量提升</h3><p><code>let</code>关键字在使用的时候，不像<code>var</code>那样存在变量提升的情况。它必须先声明再使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//ReferenceError</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"><span class="comment">//上述代码等价于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a;  <span class="comment">//var变量提升至所在作用域顶部</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//ReferenceError</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>所谓暂时性死区就是，你在块级作用域使用<code>let</code>声明了一个变量<code>i</code>，同时你在外部作用域也声明的一个同名变量<code>i</code>。若你在<code>let</code>声明这个变量前使用它，它并不会像以前的那样去上级作用域寻找这个变量，仅会在该作用域内寻找变量，又因为变量使用<code>let</code>声明，并且声明在其使用之后，就会抛出ReferenceError。<strong>因为使用<code>let</code>在作用域内声明了同名变量，它会屏蔽外界变量，这个块级区域就被称为暂时性死区</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//if&#123;&#125;内形成暂时性死区</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">-------------</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//不是同名变量，没有暂时性死区</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 20</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><h3 id="声明时必须赋值"><a href="#声明时必须赋值" class="headerlink" title="声明时必须赋值"></a>声明时必须赋值</h3><p><code>const</code>关键字的特性和<code>let</code>相同，<code>let</code>有的特性<code>const</code>都具有。不同点是<strong>它在声明的同时必须赋予一个值</strong>，否则抛出SyntaxError。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a;  <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure><h3 id="赋值后不可改变"><a href="#赋值后不可改变" class="headerlink" title="赋值后不可改变"></a>赋值后不可改变</h3><p>这里<code>const</code>关键字声明的变量能否更改还需要看具体的情况。</p><p>若<code>const</code>声明的是一个基本数据类型，则不能更改其值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">20</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>但是如果<code>const</code>声明的是一个复杂数据类型，则可以更改复杂数据类型变量内部的值，不可更改该复杂数据类型变量本身</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">100</span>; </span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// [1,100,3]</span></span><br><span class="line">b = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]; <span class="comment">//TypeError</span></span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>最初使用箭头函数的目的就是为了简化函数声明的操作，但它的作用不仅如此。我们都知道<code>this</code>指针的指向在不同地方其指向不同，例如在构造函数中其指向就是它的实例化对象，在<code>class</code>中的<code>constructor</code>中也是同样的指向自身的实例化对象，而在普通函数中其指向的是函数的调用者。</p><h3 id="箭头函数中的this是根据上下文环境确定的"><a href="#箭头函数中的this是根据上下文环境确定的" class="headerlink" title="箭头函数中的this是根据上下文环境确定的"></a>箭头函数中的<code>this</code>是根据上下文环境确定的</h3><p>箭头函数<code>this</code>指向的是<strong>被声明的作用域里面</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.querSelector(<span class="string">&#x27;.btn&#x27;</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line"><span class="comment">//在定时器的回调函数中使用箭头函数则其this会根据上下文指向btn对象，而不是指向window</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// btn</span></span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多种简写形式"><a href="#多种简写形式" class="headerlink" title="多种简写形式"></a>多种简写形式</h3><p>当形参只有一个且函数体内仅有一句返回值时</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="params">n</span> =&gt;</span> n*<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价一</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n*<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价二</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n*<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">a,b</span>) =&gt;</span> a+b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价一</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价二</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><h3 id="数组的解构"><a href="#数组的解构" class="headerlink" title="数组的解构"></a>数组的解构</h3><p>在es6中我们可以使用新的方式来命名多个变量，这种新的声明赋值方式就叫解构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统命名多个变量并赋值的方式</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>,b = <span class="number">20</span>,c = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//采用数组解构的方式</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>];</span><br><span class="line"><span class="keyword">let</span> [a,b,c] = arr;  <span class="comment">//a = 10,b = 20,c = 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当变量数量大于数组长度</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> [a,b,c,d] = arr; <span class="comment">//a = 1,b = 2, c = 3,d = undefined //多余的变量为未定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当变量数量少于数组长度</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> [a,b] = arr; <span class="comment">//a = 1,b = 2  //多余的直接被截断</span></span><br><span class="line"></span><br><span class="line">--------------</span><br><span class="line"><span class="comment">//对象解构</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;Asuhe&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>:myname,<span class="attr">age</span>:myage,<span class="attr">sex</span>:mysex&#125; = obj; <span class="comment">//myname = &#x27;Asuhe&#x27;,myage = 18,mysex = &#x27;男&#x27; //按匹配相同名称，即使乱序也会匹配上</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">let</span> myname = <span class="string">&#x27;Asuhe&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> myage = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">let</span> sex = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line"><span class="keyword">let</span> &#123;name,age,sex&#125; = obj;</span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Asuhe&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">let</span> sex = <span class="string">&#x27;男&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><p>在es6中新扩展了一种方法可以使函数的形参接收不定数量的实参，那就是使用<strong>剩余参数</strong>。我们知道在以前js同样支持函数形参和实参数量不匹配，即使定义函数时形参列表为空我们依然可以使用<code>arguments</code>对象获取到实参。<strong>但在es6新增的箭头函数中并不支持<code>arguments</code>，所以es6扩展了<code>...args</code>剩余参数来解决这个问题。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统获取所有形参</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">//2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">2</span>]); <span class="comment">//3</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用剩余参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,...args</span>)</span>&#123; <span class="comment">//剩余参数必须放在最后一个形参的位置</span></span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">console</span>.log(args); <span class="comment">//[2,3,4,5] //以数组的形式存储值</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>原型与原型链</title>
    <link href="http://example.com/2021/10/20/2021-10-20-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://example.com/2021/10/20/2021-10-20-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</id>
    <published>2021-10-20T00:04:04.000Z</published>
    <updated>2021-10-27T00:28:57.140Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是原型"><a href="#什么是原型" class="headerlink" title="什么是原型"></a>什么是原型</h2><p>在搞明白什么是原型之前我们首先要明白我们为什么要原型，毕竟语言的设计者不会无缘无故搞出一个完全没有用的东西，它肯定是为了解决某个问题而诞生的。那么原型它解决了什么问题呢？</p><p>我们都知道在es6之前，js是没有关键字<code>class</code>创建类的。那时候我们要使用类就用构造函数这种形式来实现它。在C++这种原生支持类的语言中，同一个类的多个实例里的方法只有一份，也就是说不管我们实例化了多少个对象，在计算机的内存中这个类的方法在内存中只有一份。只有每个实例的属性才会在内存中产生多个副本。例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">getName</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.name; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.age; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    foo a = <span class="keyword">new</span> <span class="built_in">foo</span>();</span><br><span class="line">    foo b = <span class="keyword">new</span> <span class="built_in">foo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在计算机的内存中，a、b这两个实例化对象的内存分布仅有private里的属性才有独立的内存副本，而public里的方法a、b是共享同一片内存的，这样设计就节约了内存空间。</p><p><img src="https://i.loli.net/2021/10/20/2PxV6KqCkLseEaQ.png" alt="C++的类方法只占一份内存"></p><p>而在es6以前没有<code>class</code>时候，我们通过构造函数实例化的类就会出现上图的第一种情况。每个实例的方法都有独有的内存空间。为了解决这个问题，所以就出现了原型。构造函数通过原型分配的函数是所有对象所共享的，也就实现了第二种内存分布。</p><h2 id="如何使用原型"><a href="#如何使用原型" class="headerlink" title="如何使用原型"></a>如何使用原型</h2><p>JavaScript 规定，每一个构造函数都有一个prototype 属性，指向prototype对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。</p><p>我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = uname;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="comment">//定义类共享的方法时我们将方法定义在原型上，而不是构造函数内部</span></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;哈喽&#x27;</span>); &#125;;  <span class="comment">//这样定义方法，多个实例对象就可以共享</span></span><br><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> Person(<span class="string">&#x27;Asuhe&#x27;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> woman = <span class="keyword">new</span> Person(<span class="string">&#x27;Asuka&#x27;</span>,<span class="number">16</span>);</span><br><span class="line">man.say();  <span class="comment">//输出 哈喽</span></span><br><span class="line">woman.say(); <span class="comment">//输出 哈喽</span></span><br></pre></td></tr></table></figure><h2 id="对象原型"><a href="#对象原型" class="headerlink" title="对象原型"></a>对象原型</h2><p>在构造函数拥有一个原型对象叫prototype，<strong>这个原型对象由构造函数内的prototype属性指明</strong>，每个构造函数都有一个这样的原型对象。经过上述学习我们知道共享的方法是定义在构造函数的原型prototype中的，但是我们的实例化对象却能使用定义在构造函数里prototype上的方法。这是如何实现的呢？</p><p>实现这个机制的就是我们即将要讲的<strong>对象原型</strong>。在每个实例化的对象中，都会包含一个<strong>属性</strong><code>__proto__</code>。这个<code>__protto__</code>属性就是令我们的实例化对象能够调用构造函数里<code>prototype</code>对象里定义的方法的原因，我们同时也称这个属性为对象原型。<code>__proto__</code>属性指向的是我们的构造函数的<code>prototype</code>原型对象，如上面的<code>man</code>当我们使用实例化的对象调用<code>prototype</code>里的方法时，我们的调用链是：<code>man</code> -&gt; <code>__proto__</code>  -&gt; <code>prototype</code> -&gt; <code>say()</code>。</p><p>经过这一层调用，我们的构造函数与实例化对象之间就形成了如下三角关系</p><p><img src="https://i.loli.net/2021/10/20/We5yfcVqx2bsZGk.png" alt="image-20211020094410424"></p><h2 id="constructor构造函数"><a href="#constructor构造函数" class="headerlink" title="constructor构造函数"></a>constructor构造函数</h2><p>不管我们构造函数里的原型对象<code>Prototype</code>，还是我们实例化的对象里的对象原型<code>__proto__</code>，它们都包含了一个<strong>属性</strong><code>constructor</code>。<code>constructor</code>属性的作用就是指明我们引用的构造函数是哪个。例如我们的<code>man、woman</code>它们都是通过构造函数<code>Person</code>创建出来的，所以它们的对象原型里的<code>construtctor</code>属性指向的就应该是<code>Person</code>这个构造函数。按这个指向顺序我们属性指向的关系应该是如下</p><p><img src="https://i.loli.net/2021/10/20/TKE9jX5aDgdJfsW.png" alt="直觉上对象原型里constructor的指向"></p><p>但事实情况是不是这样的呢？实际上对象原型里的constructor指向是通过构造函数里的<code>prototype.constructor</code>间接指回构造函数的。</p><p><img src="https://i.loli.net/2021/10/20/2CUPlsKLuvbJtGp.png" alt="20211020100310.png"></p><p>一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor  就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line"><span class="attr">say</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;哈喽&#x27;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果我们采用上述赋值的形式给原型对象添加新的方法，这意味着原本的那个原型对象被我们覆盖了。此时constructor指向的并不是Person</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所以我们需要手动指定constructor的指向，让它重新指向Person</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="attr">constructor</span>:Person,</span><br><span class="line"><span class="attr">say</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;哈喽&#x27;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>当我们继续打印出<code>prototype</code>这个对象的时候，我们可以看到<code>prototype</code>里面和已经实例化的对象一样里面也有一个<code>__proto__</code>对象原型。那么这个<code>__proto__</code>又指向哪里呢。实际上这个<code>__proto__</code>指向的是js内置的空对象<code>Object</code>的<code>prototype</code>。这个<code>Objerct</code>构造函数的对象原型里的<code>__proto__</code>还会继续往下指向最后的<code>null</code>。所以当我们查找方法时就会延着这条路径链式查找下去返回最先查找到的方法，若最后没找到则返回null。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = uname;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Person.prototype.__proto__指向的是Object的prototype，Object.prototype.__proto__指向null</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/20/Q4hrRYLdgxqDAGP.png" alt="输出结果"></p><p><img src="https://i.loli.net/2021/10/20/D1tKv4GVaNwAUu8.png" alt="实例对象查找共享方法的链式结构"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = uname;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;哈喽&#x27;</span>); &#125;;  </span><br><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> Person(<span class="string">&#x27;Asuhe&#x27;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> woman = <span class="keyword">new</span> Person(<span class="string">&#x27;Asuka&#x27;</span>,<span class="number">16</span>);</span><br><span class="line">man.say();  <span class="comment">//输出 哈喽  //在Person.prototype中找到了say方法，停止查找</span></span><br><span class="line">woman.sleep(); <span class="comment">//输出 TypeError //Person.prototype -&gt; Object.prototype中均未找到sleep方法，返回null</span></span><br></pre></td></tr></table></figure><p>像上面这种<code>__proto__</code>层层查找构成的链式结构就是我们常说的原型链。</p><p>还有一点需要我们注意的是，不管是构造函数里的<code>this</code> 还是构造函数的prototype里的<code>this</code>都是指向我们实例化出来的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = uname;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ptr = <span class="literal">null</span>;</span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;哈喽&#x27;</span>);</span><br><span class="line">    ptr = <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> Person(<span class="string">&#x27;Asuhe&#x27;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(man === ptr) <span class="comment">//输出 true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>sessionStorage 和 localStorage</title>
    <link href="http://example.com/2021/10/19/2021-10-19-sessionStorage-%E5%92%8C-localStorage/"/>
    <id>http://example.com/2021/10/19/2021-10-19-sessionStorage-%E5%92%8C-localStorage/</id>
    <published>2021-10-19T00:42:28.000Z</published>
    <updated>2021-10-19T01:05:37.096Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本文主要围绕What、Why、How这三个方面谈谈sessionStorage 和 localStorage的联系与区别。</p><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>sessionStorage 和 localStorage 都是BOM提供给我们在浏览器上进行本地存储数据的API，利用它我们可以实现在本地浏览器存储一些数据。这两个方法都是隶属于 Window这个顶级BOM下的，在需要的时候我们直接调用即可。</p><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>在某些场合下我们希望能够在用户本地的浏览器上存储一些数据以提高用户体验，所以本地存储技术就应运而生了。典型的应用场景就是我们在登录网站时希望下次登录网站能够记住我们的账号，以免再重新输入。这种时候就可以使用localStorage进行一个本地存储用户名，在用户加载完页面的时候就检测用户浏览器上有无存储相应账号数据，若有则自动填入。</p><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>在使用方式上sessionStorage和localStorage是类似的</p><h3 id="window-sessionStorage"><a href="#window-sessionStorage" class="headerlink" title="window.sessionStorage"></a>window.sessionStorage</h3><p>存储数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.setItem(key, value)</span><br></pre></td></tr></table></figure><p>获取数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.getItem(key)</span><br></pre></td></tr></table></figure><p>删除数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.removeItem(key)</span><br></pre></td></tr></table></figure><p>清空数据：(所有都清除掉)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.clear()</span><br></pre></td></tr></table></figure><h3 id="window-localStorage"><a href="#window-localStorage" class="headerlink" title="window.localStorage"></a>window.localStorage</h3><p>存储数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">localStorage</span>.setItem(key, value)</span><br></pre></td></tr></table></figure><p>获取数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">localStorage</span>.getItem(key)</span><br></pre></td></tr></table></figure><p>删除数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">localStorage</span>.removeItem(key)</span><br></pre></td></tr></table></figure><p>清空数据：(所有都清除掉)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">localStorage</span>.clear()</span><br></pre></td></tr></table></figure><h2 id="sessionStorage-和-localStorage的特点"><a href="#sessionStorage-和-localStorage的特点" class="headerlink" title="sessionStorage 和 localStorage的特点"></a>sessionStorage 和 localStorage的特点</h2><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p>1.存储容量约为5MB</p><p>2.同一个页面下可以共享数据</p><p>3.生命周期到页面关闭。当页面关闭后存储在浏览器上数据就会被清除，不会保留下来下次打开页面就没有数据了</p><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p>1.存储容量约为20MB</p><p>2.可以跨页面共享数据</p><p>3.生命周期为永久，仅当我们手动删除时才会清除数据，否则下次打开页面或者浏览器数据依然存在</p><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p>1.数据都存储在用户的浏览器中</p><p>2.数据都以键值对的形式存储</p><p>3.仅能存取字符串，可以将对象JSON.stringify() 编码后存储</p><p>4.读取方便，刷新页面也不会丢失数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="BOM" scheme="http://example.com/tags/BOM/"/>
    
  </entry>
  
  <entry>
    <title>事件对象</title>
    <link href="http://example.com/2021/10/13/2021-10-13-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/"/>
    <id>http://example.com/2021/10/13/2021-10-13-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-10-13T09:53:03.000Z</published>
    <updated>2021-10-14T01:00:34.791Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是事件对象"><a href="#什么是事件对象" class="headerlink" title="什么是事件对象"></a>什么是事件对象</h2><p>在浏览器中我们通常都是通过事件触发来实现网页与用户的交互效果的，在这个过程中js会产生一个事件对象。例如我们用常规方法给按钮绑定一个点击事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;btn&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    btn.addEventListiner(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"> e </span>)</span>&#123; <span class="comment">//这里我们给匿名函数的形参 e 就可以接收到 click 产生的事件对象</span></span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&#x27;哈喽&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="事件对象可以干什么"><a href="#事件对象可以干什么" class="headerlink" title="事件对象可以干什么"></a>事件对象可以干什么</h2><p>在返回的事件对象中包含了很多属性与方法，这些属性可以让我们准确的获取到用户目前的状态，例如用户按下了什么键、鼠标移动坐标、鼠标点击等等。然后我们可以根据用户的状态去设计我们的交互。我们可以打印一下这个对象看看里面都有什么</p><p><img src="https://i.loli.net/2021/10/14/91XMzcK2inRrb4k.png" alt="部分事件对象的内容"></p><h2 id="事件触发的三个阶段"><a href="#事件触发的三个阶段" class="headerlink" title="事件触发的三个阶段"></a>事件触发的三个阶段</h2><p>一个事件从产生到被触发可以分为三个阶段：捕获阶段、停留阶段、冒泡阶段。在捕获阶段，浏览器查找触发的事件顺序是从顶级DOM依次查找，直到找到源头。如果查找过程中有DOM元素绑定了和事件源头一样的事件，则会被触发。举个例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;father&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;son&#x27;</span>&gt;</span>Asuhe<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> father = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.father&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    father.addEventListiner(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&#x27;我是你爸爸&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,<span class="literal">true</span>) <span class="comment">//开启捕获阶段</span></span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> son = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.son&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    son.addEventListiner(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&#x27;我是你儿子&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种情况下会先弹出父亲的话，然后在弹出儿子的话。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Web API" scheme="http://example.com/tags/Web-API/"/>
    
  </entry>
  
  <entry>
    <title>关于Javascript的作用域</title>
    <link href="http://example.com/2021/10/13/2021-10-13-%E5%85%B3%E4%BA%8EJavascript%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://example.com/2021/10/13/2021-10-13-%E5%85%B3%E4%BA%8EJavascript%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/</id>
    <published>2021-10-13T09:53:03.000Z</published>
    <updated>2021-10-27T00:28:38.784Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>js里若我们包装函数的声明，则该函数会被当做一个<strong>函数表达式</strong>，而不是一个函数声明。如何理解?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); </span><br><span class="line">&#125;)(); <span class="comment">//输出3</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 输出2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当我们继续想要调用foo</span></span><br><span class="line">foo(); <span class="comment">//ReferenceError</span></span><br><span class="line"></span><br><span class="line">---------</span><br><span class="line"><span class="comment">//foo函数的书写还有一个改进的形式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//输出3</span></span><br><span class="line">&#125;())  <span class="comment">//即将()调用也包含进外层的()中，书写形式变了但其功能含义与上面的写法是一致的</span></span><br></pre></td></tr></table></figure><p>上述例子中，foo函数的作用域仅限于<code>&#123;...&#125;</code>即第五行，foo函数不能再在后续代码被调用。这种情况就是被包装函数声明foo，被编译器当作一个函数表达式而不是一个标准的函数声明。</p><p><code>(function foo()&#123;...&#125;)</code>作为函数表达式意味着，foo只能在<code>&#123;...&#125;</code>所代表的位置中被访问，外部作用域无法访问。但是若是有一个变量去接收该函数表达式的返回值，则该函数依然可以被继续保留调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最常见的函数表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> n = (<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); </span><br><span class="line">&#125;);</span><br><span class="line">n();<span class="comment">//输出3</span></span><br></pre></td></tr></table></figure><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>在js中只有全局作用域和函数作用域这两个基本的单位，<strong>块级作用域在js中是不存在的</strong>。如何理解呢，请看如下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(i);  <span class="comment">//此时输出 10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">//输出 ?     并不是输出 ReferenceError 而是输出 10</span></span><br></pre></td></tr></table></figure><p>在C++或Java中，i 这个变量其作用域仅在 {…} 中，在 {…} 外调用变量 i 是无法通过编译的，会产生一个报错。而在 js 中，如果你用 <code>var</code>关键字声明的变量不在一个函数中，则其作用域会为上级外部作用域。这就导致了如果我们在后续代码中同样声明一样的变量，使用该变量时就会产生预料外的结果。</p><p>很多时候我们希望变量仅在块级作用域里生效，用完以后就被GC回收。例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)  <span class="comment">//在这个循环里我们通常希望 i 在for循环执行完之后就失效，这一我们就可以在后续代码中重复定义使用 i</span></span><br><span class="line">&#123;<span class="comment">//但是实际上 变量 i for循环完以后并不会失效，而是继续作用在全局作用域中</span></span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">//输出 10</span></span><br><span class="line">--------</span><br><span class="line">上述代码等效于</span><br><span class="line"><span class="keyword">var</span> i;  <span class="comment">// i的作用域不是仅限于 for 循环内</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解决这个问题，es6中引入了 <code>let</code>关键字进行解决。我们使用<code>let</code>关键字对其进行改进，让 i 的作用域限定在for循环内</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)  </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">//此时输出 ReferenceError</span></span><br></pre></td></tr></table></figure><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p><code>let</code>的作用域会与其最近的{…}绑定，也就是说js在编译<code>let</code>关键字声明的变量时，会将该变量的作用域限定在包含该变量的{…}内。举个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(i);  <span class="comment">//输出 10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i)  <span class="comment">//输出ReferenceError</span></span><br><span class="line"></span><br><span class="line">变量 i 的作用域被限定在<span class="keyword">if</span>结构的代码块内</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line">如果我们用<span class="keyword">var</span>声明</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(i);  <span class="comment">//输出 10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);  <span class="comment">//依然输出 10</span></span><br><span class="line"></span><br><span class="line">上述代码等效于</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br></pre></td></tr></table></figure><p>这就是<code>var</code>关键字与<code>let</code>关键字的区别。<code>var</code>关键字定义的变量如果不是被包裹在函数体中，那么它就可以被外部作用域所访问。而<code>let</code>关键字声明的变量会将作用域绑定在最近的{…}包裹的块级作用域中。做个小测验</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line">该程序会输出啥？</span><br><span class="line">会是 <span class="number">10</span> <span class="number">10</span> 吗？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">该程序的输出是?</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一题的答案为: 10  ReferenceError，第二题的答案为：10 10 10。这个例子可以很形象的说明<code>let</code>关键字的特性。</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p><code>const</code>关键字的特性与<code>let</code>一样，都是将变量的作用域绑定在最近{…}中，唯一的不同就是当我们在其作用域中不允许修改其变量值，被<code>const</code>定义的变量都为常量，若想修改则会产生 TypeError.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> i = <span class="number">10</span>;</span><br><span class="line">i = <span class="number">20</span>; <span class="comment">//TypeError</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">//ReferenceError</span></span><br></pre></td></tr></table></figure><h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><p>我们都知道函数和变量若都声明在调用后面，js依然会通过编译。因为函数和变量的声明会被提升至所在作用域顶部，而赋值却留在原地。<strong>若代码中出现多个重复的声明，函数提升会先于变量提升。而且若有多个重复的函数声明，则以最后一个为准</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">30</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">为什么foo();输出的是<span class="number">30</span>?</span><br><span class="line"><span class="comment">//若再调用一次foo()</span></span><br><span class="line">foo(); <span class="comment">// 输出 ?            输出20</span></span><br><span class="line">    </span><br><span class="line">----------</span><br><span class="line"><span class="comment">//在编译器眼中上述代码的执行顺序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">30</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>普通块内的函数声明通常会被提升至顶级作用域的顶部，且这个过程不可被条件判断控制</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">//&#x27;asuhe&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;ashitahe&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;asuhe&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript的坑</title>
    <link href="http://example.com/2021/10/10/2021-10-10-js%E7%9A%84%E5%9D%91/"/>
    <id>http://example.com/2021/10/10/2021-10-10-js%E7%9A%84%E5%9D%91/</id>
    <published>2021-10-10T12:31:38.000Z</published>
    <updated>2021-10-27T00:28:26.978Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="坑一：变量提升"><a href="#坑一：变量提升" class="headerlink" title="坑一：变量提升"></a>坑一：变量提升</h2><p>js在解析时，会将所有的变量与函数先声明再进行赋值操作。例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先输出再声明并赋值变量</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//输出结果为undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>像这类代码，在执行时等于如下效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>这说明js在执行时，会将变量提至最前面先声明，再进行赋值操作。</strong>同理，我们进行函数调用时也是如此进行函数提升</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fu1();  <span class="comment">//在未定义fu1()时就调用它，此时我们执行时是可以输出xxx的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">fu1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;xxx&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//但我们使用变量保存函数时，函数无法执行</span></span><br><span class="line">fun();  <span class="comment">//此时控制台报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;asuhe&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="坑二：逻辑中断"><a href="#坑二：逻辑中断" class="headerlink" title="坑二：逻辑中断"></a>坑二：逻辑中断</h2><p>当出现<code>表达式1 &amp;&amp; 表达式2</code>时，前面的<strong>表达式1</strong>返回 true 则返回<strong>表达式2</strong>值，若<strong>表达式1</strong>返回 false 则返回<strong>表达式1</strong>的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span> &gt; <span class="number">3</span> &amp;&amp; <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//输出 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">1</span> &gt; <span class="number">3</span> &amp;&amp; <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//输出 false</span></span><br></pre></td></tr></table></figure><p>当出现<code>表达式1 || 表达式2</code>时，<strong>表达式1</strong>返回 true 则返回<strong>表达式1</strong>的值，若<strong>表达式1</strong>返回 false 则返回<strong>表达式2</strong>的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span> &gt; <span class="number">3</span> || <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//输出 true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">1</span> &gt; <span class="number">3</span> || <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//输出 10</span></span><br></pre></td></tr></table></figure><h2 id="坑三：变量声明"><a href="#坑三：变量声明" class="headerlink" title="坑三：变量声明"></a>坑三：变量声明</h2><p>在js中我们可以不使用<code>var</code>关键字直接对一个变量名进行赋值，而且该变量还会成为一个全局变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">//输出 10</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//输出 10</span></span><br></pre></td></tr></table></figure><h2 id="坑四：函数的形参与实参可以不匹配"><a href="#坑四：函数的形参与实参可以不匹配" class="headerlink" title="坑四：函数的形参与实参可以不匹配"></a>坑四：函数的形参与实参可以不匹配</h2><p>js的函数在定义时可以不书写形参，但是在调用该函数时，我们却可以传入实参。传入的实参会被一个<code>argument</code>对象保存，在函数内部可以使用该对象获取传入实参的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">//输出 10</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">//输出 20</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">2</span>]); <span class="comment">//输出 undefined</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//形参多于实参时，未匹配的形参值为undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//输出 10</span></span><br><span class="line">    <span class="built_in">console</span>.log(b); <span class="comment">//输出 undefined</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//形参少于实参时，多余的实参值不会赋值给形参，但仍然保存在arguments中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//输出 10</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">//输出 20</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">10</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p><code>arugments</code>的内部结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">//输出 arguments结构</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">10</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/10/ET3LHMgmd8rVUD2.png" alt="arguments中保存的东西"></p><h2 id="坑五：内置Array-sort方法里的比较默认是按第一位大小比较的"><a href="#坑五：内置Array-sort方法里的比较默认是按第一位大小比较的" class="headerlink" title="坑五：内置Array.sort方法里的比较默认是按第一位大小比较的"></a>坑五：内置Array.sort方法里的比较默认是按第一位大小比较的</h2><p>在js的内置Array.sort方法里，大小默认是为按第一位的大小比较的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">8</span>,<span class="number">31</span>,<span class="number">40</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">16</span>];</span><br><span class="line">a.sort();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; a.length; index++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/10/YJzjXpPocntudgw.png" alt="数组按第一位的大小比较"></p><p>若要变成正确的升序办法要传入特定的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">8</span>,<span class="number">31</span>,<span class="number">40</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">16</span>];</span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123; <span class="keyword">return</span> a - b;&#125;); <span class="comment">//a - b是升序，固定写法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; a.length; index++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/10/OTUrlYLp5KMRs1x.png" alt="正确的升序"></p><p>降序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">8</span>,<span class="number">31</span>,<span class="number">40</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">16</span>];</span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123; <span class="keyword">return</span> b - a;&#125;); <span class="comment">//b - a是降序，固定写法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; a.length; index++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/10/qXFoMdr1c72ipgk.png" alt="降序"></p><h2 id="坑六：所谓的构造函数"><a href="#坑六：所谓的构造函数" class="headerlink" title="坑六：所谓的构造函数"></a>坑六：所谓的构造函数</h2><p>js里的所谓的构造函数<strong>实际上就是一个自定义的用来创建对象的普通函数</strong>，只是因为它的功能是用来创建对象所以才叫构造函数。本质上与普通函数并没有区别，不是C++或Java里构造函数的概念。<strong>这也就是说，js本质上不是面向对象的，只是实现了类似面向对象的功能</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,sex</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name; <span class="comment">//this指针写出成员赋值</span></span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.name;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Person(<span class="string">&#x27;Asuhe&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;保密&#x27;</span>); <span class="comment">//创建对象时还是要使用 new 关键字</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.getName()); <span class="comment">//输出 Asuhe</span></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//输出obj的结构</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/10/OhNTdpIZF31sinP.png" alt="构造函数"></p><h2 id="坑七：作用域链"><a href="#坑七：作用域链" class="headerlink" title="坑七：作用域链"></a>坑七：作用域链</h2><p>因为变量提升导致我们在调用一个在后面定义并赋值的变量时，会先输出这个变量未赋值的状态。作用域链就是，当我们发现在当前作用域寻找不到变量声明时，就会往上一级作用域去寻找，<strong>找到为止</strong>。若在全局作用域中都未寻找到该变量声明，则报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>; <span class="comment">//变量提升</span></span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">//此时输出undefined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">//此时依然输出undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>; <span class="comment">//变量提升</span></span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>; <span class="comment">//变量提升</span></span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">//依然输出undefined , 因为在foo函数内部作用域中已经找到a的声明，所以不会继续往外查找</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="坑八：类没有变量提升"><a href="#坑八：类没有变量提升" class="headerlink" title="坑八：类没有变量提升"></a>坑八：类没有变量提升</h2><p>前面我们讲到对于函数有函数提升，变量有变量提升，我们可以先使用后声明不会报错。而es6中引入的class关键字就没有类似的提升机制。我们只能先把class的定义放在使用它之前。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Man();  <span class="comment">//此行报错,不能先于Man类的定义使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;hello world!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="坑九：类里面的this指向"><a href="#坑九：类里面的this指向" class="headerlink" title="坑九：类里面的this指向"></a>坑九：类里面的this指向</h2><p>在es6中引入了class关键字，用于实现类似面向对象的功能。但是这个class里的this指针的指向并不是总是指向实例化对象本身。在constructor函数中，this指针是一直指向实例化对象本身的。而在这个<strong>class的方法中，this指针指向的是调用该方法的对象</strong>，有时候调用该方法的并不是该实例化对象所以this指向会发生改变。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span> //点击该按钮输出 undefined</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="title">constructor</span>(<span class="params">name,word</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.name = name;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.word = word;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>); <span class="comment">//绑定至btn</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.btn.onclick = <span class="built_in">this</span>.Say; <span class="comment">//button 调用Say方法</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">Say</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.word);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> asuhe = <span class="keyword">new</span> Person(<span class="string">&#x27;Asuhe&#x27;</span>,<span class="string">&#x27;up&#x27;</span>);</span></span><br><span class="line"><span class="javascript">asuhe.getName(); <span class="comment">//输出 Asuhe</span></span></span><br><span class="line"><span class="javascript">asuhe.Say(); <span class="comment">//输出 up</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="坑十：supre关键字在子类constructor中的使用"><a href="#坑十：supre关键字在子类constructor中的使用" class="headerlink" title="坑十：supre关键字在子类constructor中的使用"></a>坑十：supre关键字在子类constructor中的使用</h2><p>我们都知道 supre 不仅可以调用父类的 constructor ，还可以用于调用父类的普通成员函数。</p><p>子类<strong>在 constructor 中使用 super 关键字, 必须放到 this指针 前面</strong> ，但在普通成员函数中无此规则 (必须先调用父类的构造方法,在使用子类构造方法)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.x = x;</span><br><span class="line"><span class="built_in">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">sum</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.x + <span class="built_in">this</span>.y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.x = x;</span><br><span class="line"><span class="built_in">this</span>.y = y;</span><br><span class="line"><span class="built_in">super</span>(x,y); <span class="comment">//此行报错，super在constructor中必须先于this。super.sum();同样报错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">subtract</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.x - <span class="built_in">this</span>.y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Son(<span class="number">5</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Boostrap初探</title>
    <link href="http://example.com/2021/10/09/2021-10-09-Boostrap%E5%88%9D%E6%8E%A2/"/>
    <id>http://example.com/2021/10/09/2021-10-09-Boostrap%E5%88%9D%E6%8E%A2/</id>
    <published>2021-10-09T11:35:43.000Z</published>
    <updated>2021-10-09T12:15:52.702Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Boostrap简介"><a href="#Boostrap简介" class="headerlink" title="Boostrap简介"></a>Boostrap简介</h2><p>Boostrap是一套基于 HTML、CSS 和 Javascript的的响应式前端框架。简单来说就是一套预先定义好的css文件和js文件，当我们需要使用时在html页面中用<code>link</code>标签引入我们需要的文件，然后使用即可。</p><h2 id="Boostrap的使用"><a href="#Boostrap的使用" class="headerlink" title="Boostrap的使用"></a>Boostrap的使用</h2><p>Boostrap的使用极其简单，我们只需要根据它定义好的类名，在我们要引入样式的标签上添加它给的类名就可以使用了。若默认样式不满足我们的需求，我们可以自己使用选择器更改对应属性。</p><p>Bootstrap 需要为页面内容和栅格系统包裹一个 .container 容器，它提供了两个作此用处的类：container类和container-fluid类，container-fluid类一般用于移动端页面开发。这个.container容器被预定好响应式样式，当我们定义这个类时，引入的Boostrap文件会对其进行一系列初始化操作。</p><h3 id="container和container-fluid的区别"><a href="#container和container-fluid的区别" class="headerlink" title="container和container-fluid的区别"></a>container和container-fluid的区别</h3><h4 id="container类"><a href="#container类" class="headerlink" title="container类"></a>container类</h4><ul><li>响应式布局的容器 固定宽度</li><li>大屏 ( &gt;=1200px)  宽度定为 1170px </li><li>中屏 ( &gt;=992px)   宽度定为 970px </li><li>小屏 ( &gt;=768px)   宽度定为 750px </li><li>超小屏 (100%)</li></ul><h4 id="container-fluid类"><a href="#container-fluid类" class="headerlink" title="container-fluid类"></a>container-fluid类</h4><ul><li>流式布局容器百分百宽度</li><li>占据全部视口（viewport）的容器</li></ul><h3 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h3><p>Bootstrap 提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加， 系统会自动分为最多12列。</p><p>它是指将页面布局划分为等宽的列，然后通 过列数的定义来模块化页面布局。</p><p>当我们使用栅格系统时都是通过使用一系列<code>row</code>和<code>column</code>来进行布局操作。例如携程的移动端页面<img src="https://i.loli.net/2021/10/09/s1eycKh4ALHdiav.png" alt="image-20211009195752403"></p><p>这种布局我们可以用flex布局，也可用栅格系统快速制作。</p><p>container里页面已经被分为十二等份，而这个页面中我们可以很容易知道，先将页面份为三列，再在第二列与第三列中分为上下两行。栅格系统中我们 html 可以这样写</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">    //col-sm-4 即让我们三个盒子各自分到了四份空间</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-sm-4 column1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-sm-4 column2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-sm-4 column3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们需要进行行切分时，html 中可以这样写</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//row-cols-2 让我们的盒子再次按行切分为两行</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">    //col-sm-4 即让我们三个盒子各自分到了四份空间</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-sm-4 column1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-sm-4 row-cols-2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span>Column<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span>Column<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-sm-4 row-cols-2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span>Column<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span>Column<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如上我们在row盒子里可以得到一个 3 * 2 布局</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="code" scheme="http://example.com/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>flex布局</title>
    <link href="http://example.com/2021/10/09/2021-10-09-flex%E5%B8%83%E5%B1%80/"/>
    <id>http://example.com/2021/10/09/2021-10-09-flex%E5%B8%83%E5%B1%80/</id>
    <published>2021-10-09T09:42:16.000Z</published>
    <updated>2021-10-09T11:00:58.292Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是flex布局"><a href="#什么是flex布局" class="headerlink" title="什么是flex布局"></a>什么是flex布局</h2><p>传统布局解决方案主要是依赖<code>display</code> 属性 + <code>float</code>属性 + <code>position</code>属性来控制我们盒模型的位置，用这三个属性相互配合达到将盒子摆放至预期位置的目的。而flex布局主要是利用在父元素中添加<code>display:flex</code>属性，使用与其相关的属性配合达到布局的目的。</p><p>在传统布局中有些特殊布局并不好实现，而在flex布局中我们可以轻松实现。例如将三个盒子同时水平对齐和垂直居中对齐。</p><h2 id="flex布局原理"><a href="#flex布局原理" class="headerlink" title="flex布局原理"></a>flex布局原理</h2><p>flex布局里我们可以指定任意一个元素为父元素，即使是行内元素我们也可以设置flex布局。</p><p>将父盒子作为一个容器，父盒子的儿子元素作为容器的成员。使用父元素控制属性可以控制儿子元素的排列位置。同时flex布局也提供了儿子元素控制属性，令我们可以单独控制特定子元素的位置。父元素控制属性可以理解为游戏里的群体控制效果，子元素控制属性可以理解单体控制效果。</p><p>在flex布局中，我们将页面看作一个二维坐标系，主轴正方向为从左至右，侧轴正方向为从上至下。</p><p><img src="https://i.loli.net/2021/10/09/lxCpiurQ5AbY4eE.png" alt="flex坐标轴"></p><p>利用父元素控制属性我们可以进行切换主轴、设置换行等系列操作。接下来我们可以看看主要的父元素控制元素有哪些。</p><h2 id="常见父元素属性"><a href="#常见父元素属性" class="headerlink" title="常见父元素属性"></a>常见父元素属性</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex-direction</span>：设置主轴的方向 </span><br><span class="line"><span class="attribute">justify-content</span>：设置主轴上的子元素排列方式 </span><br><span class="line"><span class="attribute">flex-wrap</span>：设置子元素是否换行</span><br><span class="line"><span class="attribute">align-content</span>：设置侧轴上的子元素的排列方式（多行） </span><br><span class="line"><span class="attribute">align-items</span>：设置侧轴上的子元素排列方式（单行） </span><br><span class="line"><span class="attribute">flex-flow</span>：复合属性，相当于同时设置了 <span class="attribute">flex-direction</span> 和 <span class="attribute">flex-wrap</span></span><br></pre></td></tr></table></figure><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p><code>flex-direction</code>用于设置主轴为哪个，默认情况下flex主轴为x轴，正方向是从左至右的。</p><p><img src="https://i.loli.net/2021/10/09/YNQTgrkiF8eSwqP.png" alt="flex-direction属性值"></p><p><code>flex-direction:row </code>效果（默认方向），<strong>主轴方向</strong>为从左至右</p><p><img src="https://i.loli.net/2021/10/09/765eRbhkcVWaiqQ.png" alt="flex-direction:row"></p><p><code>flex-direction:row-reverse </code>效果，<strong>主轴方向</strong>为从右至左</p><p><img src="https://i.loli.net/2021/10/09/5I3k2TsWvpAu4oP.png" alt="image-20211009181827790"></p><p><code>flex-direction:column </code>效果，<strong>主轴方向</strong>为从上至下</p><p><img src="https://i.loli.net/2021/10/09/tRj8GibZuxDHkFP.png" alt="flex-direction:column"></p><p><code>flex-direction:column-reverse </code>效果，<strong>主轴方向</strong>为从下至上</p><p><img src="https://i.loli.net/2021/10/09/3Ty9nv5pOoxl24V.png" alt="flex-direction:column-recerse"></p><h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p><code>justify-content</code>的作用是设置<strong>主轴</strong>上子元素的排列方式</p><p><img src="https://i.loli.net/2021/10/09/rkaxRVUWpyLocHF.png" alt="justify-content属性值"></p><p>下列中的示例效果，主轴皆为默认的从左至右</p><p><code>justify-content:flex-start</code>效果（默认）</p><p><img src="https://i.loli.net/2021/10/09/S5789RBDwpvmtQh.png" alt="justify-content:flex-start"></p><p><code>justify-content:flex-end</code>效果（注意和<code>flex-direction:row-reverse</code>的区别）</p><p><img src="https://i.loli.net/2021/10/09/epTGnWflVFsqKkm.png" alt="justify-content:flex-end"></p><p><code>justify-content:center</code>效果</p><p><img src="https://i.loli.net/2021/10/09/cbAU9a7YCRLXIV8.png" alt="justify-content:center"></p><p><code>justify-content:space-around</code>效果（平分剩余空间）</p><p><img src="https://i.loli.net/2021/10/09/YjNS3qDA8FaUpMh.png" alt="justify-content:space-around"></p><p><code>justify-content:space-between</code>效果（头尾元素贴紧边缘）</p><p><img src="https://i.loli.net/2021/10/09/HBqDgMu2Fw8VRkL.png" alt="justify-content:space-between"></p><h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p><code>flex-wrap</code>设置当子元素一行排不下时，是否换行。默认为不换行，将每个子元素宽度压缩至能一行排列。</p><p>当<code>flex-wrap:nowrap</code>时，flex子元素都会挤压在一行而<strong>不会</strong>像<code>float</code>一样空间不够时自动换行</p><p>当<code>flex-wrap:wrap</code>时，flex子元素保持原有大小，一行排不下时<strong>会</strong>像<code>float</code>一样空间不够时自动换行</p><h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p><code>align-items</code>设置<strong>侧轴</strong>上子元素排列方式（单行），<strong>当子元素不止一行时此属性不生效</strong></p><p><img src="https://i.loli.net/2021/10/09/brXIQGHRkuntC64.png" alt="align-items属性值"></p><p><code>align-items:flex-start</code>效果（默认）</p><p><img src="https://i.loli.net/2021/10/09/6ZrzaxDKd1UknLV.png" alt="align-items:flex-start"></p><p><code>align-items:flex-end</code>效果，在侧轴顶部排列</p><p><img src="https://i.loli.net/2021/10/09/Gq9C5svxzOyPoDI.png" alt="align-items:flex-end"></p><p><code>align-items:center</code>效果，在侧轴中部排列</p><p><img src="https://i.loli.net/2021/10/09/pJUaHMNGVLPhIOR.png" alt="align-items:center"></p><p><code>align-items:stretch</code>效果（当子元素的<code>height</code>属性不设置时才显示效果），将子元素拉伸到和父元素一样高</p><p><img src="https://i.loli.net/2021/10/09/gxXsAWk3Nz9rb4H.png" alt="align-items:stretch"></p><h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><p>align-content设置侧轴上的子元素的排列方式（多行）</p><p>设置子项在侧轴上的排列方式并且只能用于子项出现换行的情况（多行），在单行下是没有效果的。</p><p><img src="https://i.loli.net/2021/10/09/PmbyIid5qYpx9uJ.png" alt="align-content属性值"></p><p><code>align-content:flex-end</code>效果，在侧轴尾部排列</p><p><img src="https://i.loli.net/2021/10/09/fORD7b9Ul1oJWZN.png" alt="align-content:flex-end"></p><p><code>align-content:center</code>效果，在侧轴中间排列</p><p><img src="https://i.loli.net/2021/10/09/l9O3rR1XNFcfDZ4.png" alt="align-content:center"></p><p><code>align-content: space-around</code> 效果，平分剩余空闲空间并在侧轴两侧排列</p><p><img src="https://i.loli.net/2021/10/09/xKrhMCI1XmOAw7Q.png" alt="align-content: space-around;"></p><p><code>align-content: space-between </code>效果，首行和尾行紧贴侧轴两端，中间行平分剩余空间</p><p><img src="https://i.loli.net/2021/10/09/KtlQ17b3WqAYmis.png" alt="align-content: space-between"></p><h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p><code>flex-flow</code>是<code>flex-direction</code>和<code>flex-wrap</code>的复合写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex-flow</span>:flex-direction-value flex-wrap-value </span><br></pre></td></tr></table></figure><h2 id="常见子元素属性"><a href="#常见子元素属性" class="headerlink" title="常见子元素属性"></a>常见子元素属性</h2><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p><code>flex </code>属性定义子项目分配剩余空间，用flex来表示占多少<strong>份数</strong> </p><p>设置<code>中</code>的属性为<code>flex:2</code>,空白空间被分为四份，中间的占两份</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//父容器空间被分为四等份，中间元素占<span class="number">2</span>份，两边元素占<span class="number">1</span>份</span><br><span class="line"><span class="selector-class">.zuo</span> &#123;</span><br><span class="line"><span class="attribute">flex</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.zhong</span> &#123;</span><br><span class="line"><span class="attribute">flex</span>:<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.you</span> &#123;</span><br><span class="line"><span class="attribute">flex</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/09/l6uzL1tUy9bw5nJ.png" alt="flex:2"></p><h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p><code>align-self </code>控制子项<strong>自己</strong>在<strong>侧轴</strong>上的排列方式，可以单独控制一个子元素的位置</p><p>align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。 默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//如设置 右 元素，在底部</span><br><span class="line"><span class="selector-class">.you</span> &#123;</span><br><span class="line"><span class="attribute">align-self</span>:flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/09/eXoJMHfayB6qAY4.png" alt="align-self"></p><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p>order 属性定义项目的排列顺序,数值越小，排列越靠前，<strong>默认值为0</strong>。</p><p>设置<code>中</code>元素在第一个位置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.zhong</span> &#123;</span><br><span class="line"><span class="attribute">order</span>:-<span class="number">1</span>;  //<span class="number">0</span> &gt; -<span class="number">1</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/09/xzeqv2lV69jBwmr.png" alt="order"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="code" scheme="http://example.com/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>Windows terminal 免密码登录Linux服务器</title>
    <link href="http://example.com/2021/10/08/2021-10-08-%E4%BD%BF%E7%94%A8Windows-terminal-%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95Linux%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://example.com/2021/10/08/2021-10-08-%E4%BD%BF%E7%94%A8Windows-terminal-%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95Linux%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2021-10-08T12:12:16.000Z</published>
    <updated>2021-10-09T11:35:06.910Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Linxu服务器配置"><a href="#Linxu服务器配置" class="headerlink" title="Linxu服务器配置"></a>Linxu服务器配置</h2><h3 id="登录Linux并生成密钥对"><a href="#登录Linux并生成密钥对" class="headerlink" title="登录Linux并生成密钥对"></a>登录Linux并生成密钥对</h3><p>首先我们使用putty登录Linux服务器</p><p><img src="https://i.loli.net/2021/10/08/KNjAHIwMhWoTBU2.png" alt="putty登录服务器"></p><p>再让Linux服务器先生成 rsa 密钥对供我们认证。使用如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p>命令执行后对于弹出的选项我们一路回车就行</p><p><img src="https://i.loli.net/2021/10/08/IRbGlNqvMUCSgrA.png" alt="生成密钥对"></p><p>密钥对生成后我们要将其中的公钥文件<code>id_rsa.pub</code>更改为<code> authorized_keys</code>，然后将私钥文件<code>id_rsa</code>下载至本地Windows</p><h3 id="更改Linux公钥文件名称"><a href="#更改Linux公钥文件名称" class="headerlink" title="更改Linux公钥文件名称"></a>更改Linux公钥文件名称</h3><p>我们找到生成密钥的地址<code> /home/unbuntu/.ssh</code>，因为我们现在就是在当前用户目录下生成的密钥，所以只需要输入<code>cd .ssh</code>即可跳转至密钥存放的文件夹，<code>ls</code>查看一下。确实存在我们刚刚生成的密钥，最后更改公钥文件名称Linux端就大功告成了。再查看一下，文件是否更改成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//跳转到密钥文件所在目录</span><br><span class="line">cd .ssh</span><br><span class="line"></span><br><span class="line">//更改公钥文件名</span><br><span class="line">mv id_rsa.pub authorized_keys</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/08/p7y5bLd8Y4vwNso.png" alt="更改公钥文件名称"></p><h2 id="Windows端配置"><a href="#Windows端配置" class="headerlink" title="Windows端配置"></a>Windows端配置</h2><h3 id="从Linux服务器下载私钥"><a href="#从Linux服务器下载私钥" class="headerlink" title="从Linux服务器下载私钥"></a>从Linux服务器下载私钥</h3><p>Linux服务器已经生成了密钥对，并且我们也成功将Linux中的公钥文件修改成功。接下来我们只要将Linux生成的私钥下载至本地即可。</p><p>首先我们需要确定Linux上私钥的存放地址，然后再确定Windows中我们将私钥存放的地址。比如Windows中我就将私钥存放在<code>D:\ssh_keys\tencent</code></p><p>找到Linux中文件存放的地址，其实地址之前我们生成密钥对的时候就已经显示过了，我们只需要复制下来即可。私钥文件路径<code>/home/ubuntu/.ssh/id_rsa</code></p><p><img src="https://i.loli.net/2021/10/08/HM9rK5IytaZNpeo.png" alt="获取私钥"></p><p>使用scp将文件下载至我们指定的位置:<code> scp ubuntu@Linux的IP:/home/ubuntu/.ssh/id_rsa D:\ssh_keys\tencent</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//scp命令格式</span><br><span class="line">scp Linux用户名@Linxu的IP地址:密钥的文件路径 Windows存放密钥的文件路径</span><br></pre></td></tr></table></figure><p>根据提示输入Linxu用户密码</p><p><img src="https://i.loli.net/2021/10/08/Iva5uWUGbtTC6Yc.png" alt="下载私钥"></p><p>下载完成后我们可以看见我们的密钥文件</p><p><img src="https://i.loli.net/2021/10/08/FtJqo8wEWRHfG45.png" alt="找到私钥"></p><p>到了这一步我们就可以使用密钥登录啦，在命令行中输入:<code>ssh -i D:\ssh_keys\tencent\id_rsa ubuntu@Linux的IP地址</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//登录命令格式</span><br><span class="line">ssh -i Windows中私钥的文件路径 Linux用户名@Linxu的IP地址</span><br></pre></td></tr></table></figure><p>登录成功</p><p><img src="https://i.loli.net/2021/10/08/z2efD4Nit97U5xg.png" alt="密钥登录"></p><h3 id="设置私钥文件权限"><a href="#设置私钥文件权限" class="headerlink" title="设置私钥文件权限"></a>设置私钥文件权限</h3><p>走到这一步我们已经基本完成了，但是还有一个问题就是当我们执行密钥登录时Windows可能会提示我们私钥文件过权限大，忽视这个私钥，导致我们无法使用密钥登录</p><p><img src="https://i.loli.net/2021/10/08/EUnf5Lp2QgGZqDx.png" alt="私钥文件权限过于开放"></p><p>这时我们需要将私钥文件<code>id_rsa</code>的权限设置为仅<strong>所有者</strong>控制</p><p>在Windows资源管理器中找到<code>id_rsa</code>文件，右键单击该文件，然后选择“属性”。导航到“安全性”选项卡，然后单击“高级”。</p><p>将所有者更改为你，禁用继承并删除所有权限，把除了自己以外的权限条目全部删除。然后授予自己“完全控制权”并保存权限。</p><p><img src="https://i.loli.net/2021/10/08/sbrithHIYfGSwlU.png" alt="删除其它用户对私钥文件的权限"></p><p>现在SSH不再抱怨文件权限太开放了。</p><p>若原本权限条目中没有拥有者，则去添加中寻找并加入</p><p><img src="https://i.loli.net/2021/10/08/xfqCWE7l2KDMJnt.png" alt="寻找本机用户组"></p><h2 id="设置Windows-terminal"><a href="#设置Windows-terminal" class="headerlink" title="设置Windows terminal"></a>设置Windows terminal</h2><p>只需要去设置中将我们刚才登录Linux的命令复制一份并保存就可以了</p><p><img src="https://i.loli.net/2021/10/08/URK3hpTQWH569cX.png" alt="Windows terminal设置"></p><p>这样以后我们打开Windows terminal选择选项卡就可以登录服务器了，打完收工！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="tips" scheme="http://example.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>浅谈rem布局</title>
    <link href="http://example.com/2021/10/07/rem%20+%20less%20+%20%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E5%B8%83%E5%B1%80/"/>
    <id>http://example.com/2021/10/07/rem%20+%20less%20+%20%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E5%B8%83%E5%B1%80/</id>
    <published>2021-10-07T15:14:23.000Z</published>
    <updated>2021-10-07T15:14:26.807Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="rem-less-媒体查询布局"><a href="#rem-less-媒体查询布局" class="headerlink" title="rem + less + 媒体查询布局"></a>rem + less + 媒体查询布局</h1><h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><h3 id="初识rem"><a href="#初识rem" class="headerlink" title="初识rem"></a>初识rem</h3><p>什么是rem，rem的全称为root em。em我们都知道，1em代表一个字符的大小。而root em顾名思义，我们可以大致猜测出是以某个源为标准的单位。实际上rem代表的是以<html>标签里font-size属性的单位，举个例子</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">设置<span class="selector-tag">html</span>文件的默认字体大小为<span class="number">16px</span></span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line">此时 <span class="number">1</span> rem = <span class="number">16</span> px;</span><br></pre></td></tr></table></figure><p>由此可以看出，html标签里设置的字体像素值为多少，其每单位rem就是多少像素的大小。</p><h3 id="为什么要rem"><a href="#为什么要rem" class="headerlink" title="为什么要rem"></a>为什么要rem</h3><p>我们都知道当我们缩放浏览器窗口时，网页的内容会因为我们的而改变缩放。如果我们进行开发时，使用的是rem则采用rem进行设置大小的内容都会进行等比缩放，从而实现自适应效果。但如果我们使用px规定了大小，此时我们进行缩放或者使用不同分辨率的设备查看网页内容时，里面的字体的内容并不会进行一个等比缩放而是依然使用规定的像素值。</p><p>rem的出现很好的解决了不同分辨率下查看同一网页字体不会自适应的问题。</p><p>相比于em仅依靠父元素来设置文字大小，在实际开发中父元素文字大小可能不一致，但是整个页面只有一个html，使用rem可以很好来控制整个页面的元素大小。</p><h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><h3 id="什么是less"><a href="#什么是less" class="headerlink" title="什么是less"></a>什么是less</h3><p>为解决css代码冗余，无法使用变量、函数等概念的问题。引入less简化css代码的开发。</p><p>Less （Leaner Style Sheets 的缩写） 是一门 CSS 扩展语言，也称为CSS预处理器。</p><h3 id="典型场景"><a href="#典型场景" class="headerlink" title="典型场景"></a>典型场景</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">当我们需要在不同选择器重复使用同一属性并对其修改时，需要一个一个找到相应属性然后修改十分麻烦，如下情形</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    backgroud-<span class="attribute">color</span>:green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>:green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">我们要同时修改背景颜色时，需要一个一个去修改很麻烦。若我们使用less开发，则可以同时修改背景颜色，只需如下</span><br><span class="line"></span><br><span class="line"><span class="keyword">@Color</span>:black;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    backgroud-<span class="attribute">color</span>:@Color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>:@Color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">改变变量<span class="attribute">Color</span>的值即可同时修改<span class="selector-tag">body</span> 和 <span class="selector-tag">div</span> 的背景颜色为black</span><br><span class="line"></span><br><span class="line">可以将其理解为一个全局变量</span><br></pre></td></tr></table></figure><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><h5 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h5><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@varname:</span>value; </span><br></pre></td></tr></table></figure><p>注意事项</p><ul><li>必须有@为前缀</li><li>不能包含特殊字符</li><li> 不能以数字开头</li><li> 大小写敏感</li></ul><h5 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h5><p>直接选中div里的子元素span</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="selector-tag">CSS-Code</span>;</span><br><span class="line">    <span class="selector-tag">span</span> &#123;</span><br><span class="line">        <span class="selector-tag">CSS-Code</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">编译出的<span class="selector-tag">css</span>代码为</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="selector-tag">CSS-Code</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="selector-tag">CSS-Code</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项</p><ul><li>如果遇见（交集|伪类|伪元素选择器）</li><li>内层选择器的前面没有&amp; 符号，则它被解析为父选择器的后代；</li><li>如果有&amp; 符号，它就被解析为父元素自身或父元素的伪类。</li></ul><p>如，使用伪类选择器</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="selector-tag">CSS-Code</span></span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">        <span class="selector-tag">CSS-Code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">编译出来的<span class="selector-tag">CSS</span>代码为</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="selector-tag">CSS-Code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="selector-tag">CSS-Code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h5><p>可使用的运算符有 + - * / ，运算符前后左右都要空格</p><p>运算优先级为先乘除后加减，从左往右</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>:<span class="number">50px</span> - <span class="number">5</span>; <span class="comment">//最终值为 45px </span></span><br><span class="line"></span><br><span class="line">若改变运算优先级，则使用()即可，如下</span><br><span class="line"></span><br><span class="line">witdth:(50px + 10px) * 2; <span class="comment">//最终值为 120px</span></span><br></pre></td></tr></table></figure><p>注意事项</p><ul><li><p>对于两个不同的单位的值之间的运算，运算结果的值取第一个值的单位</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">10rem</span> / <span class="number">5px</span>; <span class="comment">//最终值为 2rem</span></span><br></pre></td></tr></table></figure></li><li><p>如果两个值之间只有一个值有单位，则运算结果就取该单位</p></li></ul><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><h3 id="什么是媒体查询"><a href="#什么是媒体查询" class="headerlink" title="什么是媒体查询"></a>什么是媒体查询</h3><p>媒体查询（Media Query）是CSS3新语法。 使用媒体查询可以令我们针对不同的设备开发不同的css样式用以适配，当查看网页的设备不同，就可以根据媒体查询的结果去使用不同的css样式以达到最佳的显示效果。</p><h3 id="媒体查询使用"><a href="#媒体查询使用" class="headerlink" title="媒体查询使用"></a>媒体查询使用</h3><h4 id="基础范式"><a href="#基础范式" class="headerlink" title="基础范式"></a>基础范式</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">检测设备分辨率</span><br><span class="line"><span class="keyword">@media</span> -mediatype- -and | <span class="keyword">not</span> | <span class="keyword">only</span> -(media feature)- &#123;</span><br><span class="line">CSS-<span class="selector-tag">Code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">根据设备分辨率引入文件</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; media=&quot;mediatype and|not|only (media feature)&quot; href=&quot;mystylesheet<span class="selector-class">.css</span>&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>用 @media 开头 注意@符号 </li><li>mediatype  媒体类型 </li><li>关键字 and  not   only</li><li> media feature 媒体特性 必须有小括号包含</li></ul><h4 id="属性详解"><a href="#属性详解" class="headerlink" title="属性详解"></a>属性详解</h4><p>mediatype 查询类型，将不同的终端设备划分成不同的类型，称为媒体类型，<strong>一般使用 screen</strong></p><p><img src="https://i.loli.net/2021/10/07/D8iPs1ZbQXMKA7I.png" alt="image-20211007222508126"></p><p>关键字 </p><ul><li>and：可以将多个媒体特性连接到一起，相当于“且”的意思。 </li><li>not：排除某个媒体类型，相当于“非”的意思，可以省略。 </li><li>only：指定某个特定的媒体类型，可以省略。</li></ul><p>媒体特性</p><p>每种媒体类型都具体各自不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格。我们暂且了解三个。注意他们要加小括号包含</p><p><img src="https://i.loli.net/2021/10/07/E1rsOG5hjDNeFqB.png" alt="image-20211007222823943"></p><h4 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">当分辨率小于<span class="number">540px</span>的设备查看时.使<span class="selector-tag">html</span>字体大小为<span class="number">16px</span>，且<span class="selector-tag">body</span>变蓝</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">540px</span>) &#123;</span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>:blue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当分辨率 <span class="number">540px</span> &lt; X &lt; <span class="number">970px</span> 的设备查看时，使<span class="selector-tag">html</span>字体大小为<span class="number">25px</span>，且<span class="selector-tag">body</span>变黑</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">540px</span>) &#123;</span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">25px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>:black;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当分辨率大于<span class="number">970px</span>的设备查看时，使<span class="selector-tag">html</span>字体大小为<span class="number">50px</span>，且<span class="selector-tag">body</span>变红</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">970px</span>) &#123;</span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用媒体查询引入不同css文件，当设备分辨率大于<span class="number">400px</span>时引入styleA<span class="selector-class">.css</span></span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;styleA<span class="selector-class">.css</span>&quot; media=&quot;screen and (<span class="attribute">min-width</span>: <span class="number">400px</span>)<span class="string">&quot;&gt;</span></span><br></pre></td></tr></table></figure><h4 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h4><p>分析媒体查询的里的css层叠特性</p><p><img src="https://i.loli.net/2021/10/07/GwktRdAie3QYoZM.png" alt="image-20211007224005323"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="code" scheme="http://example.com/tags/code/"/>
    
  </entry>
  
</feed>
