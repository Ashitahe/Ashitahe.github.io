<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Asuhe</title>
  
  <subtitle>Born in poverty, died of numbness</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-11-12T10:42:24.258Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Asuhe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js执行上下文</title>
    <link href="http://example.com/2021/11/12/2021-11-12-js%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>http://example.com/2021/11/12/2021-11-12-js%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</id>
    <published>2021-11-12T09:24:27.000Z</published>
    <updated>2021-11-12T10:42:24.258Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>在了解什么叫执行上下文之前我们需要区分一个小概念那就是程序执行和代码执行。我们的代码在执行之前是需要有一个环境的，就像我们做饭一样，做饭之前需要有做饭的环境就是厨房。代码执行就相当于做饭，做饭需要各种烹饪工具，而程序执行就是给代码执行创建一个可以让代码执行环境，相当于给一个厨房。程序执行的时候会在内存里面开辟空间存放各种代码执行需要的东西。<strong>而程序在解析和运行的时候也需要依赖一些环境，这些程序执行所依赖和使用的环境就叫做执行上下文。</strong></p><p>执行上下文根据范围的不同分为全局执行上下文和函数执行上下文。它是根据js的作用域来区分的，因为一般来说js就分为两种作用域，一种是全局作用域也就是最外层的作用域，另一种就是函数作用域。而上面两种执行上下文就是和这些作用域一一对应的。</p><p>程序执行时主要做三件事：</p><ul><li>收集变量，生成<strong>变量对象</strong>（预解析是其中的一个步骤）</li><li>确定 this 指向</li><li>确定作用域链</li></ul><p>有了这三步以后，我们的代码才能执行。其中第一步的生成变量对象实际上就是把我们声明的那些 var 变量 和函数都打包装进一个对象里面。我们都知道在script里面最顶级的对象是 window 对象，在全局执行上下文运行的时候那些在全局作用域下的 var变量和声明的函数都会收集进 window对象里，<strong>window就是一个变量对象</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/12/JgDQXyECYvZdj7w.png" alt="var a在全局作用域内"></p><h2 id="执行上下文调用栈"><a href="#执行上下文调用栈" class="headerlink" title="执行上下文调用栈"></a>执行上下文调用栈</h2><p>程序为了管理执行上下文（确保程序的执行顺序）所创建的一个栈数据结构，被称作执行上下文栈。本质上为了确保程序按预定的调用顺序执行，就使用栈这种结构来保存管理执行上下文。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/12/ntSeWVB36G7DRm1.png" alt="调用foo函数时的执行上下文调用栈"></p><p>程序开始执行：（全局环境和函数环境）</p><p>全局执行上下文（分为创建阶段和执行阶段）代码开始执行之前和之后</p><p>​    1、全局执行上下文压入执行上下文栈）<br>​    创建上下文阶段：<br>​        1、收集变量形成变量对象 （函数 var的变量会收集）<br>​        预解析（其实在创建变量对象的时候已经做了预解析）<br>​        2、确定this指向（可以认为确定执行者）<br>​        3、创建自身执行上下文的作用域链<br>​        注意：同时确定函数在调用时候的上级作用域链。（根据ECMA词法去确定，看内部是否引用外部变量确定）</p><p>​    2、执行全局执行上下文<br>​        执行全局上下文阶段<br>​        为变量真正赋值<br>​        顺着作用域链查找要使用的变量或者函数执行</p><p>函数执行上下文<br>    1、函数执行上下文压栈<br>        1、收集变量  （var 形参  arguments  函数）<br>        2、确定this指向（可以认为确定执行者）<br>        3、创建自身执行上下文的作用域链<br>        注意：同时确定函数在调用时候的上级作用域链。（根据ECMA词法去确定，看内部是否引用外部变量确定）<br>        函数的作用域链：  自己定义的时候已经确定了函数在调用时候的上级作用域链，因此，在函数调用的时候，只需要将自己的变量对象添加到上级作用域链的顶端；就形成自己的作用域链</p><pre><code>2、执行函数执行上下文    为变量真正赋值    顺着作用域链查找要使用的变量或者函数执行</code></pre><h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><p>预解析就是我们平常所说的变量提升。它会先解析函数，在解析变量。如果有函数重名，则函数覆盖。如果有变量重名则忽略。</p><h3 id="两个函数重名"><a href="#两个函数重名" class="headerlink" title="两个函数重名"></a>两个函数重名</h3><p>函数重名，函数覆盖</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo();  <span class="comment">// sphinx</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;asuhe&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;sphinx&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量与变量重名"><a href="#变量与变量重名" class="headerlink" title="变量与变量重名"></a>变量与变量重名</h3><p>重名变量的值被覆盖</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><h3 id="函数与变量重名"><a href="#函数与变量重名" class="headerlink" title="函数与变量重名"></a>函数与变量重名</h3><p>函数和变量重名，则忽略变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;asuhe&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a(); <span class="comment">// asuhe</span></span><br></pre></td></tr></table></figure><p>但是如果同名的变量在函数调用之前被赋值了，则会覆盖原来的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;asuhe&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">a(); <span class="comment">// asuhe</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">a(); <span class="comment">// TypeError 此时a已经不是函数了，被覆盖成了10</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">c(<span class="number">2</span>);  <span class="comment">//TypeError</span></span><br><span class="line"></span><br><span class="line">--------</span><br><span class="line"><span class="comment">//浏览器执行时，上述代码被翻译为</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c;</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">    c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c;</span><br><span class="line">c = <span class="number">1</span>;</span><br><span class="line">c(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">--------</span><br><span class="line"><span class="comment">//变形 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">c(<span class="number">2</span>);  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">-------</span><br><span class="line"><span class="comment">//变形 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br><span class="line">c(<span class="number">2</span>);  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"><span class="comment">//变形 3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">    <span class="keyword">let</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">c(<span class="number">2</span>);  <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure><h4 id="小测验"><a href="#小测验" class="headerlink" title="小测验"></a>小测验</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a) <span class="comment">// function</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(fn)</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">// fn函数体</span></span><br><span class="line">--------</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(fn)&#125;;</span><br><span class="line">fn(); <span class="comment">// fn函数体</span></span><br></pre></td></tr></table></figure><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域就是用来确定确定变量起作用的范围的。<strong>作用域在代码定义的时候确定死了，而不是在执行的时候确定。</strong>作用域的主要作用就是隔离变量，防止变量命名污染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>而且在 js 中只有全局作用域和函数作用域这两种作用域。像对象和循环等等带有 { } 的都不存在作用域，不能限定变量范围</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">fn</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(fn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn(); <span class="comment">// ReferenceError</span></span><br><span class="line">-------</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;asuhe&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;sphinx&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">foo(); <span class="comment">// asuhe</span></span><br><span class="line"><span class="built_in">console</span>.log(fn); <span class="comment">// undefined fn会被当做变量提升，但是不会获得定义</span></span><br></pre></td></tr></table></figure><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>作用域链是使用执行上下文当中变量对象所组成的链条结构（数组结构）是真实存在的，查找的时候其实真正是先去自身的变量对象当中查找，如果没有，去上级执行上下文的变量对象当中去查找，直到找到全局执行上下文的变量对象；  函数调用的时候上一级的变量对象其实是在函数定义的时候都已经确定好的。</p><p>当一个内部作用域引用外部作用域的变量时，外部作用域会被加入内部作用域变量对象的作用域链数组中，否则不加入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">30</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    fn1();</span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">// 10 20 30</span></span><br><span class="line"><span class="comment">//此时因为fn1内引用了fn内的变量，fn的变量对象会被加入fn1的作用域链以便查找变量</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/12/2HTfuOckJGvqobn.png" alt="fn变量对象被加入fn1的作用域链数组"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">30</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    fn1();</span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">//20 30</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/12/pOb7qZ4CwWiex8n.png" alt="fn变量对象被跳过"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>数组花式遍历</title>
    <link href="http://example.com/2021/11/11/2021-11-11-%E8%8A%B1%E5%BC%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://example.com/2021/11/11/2021-11-11-%E8%8A%B1%E5%BC%8F%E9%81%8D%E5%8E%86/</id>
    <published>2021-11-11T13:07:47.000Z</published>
    <updated>2021-11-11T13:46:11.746Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="for遍历"><a href="#for遍历" class="headerlink" title="for遍历"></a>for遍历</h2><p>for遍历是最基础最简单的一种遍历数组的方式，在js中的数组其实并不是其它语言通常意义上的数组。它实际上只是一个带有length属性的对象，当我们使用for循环加上index去遍历数组时，本质上是使用<code>obj[属性名]</code>的方式去遍历的，数组里它的属性名默认是从 0 开始增长的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">44</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; arr.length;index++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我我们使用<code>Object.keys()</code>方法去获取一个数组的值时，实际上它只会返回从 0 开始的属性名组成的新数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arr[<span class="string">&#x27;5&#x27;</span>] = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length) <span class="comment">// 6</span></span><br><span class="line">arr[<span class="number">7</span>] = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length) <span class="comment">// 8 </span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [ 1, 2, 3, 4, 5, 6, &lt;1 empty item&gt;, 20 ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(arr);</span><br><span class="line"><span class="built_in">console</span>.log(keys); <span class="comment">// [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;7&#x27;]</span></span><br></pre></td></tr></table></figure><p>当我们使用 [ ] 去获取对象属性的值时，实际上 [ ] 上的内容都会被强制转换成字符串的形式。也就是说 [ 7 ] 等价于 [ ‘7’ ]。</p><h2 id="for-in-遍历"><a href="#for-in-遍历" class="headerlink" title="for in 遍历"></a>for in 遍历</h2><p>使用 for in 适合用于遍历一个对象，但它效率极低。因为它不仅会遍历对象里的属性，而且还会延着原型链一直遍历所有原型的属性。但是由于原型上属性一般都是不可枚举的，所以通常不会被它枚举出来。但是若你给原型对象配置了一个可以枚举的属性，它就会将它枚举出来。遍历对象的属性都是随机的，根据引擎的不同其输出的顺序也不同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125; <span class="comment">// name age</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给原型对象添加一个可枚举属性</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.sex = <span class="string">&#x27;male&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125; <span class="comment">// name age sex   它将sex也遍历出来了</span></span><br></pre></td></tr></table></figure><h2 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h2><p>for of 用于遍历一个带有<strong>迭代器</strong>的对象。而通常内置的对象都会有一个迭代器供其使用。而我们自定的对象除非我们给它手动添加迭代器，否则是无法使用for of 遍历的。</p><p><img src="https://i.loli.net/2021/11/11/hYeG67q84KaZWAr.png" alt="数组的迭代器"></p><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p>forEach是数组内置的一个遍历方法，它的是个高效的数组遍历方法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>VUE基础(三)</title>
    <link href="http://example.com/2021/11/11/2021-11-11-VUE%E5%9F%BA%E7%A1%80(%E4%B8%89)/"/>
    <id>http://example.com/2021/11/11/2021-11-11-VUE%E5%9F%BA%E7%A1%80(%E4%B8%89)/</id>
    <published>2021-11-11T12:45:49.000Z</published>
    <updated>2021-11-11T13:05:52.199Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h2><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>props组件是组件通信最常用最简单的方式。它使用于父子组件之间进行通信。父组件可以给子组件传递函数数据和非函数数据，当我们给子组件传递一个<strong>非函数数据通常给子组件传递的是一个父组件配置对象里的一个属性，而不是具体的属性值</strong>。子组件拿到了这个属性就是拿到了它的引用，从而可以开始操作属性值。当我们传递非函数数据时，本质上就是父组件给子组件传递数据，以供子组件使用。</p><p>当我们给子组件传递的是一个函数数据而时，本质上就是父组件想要得到子组件中收集来的数据，子组件通过给父组件传递过来的函数传递实参的方式，将收集到的数据给父组件。</p><p>使用props方法通信主要是运用在父子（嵌套）关系里，若想给兄弟组件传递数据就必须经过组件的共同祖先来中转再传递给兄弟组件，十分麻烦。它能够让父组件数据传递给子组件的原因是因为，站在父组件这个层级，父组件能够看到子组件，而子组件看上层组件是看不见的。从我们拆分的语法也可以很容易理解，当我们引入一个文件时，使用<code>import </code>引入文件的那个文件能够清楚地知道自己引用了哪些文件，而对于被引用的文件它其实并不知道自己被谁引用了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子组件配置对象</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//第一种写法</span></span><br><span class="line">    <span class="attr">props</span>:[<span class="string">&#x27;传递过来的属性名&#x27;</span>]</span><br><span class="line">    <span class="comment">//第二种写法</span></span><br><span class="line">    <span class="attr">props</span>:&#123;</span><br><span class="line">        传递过来的属性名:<span class="built_in">Function</span>  <span class="comment">//可以指定传递过来的数据类型，这里指定为Function</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第三种写法</span></span><br><span class="line">    <span class="attr">props</span>:&#123;</span><br><span class="line">        传递过来的属性名:&#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="built_in">Function</span> <span class="comment">//指定数据类型</span></span><br><span class="line">            <span class="attr">required</span>:<span class="literal">true</span> <span class="comment">//指定必须传递</span></span><br><span class="line">            <span class="attr">defaulte</span>:value <span class="comment">//指定如果没传数据，默认数据的value</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>VUE基础(二)</title>
    <link href="http://example.com/2021/11/09/2021-11-09-VUE%E5%9F%BA%E7%A1%80(%E4%BA%8C)/"/>
    <id>http://example.com/2021/11/09/2021-11-09-VUE%E5%9F%BA%E7%A1%80(%E4%BA%8C)/</id>
    <published>2021-11-09T14:53:35.000Z</published>
    <updated>2021-11-10T14:26:15.083Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><p>根据官网给的图可以大致将Vue的生命周期分为四个阶段：初始化阶段、挂载阶段、更新阶段、销毁阶段。而每个阶段又可以分为前、后两个阶段。</p><p><img src="https://i.loli.net/2021/11/09/VJlqy2KYobWscwC.png" alt="vue生命周期"></p><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p>beforeCreate() 钩子可以让我们在初始化之前进行一些操作。在这个阶段，<strong>数据还没有被代理到我们创建的实例中</strong>，所以此时我们无法获取data里的数据。</p><p>created() 钩子可以让我们在初始化完成时进行一些操作。在这个阶段，<strong>数据完成了代理</strong>，此时我们可以获取 data中的数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line"><span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">msg</span>:<span class="string">&#x27;asuhe&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(msg); <span class="comment">//此时数据还未被代理无法获取msg属性的值，输出undefined</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(msg); <span class="comment">//数据已经被代理,输出asuhe</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h3><p>beforeMount()钩子可以让我们在DOM实际渲染到页面前进行一些操作，<strong>这时挂载点的数据已经被渲染好了，但还没有实际插入页面，我们无法获取到DOM节点。</strong></p><p>mounted()钩子可以让我们的在DOM实际渲染到页面后进行一些操作，<strong>此时DOM节点已经挂载，我们可以获取到DOM节点。</strong>通常这时我们会向服务器发送请求获得数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">ref</span>=<span class="string">&quot;pp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line"><span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">beforMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs.pp) <span class="comment">//undefined</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs.pp) <span class="comment">//&lt;p ref=&quot;pp&quot;&gt;&lt;/p&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h3><p>当数据更新的时候，data配置项里的数据是马上更新的，但页面上的数据并不是能马上更新。所以有beforeUpdate()和updated()这两个钩子供我们在页面数据更新前后进行操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line"><span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">isOk</span>:<span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">beforUpdate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs.pp) <span class="comment">//输出空</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">updated</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs.pp) <span class="comment">//&lt;p ref=&quot;pp&quot;&gt;&lt;/p&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">ref</span>=<span class="string">&quot;pp&quot;</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span>&#123;&#123;isShow?&#x27;小香香&#x27;:&#x27;明日香&#x27;&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;destroy&quot;</span>&gt;</span>点击销毁实例<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">isShow</span>:<span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">destroy</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.$destroy(); <span class="comment">//这里触发两个销毁阶段的钩子，同步回调</span></span><br><span class="line">            <span class="comment">//最后执行</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;正在清理&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.timer = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.isShow = !<span class="built_in">this</span>.isShow;</span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;,            </span><br><span class="line">    <span class="comment">//销毁阶段的两个钩子</span></span><br><span class="line">    <span class="function"><span class="title">beforeDestroy</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">//销毁阶段进行清理工作</span></span><br><span class="line">        <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.timer);</span><br><span class="line">        <span class="built_in">this</span>.timer = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;销毁了定时器&#x27;</span>);  </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">destroyed</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;销毁完毕&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//点击销毁按钮后输出顺序是: 销毁了定时器 销毁完毕 正在清理</span></span><br></pre></td></tr></table></figure><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><p>自定义指令分为定义全局指令和局部指令，全局自定义指令在任何一个Vue实例中都可以使用，而局部自定义指令只能在特定的Vue实例中使用</p><h3 id="全局自定义指令"><a href="#全局自定义指令" class="headerlink" title="全局自定义指令"></a>全局自定义指令</h3><p>  定义全局指令</p><p>  参数： 1、指令名称（不包含v- 只能是全小写） 2、回调函数</p><p>  （参数 1使用这个指令的那个节点,2这个指令使用的表达式的值以及表达式的集合）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">&#x27;upper&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">node,bindings</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// console.log(node,bindings)</span></span><br><span class="line">    node.textContent = bindings.value.toUpperCase();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="局部自定义指令"><a href="#局部自定义指令" class="headerlink" title="局部自定义指令"></a>局部自定义指令</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">directives</span>:&#123;</span><br><span class="line">        <span class="function"><span class="title">upper</span>(<span class="params">node,bindings</span>)</span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(<span class="string">&#x27;timeFormat&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">value,format=<span class="string">&#x27;YYYY-MM-DD hh:mm:ss&#x27;</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> moment(value).format(format)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">timeNow</span>: <span class="built_in">Date</span>.now()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>const 和 Object.freeze()</title>
    <link href="http://example.com/2021/11/08/2021-11-08-const-%E5%92%8C-Object.freeze()/"/>
    <id>http://example.com/2021/11/08/2021-11-08-const-%E5%92%8C-Object.freeze()/</id>
    <published>2021-11-08T12:12:48.000Z</published>
    <updated>2021-11-08T12:26:29.306Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>const 关键字是用来声明一个常量的，它可以使一个<strong>变量引用</strong>不能被改变，而且在定义之初就要赋予初值，不然会报语法错误。这个变量如果是数组或者对象，则它里面的内容其实是可以修改的。</p><p>而Object.freeze()方法是冻结了一个对象里面<strong>属性的引用</strong>，对象的属性值不能改变，但如果对象的属性值是另一个数组或对象，则这个属性值的内部依然可以修改。所以Object.freeze()实际上是一个<strong>浅冻结</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">18</span>,</span><br><span class="line">    <span class="attr">address</span>:[</span><br><span class="line">        <span class="string">&#x27;asuhe&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;asuka&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.age); <span class="comment">// 18</span></span><br><span class="line">obj.age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.age); <span class="comment">// 20</span></span><br><span class="line">obj = &#123;&#125;; <span class="comment">// TypeError</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(obj)</span><br><span class="line">obj.age = <span class="number">30</span>; </span><br><span class="line"><span class="built_in">console</span>.log(obj.age); <span class="comment">//20</span></span><br><span class="line">obj.address = []; <span class="comment">// 修改失败，但不报错</span></span><br><span class="line">obj.address[<span class="number">0</span>] = <span class="string">&#x27;sphinx&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(...obj.address); <span class="comment">//&#x27;sphinx&#x27; &#x27;asuhka&#x27;</span></span><br></pre></td></tr></table></figure><p>参考资料：</p><p><a href="https://stackoverflow.com/questions/33124058/object-freeze-vs-const"><a href="https://stackoverflow.com/questions/33124058/object-freeze-vs-const">Object.freeze() vs const</a></a></p><p><a href="https://alligator.io/js/const-vs-obj-freeze/">const vs Object.freeze() in JavaScript</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>VUE基础(一)</title>
    <link href="http://example.com/2021/11/08/2021-11-08-VUE%E5%9F%BA%E7%A1%80(%E4%B8%80)/"/>
    <id>http://example.com/2021/11/08/2021-11-08-VUE%E5%9F%BA%E7%A1%80(%E4%B8%80)/</id>
    <published>2021-11-07T23:54:23.000Z</published>
    <updated>2021-11-08T12:13:15.848Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="VUE的数据代理原理"><a href="#VUE的数据代理原理" class="headerlink" title="VUE的数据代理原理"></a>VUE的数据代理原理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &#123;&#123;msg&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">//最简单的Vue对象</span></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">msg</span>:<span class="string">&#x27;I love you，asuka&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们都知道当我们使用模板语法去输出msg时并不是直接输出data的msg，而是经过 vm 这层代理输出的。 </p><p>我们在模板中输出的所有数据、方法都是经过 vm 代理的，而不是直接使用配置对象中东西。同样地，当我们修改 msg或者方法时，我们修改的也是 data 、methods中的东西。而不是 vm 上挂载的，修改结果将直接影响到配置对象中的值。</p><p>那么这种数据代理是如何做到的呢，答案就是 Object.defineProperty()方法。</p><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h3><p>这个方法可以添加或修改一个属性，将其变为<strong>响应式属性</strong>。什么叫响应式属性呢，就是随着你源属性值的变化。它的属性值也跟随着变化。举个简单的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">firstName</span>:<span class="string">&#x27;zhang&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>:<span class="string">&#x27;san&#x27;</span>,</span><br><span class="line">    <span class="attr">fullName</span>:<span class="string">&#x27;zhang-san&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.fullName) <span class="comment">//zhang-san</span></span><br><span class="line"></span><br><span class="line">obj.firstName = <span class="string">&#x27;li&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.fullName) <span class="comment">//zhang-san</span></span><br><span class="line"><span class="comment">//我们改变firstName,合理的是输出是 li-san。但是输出的依然是zhang-san，也就是说fullName没有自动跟随firstName变化</span></span><br><span class="line">--------------</span><br><span class="line"><span class="comment">//如果我们将fullName变成响应式属性，那么上述需求就额能实现</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">&#x27;fullName&#x27;</span>,&#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123; <span class="comment">//每次输出fullName属性时，get函数就会被调用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">this</span>.lastName; </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">newVal</span>)</span>&#123; <span class="comment">//每次修改fullName属性时，set函数就会传入修改后的新值，然后被调用</span></span><br><span class="line">        <span class="keyword">let</span> arr = newVal.split(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.firstName = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">this</span>.lastName = arr[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj.fullName); <span class="comment">//zhang-san</span></span><br><span class="line"></span><br><span class="line">obj.firstName = <span class="string">&#x27;li&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.fullName); <span class="comment">//li-san</span></span><br><span class="line"></span><br><span class="line">obj.fullName = <span class="string">&#x27;xiao-xiangxiang&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.firstName); <span class="comment">//xiao</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.lastName); <span class="comment">//xiangxiang</span></span><br></pre></td></tr></table></figure><p>实际上我们可以 set 和 get 函数上做任何我们想做的事情。根据这个特性我们可以想到 vm 是如何做数据代理的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟数据代理</span></span><br><span class="line"><span class="keyword">let</span> vm = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> data = &#123;<span class="attr">msg</span>:<span class="string">&#x27;asuka&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(vm,<span class="string">&#x27;msg&#x27;</span>,&#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.msg;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line">        data.msg = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们可以看到 vm 原本就是个空对象，但是我们使用了Object.defineProperty()方法后，它就增添了一个属性<code>msg</code>，每当这个<code>msg</code>被输出时就会自动调用<code>get</code>函数，被修改时就会自动调用<code>set</code>函数</p><p>当我们只设置 get 函数进行操作时在 vue 中实际上就是单向数据绑定基础，而我们同时设置好 get 和 set 函数时在 vue 中就变成了双向数据绑定的基础</p><h2 id="computed和watch"><a href="#computed和watch" class="headerlink" title="computed和watch"></a>computed和watch</h2><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>我们把上例中<code>obj</code>变量拿过来，在这个变量中我们定义了<code>fullName</code>属性。实际上这个属性是由<code>firstName</code>和<code>lastName</code>这两个源头属性组合而成的。既然它是由其它属性组合而成的，那么我们就可以在配置对象的 data 中省略它的定义，直接在 vue 的模板中动态生成。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 第一种方法 直接使用字符串拼接它 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;firstName&#125;&#125; + &#x27;-&#x27; + &#123;&#123;lastName&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 第二种方法 用函数调用拼接,本质上和拼接字符串是一样的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>getFullName()<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">firstName</span>:<span class="string">&#x27;zhang&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">lastName</span>:<span class="string">&#x27;san&#x27;</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">getFullName</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="built_in">this</span>.firsName + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们使用字符串拼接它有一个很大的缺点就是，一旦数据多了起来。拼接字符串这种方法维护起来十分麻烦。而在 vue 它提供了一种计算属性的方式让我们可以更加高效地得到这个由其它属性组合而来的属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 第三种方法 计算属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">firstName</span>:<span class="string">&#x27;zhang&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">lastName</span>:<span class="string">&#x27;san&#x27;</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="comment">//计算出fullName，这个fullName可以不预先定义，会被动态创建</span></span></span><br><span class="line"><span class="javascript">    <span class="attr">computed</span>:&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">fullName</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123; <span class="comment">//类似Object.defineProperty()</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">this</span>.lastName;</span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">set</span>(<span class="params">newVal</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">/* code */</span></span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//当computed只使用 get 函数时，可以使用简写形式</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">fullName</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>表面上看起来使用<strong>computed</strong>去计算一个属性和第一种、第二种方法比起来貌似并没有什么区别，但是实际上用计算属性的方式去获取一个全新的响应式属性效率更高，因为它会被缓存起来。当<code>fullName</code>被多次使用时，它将会直接从缓存中拿出来使用不会多次使用<code>this.firstName + &#39;-&#39; + this.lastName</code>去拼接字符串。</p><p>由上我们可以总结出computed的特性：</p><ul><li>可以动态创建出一个属性，不用预先定义属性</li><li>创建出来的这个属性会被缓存，当属性的值不改变时使用该属性将会直接从缓存中拿出，提高效率</li></ul><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>除了上面三种方法来获得<code>fullName</code>属性我还有第四种方法得到<code>fullName</code>。那就是使用<code>watch</code>监视属性。使用监视的前提是这个属性必须预先存在，也就是说我们必须在data里预先就有需要监视的属性，然后才能去对它使用<code>watch</code>监视。这是和<strong>computed</strong>的一个重要区别。继续使用上面的例子，我们只需要在data后面在跟一个watch属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">firstName</span>:<span class="string">&#x27;zhang&#x27;</span>,</span><br><span class="line">        <span class="attr">lastName</span>:<span class="string">&#x27;san&#x27;</span>,</span><br><span class="line">        <span class="attr">fullName</span>:<span class="string">&#x27;&#x27;</span> <span class="comment">//使用watch时fullName必须预先存在</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">watch</span>:&#123;<span class="comment">//对象内放置被监视的属性</span></span><br><span class="line">    <span class="attr">firstName</span>:&#123; </span><br><span class="line"><span class="function"><span class="title">handler</span>(<span class="params">newVal,oldVal</span>)</span>&#123;  <span class="comment">//这里我们使用handler函数回调，handler是固定写法不可更改,hander会传入被监视属性的新值和旧值两个参数</span></span><br><span class="line">            <span class="comment">//只有当firstName这个属性发生变化时，handler回调才会执行</span></span><br><span class="line">            <span class="built_in">this</span>.fullName = newVal + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">immediat</span>:<span class="literal">true</span> <span class="comment">//配置了immediate 无论被监视属性是否变化都强制执行一次handler回调</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种watch写法  在Vue()的外部使用$watch方法监视lastName属性</span></span><br><span class="line">vm.$watch(<span class="string">&#x27;lastName&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">newVal,oldVal</span>)</span>&#123;</span><br><span class="line">    fullName = <span class="built_in">this</span>.firstName + <span class="string">&#x27;-&#x27;</span> + newVal;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过上面例子我们可以体会到watch的特点：</p><ul><li>被监视的属性必须预先存在</li><li>当被监视的属性不发生变化时，handler函数其实不会被调用</li><li>可以使用 immediat:true 强制执行 handler 回调</li></ul><h3 id="computed-和-watch-最重要的区别"><a href="#computed-和-watch-最重要的区别" class="headerlink" title="computed 和 watch 最重要的区别"></a>computed 和 watch 最重要的区别</h3><p>实际上 computed 和 watch 有一个最重要的区别就是，<strong>computed里面只能获取到同步的数据，而不能获取到异步的数据。而 watch 里面同步异步的数据都可以获取到。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123;fullName&#125;&#125;&lt;<span class="regexp">/p&gt;  /</span><span class="regexp">/ 1s后这个fullName可以被渲染出来 输出:嘿嘿</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">watch:&#123;</span></span><br><span class="line"><span class="regexp">    firstName:&#123;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/这个对象是一个配置对象</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/当数据发生改变的时候会自动调用handler回调</span></span><br><span class="line"><span class="regexp">        handler(newVal,oldVal)&#123;</span></span><br><span class="line"><span class="regexp">            </span></span><br><span class="line"><span class="regexp">            setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">                /</span><span class="regexp">/ 异步修改数据</span></span><br><span class="line"><span class="regexp">                this.fullName = &#x27;嘿嘿&#x27;;</span></span><br><span class="line"><span class="regexp">            &#125;, 1000);</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123;fullName&#125;&#125;&lt;<span class="regexp">/p&gt;  /</span><span class="regexp">/ 1s后这个fullName不能被渲染出来 fullName的值为null,无法得到字符串 哈哈</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">computed:&#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/计算属性的完整写法</span></span><br><span class="line"><span class="regexp">    fullName:&#123;</span></span><br><span class="line"><span class="regexp">        get()&#123;</span></span><br><span class="line"><span class="regexp">            let n = null;</span></span><br><span class="line"><span class="regexp">            /</span><span class="regexp">/异步修改数据</span></span><br><span class="line"><span class="regexp">            setTimeout(()=&gt;&#123;</span></span><br><span class="line"><span class="regexp">                n = &#x27;哈哈&#x27;;</span></span><br><span class="line"><span class="regexp">            &#125;)</span></span><br><span class="line"><span class="regexp">            return n;</span></span><br><span class="line"><span class="regexp">        &#125;,</span></span><br><span class="line"><span class="regexp">         /</span><span class="regexp">/ 当计算属性的数据能被修改时候使用（表单类元素在双向绑定计算属性值）</span></span><br><span class="line"><span class="regexp">        set(val)&#123;</span></span><br><span class="line"><span class="regexp">/</span>* code */</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>TypeError:this.getOptions is not a function</title>
    <link href="http://example.com/2021/11/07/2021-11-07-webpack%E4%B8%AD%E6%89%93%E5%8C%85css%E7%9A%84%E5%9D%91/"/>
    <id>http://example.com/2021/11/07/2021-11-07-webpack%E4%B8%AD%E6%89%93%E5%8C%85css%E7%9A%84%E5%9D%91/</id>
    <published>2021-11-07T03:29:37.000Z</published>
    <updated>2021-11-07T14:19:39.161Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="webpack-中打包-css、less、sass文件的坑"><a href="#webpack-中打包-css、less、sass文件的坑" class="headerlink" title="webpack 中打包 css、less、sass文件的坑"></a>webpack 中打包 css、less、sass文件的坑</h2><p>vscode用import语法引入css文件不显示css路径：安装一个路径显示插件即可，推荐使用<a href="https://marketplace.visualstudio.com/items?itemName=ionutvmi.path-autocomplete">Path Autocomplete</a>即可解决</p><p>原本安装好css-loader准备用webpack打包css文件时出现一堆底层报错说<code>TypeError: this.getOptions is not a function</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ERROR <span class="keyword">in</span> ./src/css/index.css</span><br><span class="line">Module build failed (from ./node_modules/style-loader/dist/cjs.js):</span><br><span class="line">TypeError: this.getOptions is not a <span class="keyword">function</span></span><br><span class="line">    at Object.loader (C:\Users\12071\Desktop\练习\webpack-test\node_modules\style-loader\dist\index.js:19:24)</span><br><span class="line"> @ ./src/js/app.js 8:0-25</span><br></pre></td></tr></table></figure><p>原因：loader版本不匹配</p><p>解决方案：安装配套版本的style-loader和css-loader</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//安装2.0版本的style-loader</span><br><span class="line">npm i style-loader@2.0.0</span><br><span class="line"></span><br><span class="line">//安装5.2.7版本的css-loader</span><br><span class="line">npm i css-loader@5.2.7</span><br></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/68580273/type-error-this-getoptions-is-not-a-function-for-style-loader">stackoverflow YYDS</a></p><p>less文件无法打包</p><p>原因：less-loader版本过高</p><p>解决方案：安装低于5.0版本的less-loader</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install less-loader@5.0 -D</span><br></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/66792368/less-files-not-getting-picked-up-by-less-loader/66793018#66793018">stackoverflow YYDS</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="报错处理" scheme="http://example.com/categories/%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86/"/>
    
    
    <category term="tools" scheme="http://example.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Promise</title>
    <link href="http://example.com/2021/11/05/2021-11-05-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAPromise/"/>
    <id>http://example.com/2021/11/05/2021-11-05-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAPromise/</id>
    <published>2021-11-05T00:26:46.000Z</published>
    <updated>2021-11-09T00:36:57.235Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>在学习Promise之前我们需要先明白一些基础知识，首先我们要知道什么叫实例对象，什么叫函数对象。所谓实例对象就是我们使用 new 关键字创建出来的对象，称为实例对象，一般简称对象。而函数对象是指当我们把一个函数当作对象使用时，此时我们称这个函数为函数对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数的两种身份：函数、函数对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// ok 当我们用()调用函数时，此时函数称为一个函数</span></span><br><span class="line">foo.a = <span class="number">20</span> <span class="comment">// 当我们像这样给函数添加属性或者方法时，此时函数称为一个函数对象</span></span><br></pre></td></tr></table></figure><p>按函数的调用者分类我们可以将某些函数称为回调函数，<strong>回调函数就是我们定义的，我们没调用，最终执行了。</strong>最典型的例子就是定时器里我们传入的函数。根据回调函数执行时机的不同，我们又可以将回调函数分为<strong>同步回调函数和异步回调函数</strong>。</p><p>同步回调函数的特点就是<strong>立即执行</strong>，完全执行完了才结束，不会放入回调队列中。<strong>换言之就是它是在主线程上执行的</strong>。例如数组遍历相关的回调函数、Promise的excutor函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]</span><br><span class="line">arr.forEach(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value))  </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;主线程&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出顺序为: 10 20 30 主线程</span></span><br></pre></td></tr></table></figure><p>上述例子中可以明显看到，数组forEach方法里的回调函数先于主线程上的 console.log 输出，这表明这个回调函数就是一个同步回调</p><p>与同步回调函数相反，异步回调函数的特点就是<strong>延迟执行</strong>，它会被放入回调队列里，等主线程上的函数都执行完以后将来再根据条件执行。例如定时器上的回调函数、ajax回调、Promise的成功 | 失败回调</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>(<span class="built_in">console</span>.log(<span class="string">&#x27;hello!&#x27;</span>)),<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;主线程&#x27;</span>)</span><br><span class="line"><span class="comment">//输出顺序为: 主线程 hello!</span></span><br></pre></td></tr></table></figure><p>即便定时器的延迟设为 0 ，它里面的回调函数依然要等待主线程执行完毕才能执行。这就是一个典型的异步回调</p><p>通过理解同步回调和异步回调的例子，我们可以明白。所谓同步就是绝对的串行执行，只有上一步执行完了下一步才能继续执行。想象这样的一个场景，我们去做饭，电饭煲在煮饭的同时我们可以继续处理我们的菜，我们不必等饭完全煮好了才开始做菜，这样太浪费时间了。这种就是异步执行。如果我们必须等到饭煮好了才开始炒菜之类的，那这种就是同步执行。</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>有了上面同步异步的概念以后，接下来我们就可以开始学习Promise了。我们先来看看它是什么，官方给的定义是啥。</p><ul><li><p>抽象表达: </p><ul><li>Promise是JS中进行<strong>异步编程</strong>的<strong>新方案</strong>(旧的是谁?—纯回调)</li></ul></li><li><p> 具体表达:</p></li><li><p>从语法上来说: Promise是一个构造函数</p></li><li><p> 从功能上来说: promise对象用来封装一个异步操作并可以获取其结果</p></li></ul><p>其实看了上面的表达我们还是不懂什么是Promise。从异步这个词入手，我们都知道ajax就是一个典型的异步操作。那么我们就可以用Promise来封装ajax请求。那我们为什么非要用Promise来封装异步操作，我们用普通的回调函数形式不一样可以吗？这就涉及到回调地狱这个问题，关于[Promise的优越性](# 回调地狱 )我们后面再谈。首先来明确一些基础的Promise知识</p><ul><li>Promise不是回调，是一个内置的构造函数，是程序员自己new调用的。</li><li>new Promise的时候，要传入一个回调函数，它是同步的回调，会立即在主线程上执行，它被称为executor函数</li><li>每一个Promise实例都有3种状态：初始化(pending)、成功(fulfilled)、失败(rejected)</li><li>每一个Promise实例在刚被new出来的那一刻，状态都是初始化(pending)</li><li>executor函数会接收到2个参数，它们都是函数，分别用形参：resolve、reject接收<ul><li>调用resolve函数会：<ul><li>让Promise实例状态变为成功(fulfilled)</li><li>可以指定成功的value。</li></ul></li><li>调用reject函数会：<ul><li>让Promise实例状态变为失败(rejected)</li><li>可以指定失败的reason。</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//new 一个实例</span></span><br><span class="line"><span class="keyword">const</span> p  = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据上面描述这个Promise必须传入一个excutor函数，而这个excutor函数又两个形参也是函数,我们不必定义该两个形参函数，可以直接调用</span></span><br><span class="line">(resolve,reject)=&gt;&#123;&#125;  <span class="comment">//excutor</span></span><br></pre></td></tr></table></figure><p>当我们使用一个Promise管理异步操作的时候，我们要在excutor函数内启动异步任务然后再用它的 then 方法来指定异步任务结束后根据Promise实例的状态来调用相应的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用Promise封装一个自己的get请求ajax</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myAjax</span>(<span class="params">url,datas</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">        <span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> xhr = <span class="keyword">new</span> XHLHttpRequest();</span><br><span class="line">            xhr.onreadystatuschange = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(xhr.status === <span class="number">200</span>) resolve(<span class="string">&#x27;ok&#x27;</span>) <span class="comment">//请求成功将Promise状态置为fulfilled</span></span><br><span class="line">                    <span class="keyword">else</span> reject(<span class="string">&#x27;falure&#x27;</span>)  <span class="comment">//请求失败将Promise状态置为rejected</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            xhr.opne(<span class="string">&#x27;GET&#x27;</span>,url);</span><br><span class="line">            xhr.send();</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = myAjax(<span class="string">&#x27;http://127.0.0.1/get&#x27;</span>,&#123;<span class="attr">test</span>:<span class="string">&#x27;test&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">p.then( <span class="comment">//为Promise实例指定成功与失败的回调函数</span></span><br><span class="line">    <span class="function">(<span class="params">value</span>)=&gt;</span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;请求成功1&#x27;</span>,value); &#125;, <span class="comment">//fulfilled状态调用</span></span><br><span class="line">    <span class="function">(<span class="params">reason</span>)=&gt;</span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;请求失败1&#x27;</span>,reason); &#125; <span class="comment">//rejected状态调用</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个promise指定多个成功/失败回调函数, 则会依次调用并不会覆盖</span></span><br><span class="line">p.then( <span class="comment">//为Promise实例指定成功与失败的回调函数</span></span><br><span class="line">    <span class="function">(<span class="params">value</span>)=&gt;</span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;请求成功2&#x27;</span>,value); &#125;, <span class="comment">//fulfilled状态调用</span></span><br><span class="line">    <span class="function">(<span class="params">reason</span>)=&gt;</span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;请求失败2&#x27;</span>,reason); &#125; <span class="comment">//rejected状态调用</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//若该次请求失败则依次输出:请求失败1 请求失败2</span></span><br></pre></td></tr></table></figure><ul><li>关于状态的注意点：<ul><li>三个状态:<ul><li>pending: 未确定的——初始状态</li><li>fulfilled: 成功的——调用resolve()后的状态</li><li>rejected: 失败的——-调用reject()后的状态</li></ul></li><li>两种状态改变<ul><li>pending ==&gt; fulfilled</li><li>pending ==&gt; rejected</li></ul></li><li>状态只能改变一次！</li></ul></li></ul><h2 id="Promise基本方法"><a href="#Promise基本方法" class="headerlink" title="Promise基本方法"></a>Promise基本方法</h2><h3 id="Promise构造函数-new-Promise-executor"><a href="#Promise构造函数-new-Promise-executor" class="headerlink" title="Promise构造函数: new Promise (executor) {}"></a>Promise构造函数: new Promise (executor) {}</h3><ul><li>executor函数: 是同步执行的，(resolve, reject) =&gt; {}</li><li>resolve函数: 调用resolve将Promise实例内部状态改为成功(fulfilled)。</li><li>reject函数: 调用reject将Promise实例内部状态改为失败(rejected)。</li><li>说明: excutor函数会在Promise内部立即同步调用,异步代码放在excutor函数中。</li></ul><h3 id="Promise-prototype-then方法-Promise实例-then-onFulfilled-onRejected"><a href="#Promise-prototype-then方法-Promise实例-then-onFulfilled-onRejected" class="headerlink" title="Promise.prototype.then方法: Promise实例.then(onFulfilled,onRejected)"></a>Promise.prototype.then方法: Promise实例.then(onFulfilled,onRejected)</h3><ul><li>onFulfilled: 成功的回调函数 (value) =&gt; {}</li><li>onRejected: 失败的回调函数 (reason) =&gt; {}</li><li>特别注意(难点)：then方法会返回一个新的Promise实例对象</li><li>如果上一个回调返回的是一个非promise对象，则这个新的Promise实例状态为fulfilled</li><li>当上一个回调返回一个Promise对象则该新返回的Promise对象的状态与回调返回的Promise对象一致</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span>&#123; resolve(<span class="string">&#x27;ok&#x27;</span>); &#125;) </span><br><span class="line"><span class="keyword">const</span> x = p.then(</span><br><span class="line"><span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="number">1</span>&#125;, <span class="comment">//返回非Promise值</span></span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>.reject(<span class="number">996</span>)&#125;</span><br><span class="line">)</span><br><span class="line">x.then(</span><br><span class="line"><span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功了&#x27;</span>), <span class="comment">//x状态为fulfilled,输出成功了</span></span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;失败了&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> z = p.then(</span><br><span class="line"><span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;&#125;)&#125;, <span class="comment">//返回Promise值</span></span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>.reject(<span class="number">996</span>)&#125;</span><br><span class="line">)</span><br><span class="line">z.then( <span class="comment">//z状态为 pending ,不调用回调函数</span></span><br><span class="line"><span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功了&#x27;</span>), </span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;失败了&#x27;</span>) </span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Promise-prototype-catch方法-Promise实例-catch-onRejected"><a href="#Promise-prototype-catch方法-Promise实例-catch-onRejected" class="headerlink" title="Promise.prototype.catch方法: Promise实例.catch(onRejected)"></a>Promise.prototype.catch方法: Promise实例.catch(onRejected)</h3><ul><li>onRejected: 失败的回调函数 (reason) =&gt; {}</li><li>说明: catch方法是then方法的语法糖, 相当于: then(undefined, onRejected)</li></ul><h3 id="Promise-resolve方法-Promise-resolve-value"><a href="#Promise-resolve方法-Promise-resolve-value" class="headerlink" title="Promise.resolve方法: Promise.resolve(value)"></a>Promise.resolve方法: Promise.resolve(value)</h3><ul><li>说明: 用于快速返回一个状态为fulfilled或rejected的Promise实例对象</li><li>备注：value的值可能是：(1)非Promise值  (2)Promise值</li><li>当传入的值为非Promise值时或空值时，直接返回一个 fulfilled 状态的 Promise实例</li><li>当传入的值为 Promise 时，返回的Promise状态跟随传入的Promise</li></ul><h3 id="Promise-reject方法-Promise-reject方法-reason"><a href="#Promise-reject方法-Promise-reject方法-reason" class="headerlink" title="Promise.reject方法: Promise.reject方法(reason)"></a>Promise.reject方法: Promise.reject方法(reason)</h3><ul><li>说明: 用于快速返回一个状态必为rejected的Promise实例对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="built_in">Promise</span>.reject(<span class="number">996</span>);</span><br><span class="line">x.then(</span><br><span class="line"><span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功了&#x27;</span>,value),</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;失败了&#x27;</span>,reason) <span class="comment">//调用该函数 输出:失败了 996</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Promise-all方法-Promise-all-promiseArr"><a href="#Promise-all方法-Promise-all-promiseArr" class="headerlink" title="Promise.all方法: Promise.all(promiseArr)"></a>Promise.all方法: Promise.all(promiseArr)</h3><ul><li>promiseArr: 包含n个Promise实例的数组</li><li>说明: 返回一个新的Promise实例, 只有所有的promise都成功才成功, 只要有一个失败了就直接失败。</li><li>若没有失败的值，且没有pending的值即全都成功返回的新Promise状态为fulfilled</li><li>若没有失败的值，但存在pending的值即数组内仅有pending和fulfilled两种值，则返回的新Promise状态为pending</li></ul><h3 id="Promise-race方法-Promise-race-promiseArr"><a href="#Promise-race方法-Promise-race-promiseArr" class="headerlink" title="Promise.race方法: Promise.race(promiseArr)"></a>Promise.race方法: Promise.race(promiseArr)</h3><ul><li>promiseArr: 包含n个Promise实例的数组</li><li>说明: 返回一个新的Promise实例, 成功还是很失败？以最先出结果的promise为准。</li><li>若最先出结果的promise为pending则跳过该promise</li><li>这也就意味着race返回的Promise实例仅有fulfilled和rejected两种状态，不存在pending状态的值</li></ul><h2 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h2><p>上面我们学习了基本Promise使用，但是我们依然没有看出来Promise的优越性在哪里。现在我们有这么一个需求，连发三次Ajax请求，仅当上次请求成功时才发送下一次请求，若请求失败则中断以后的所有请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用纯回调的方式封装ajax</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendAjax</span>(<span class="params">url,data,success,error</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    xhr.onreadystatechange = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) success(xhr.response);</span><br><span class="line">            <span class="keyword">else</span> error(<span class="string">&#x27;请求出了点问题&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//整理参数</span></span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data)&#123;</span><br><span class="line">        str += <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;data[key]&#125;</span>&amp;`</span></span><br><span class="line">    &#125;</span><br><span class="line">    str = str.slice(<span class="number">0</span>,-<span class="number">1</span>)</span><br><span class="line">    xhr.open(<span class="string">&#x27;GET&#x27;</span>,url+<span class="string">&#x27;?&#x27;</span>+str)</span><br><span class="line">    xhr.responseType = <span class="string">&#x27;json&#x27;</span></span><br><span class="line">    xhr.send()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传统解决方案，链式连发三个请求</span></span><br><span class="line">sendAjax(</span><br><span class="line">    <span class="string">&#x27;https://api.apiopen.top/getJoke&#x27;</span>,</span><br><span class="line">    &#123;<span class="attr">page</span>:<span class="number">1</span>,<span class="attr">count</span>:<span class="number">2</span>,<span class="attr">type</span>:<span class="string">&#x27;video&#x27;</span>&#125;,</span><br><span class="line">    <span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;第1次成功了&#x27;</span>,response);</span><br><span class="line">        sendAjax(</span><br><span class="line">            <span class="string">&#x27;https://api.apiopen.top/getJoke&#x27;</span>,</span><br><span class="line">            &#123;<span class="attr">page</span>:<span class="number">1</span>,<span class="attr">count</span>:<span class="number">2</span>,<span class="attr">type</span>:<span class="string">&#x27;video&#x27;</span>&#125;,</span><br><span class="line">            <span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;第2次成功了&#x27;</span>,response);</span><br><span class="line">                sendAjax(</span><br><span class="line">                    <span class="string">&#x27;https://api.apiopen.top/getJoke&#x27;</span>,</span><br><span class="line">                    &#123;<span class="attr">page</span>:<span class="number">1</span>,<span class="attr">count</span>:<span class="number">2</span>,<span class="attr">type</span>:<span class="string">&#x27;video&#x27;</span>&#125;,</span><br><span class="line">                    <span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">&#x27;第3次成功了&#x27;</span>,response);   <span class="comment">//回调地狱</span></span><br><span class="line">                    &#125;, </span><br><span class="line">                    <span class="function"><span class="params">err</span> =&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;第3次失败了&#x27;</span>,err);&#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;, </span><br><span class="line">            <span class="function"><span class="params">err</span> =&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;第2次失败了&#x27;</span>,err);&#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="function"><span class="params">err</span> =&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;第1次失败了&#x27;</span>,err);&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以看到当我们要进行三次链式的异步请求时，采用纯回调的方式来处理就导致了回调地狱的问题。要对代码进行维护十分困难。而如果我们采用Promise去封装异步请求，则可以解决回调地狱的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Promsie封装ajax</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendAjax</span>(<span class="params">url,data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        xhr.onreadystatechange = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) resolve(xhr.response);</span><br><span class="line">                <span class="keyword">else</span> reject(<span class="string">&#x27;请求出了点问题&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//整理参数</span></span><br><span class="line">        <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data)&#123;</span><br><span class="line">            str += <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;data[key]&#125;</span>&amp;`</span></span><br><span class="line">        &#125;</span><br><span class="line">        str = str.slice(<span class="number">0</span>,-<span class="number">1</span>)</span><br><span class="line">        xhr.open(<span class="string">&#x27;GET&#x27;</span>,url+<span class="string">&#x27;?&#x27;</span>+str)</span><br><span class="line">        xhr.responseType = <span class="string">&#x27;json&#x27;</span></span><br><span class="line">        xhr.send()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用Promise进行三次链式ajax请求</span></span><br><span class="line">sendAjax(<span class="string">&#x27;https://api.apiopen.top/getJoke&#x27;</span>,&#123;<span class="attr">page</span>:<span class="number">1</span>&#125;)</span><br><span class="line">    .then(</span><br><span class="line">        <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;第1次请求成功了&#x27;</span>,value);</span><br><span class="line">            <span class="comment">//发送第2次请求</span></span><br><span class="line">            <span class="keyword">return</span> sendAjax(<span class="string">&#x27;https://api.apiopen.top/getJoke&#x27;</span>,&#123;<span class="attr">page</span>:<span class="number">1</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">    .then(</span><br><span class="line">        <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;第2次请求成功了&#x27;</span>,value);</span><br><span class="line">            <span class="comment">//发送第3次请求</span></span><br><span class="line">            <span class="keyword">return</span> sendAjax(<span class="string">&#x27;https://api.apiopen.top/getJoke&#x27;</span>,&#123;<span class="attr">page</span>:<span class="number">1</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">)</span><br><span class="line">    .then(</span><br><span class="line">        <span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;第3次请求成功了&#x27;</span>,value);&#125;</span><br><span class="line">)</span><br><span class="line">.cathe(</span><br><span class="line"><span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err);  <span class="comment">//利用错误穿透进行兜底</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以明显地对比出来，利用Promise进行链式异步操作能清晰地看到调用结构，维护起来相比纯回调方便了很多。这就解决了回调地狱的问题。</p><h2 id="Promise的优势"><a href="#Promise的优势" class="headerlink" title="Promise的优势"></a>Promise的优势</h2><ul><li><p>指定回调函数的方式更加灵活: </p><ul><li>旧的: 必须在启动异步任务前指定</li><li>Promise: 启动异步任务 =&gt; 返回promie对象 =&gt; 给promise对象绑定回调函数(甚至可以在异步任务结束后指定)</li></ul></li><li><p>支持链式调用, 可以解决回调地狱问题</p><ul><li>什么是回调地狱：回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调函数执行的条件</li><li>回调地狱的弊病：代码不便于阅读、不便于异常的处理</li><li>一个不是很优秀的解决方案：then的链式调用</li><li>终极解决方案：async/await（底层实际上依然使用then的链式调用）</li></ul></li></ul><h2 id="Promise关键问题"><a href="#Promise关键问题" class="headerlink" title="Promise关键问题"></a>Promise关键问题</h2><h3 id="如何改变一个Promise实例的状态"><a href="#如何改变一个Promise实例的状态" class="headerlink" title="如何改变一个Promise实例的状态?"></a>如何改变一个Promise实例的状态?</h3><ul><li>执行resolve(value): 如果当前是pending就会变为fulfilled</li><li>执行reject(reason): 如果当前是pending就会变为rejected</li><li>执行器函数(executor)抛出异常: 如果当前是pending就会变为rejected</li></ul><h3 id="改变Promise实例的状态和指定回调函数谁先谁后"><a href="#改变Promise实例的状态和指定回调函数谁先谁后" class="headerlink" title="改变Promise实例的状态和指定回调函数谁先谁后?"></a>改变Promise实例的状态和指定回调函数谁先谁后?</h3><ul><li>都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调</li><li>如何先改状态再指定回调? <ul><li>延迟一会再调用then()</li></ul></li><li>Promise实例什么时候才能得到数据?<ul><li>如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据</li><li>如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据</li></ul></li></ul><h3 id="Promise实例-then-返回的是一个【新的Promise实例】，它的值和状态由什么决定"><a href="#Promise实例-then-返回的是一个【新的Promise实例】，它的值和状态由什么决定" class="headerlink" title="Promise实例.then()返回的是一个【新的Promise实例】，它的值和状态由什么决定?"></a>Promise实例.then()返回的是一个【新的Promise实例】，它的值和状态由什么决定?</h3><ul><li>简单表达: 由then()所指定的回调函数执行的结果决定</li><li>详细表达:<ul><li>如果then所指定的回调返回的是非Promise值a:<ul><li>那么【新Promise实例】状态为：成功(fulfilled), 成功的value为a</li></ul></li><li>如果then所指定的回调返回的是一个Promise实例p:<ul><li>那么【新Promise实例】的状态、值，都与p一致</li></ul></li><li>如果then所指定的回调抛出异常:<ul><li>那么【新Promise实例】状态为rejected, reason为抛出的那个异常</li></ul></li></ul></li></ul><h3 id="如何中断promise链："><a href="#如何中断promise链：" class="headerlink" title="如何中断promise链："></a>如何中断promise链：</h3><ul><li>当使用promise的then链式调用时, 在中间中断, 不再调用后面的回调函数。</li><li>办法: 在失败的回调函数中返回一个pendding状态的Promise实例。</li></ul><h3 id="Promise错误穿透的原理："><a href="#Promise错误穿透的原理：" class="headerlink" title="Promise错误穿透的原理："></a>Promise错误穿透的原理：</h3><ul><li>当使用promise的then链式调用时, 可以在最后用catch指定一个失败的回调,</li><li>前面任何操作出了错误, 都会传到最后失败的回调中处理了</li><li>备注：如果不存在then的链式调用，就不需要考虑then的错误穿透。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        reject(-<span class="number">100</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;成功了1&#x27;</span>,value);<span class="keyword">return</span> <span class="string">&#x27;b&#x27;</span>&#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;<span class="comment">//底层帮我们补上的这个失败的回调</span></span><br><span class="line">)</span><br><span class="line">    .then(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;成功了2&#x27;</span>,value);<span class="keyword">return</span> <span class="built_in">Promise</span>.reject(-<span class="number">108</span>)&#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;<span class="comment">//底层帮我们补上的这个失败的回调</span></span><br><span class="line">)</span><br><span class="line">    .catch(</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="async-amp-await"><a href="#async-amp-await" class="headerlink" title="async &amp; await"></a>async &amp; await</h2><ul><li><p>async修饰的函数</p><p>函数的返回值为promise对象</p><p>Promise实例的结果由async函数执行的返回值决定，返回非Promise值则返回的Promise对象状态为fulfilled，返回Promise则状态跟随返回的Promise，但是不能返回一个 rejected的Promise，否则报错</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = (<span class="keyword">async</span> () =&gt;&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(p) <span class="comment">//输出fulfilled</span></span><br><span class="line">p.then(</span><br><span class="line"><span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功了&#x27;</span>,value), <span class="comment">//执行成功回调</span></span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;失败了&#x27;</span>,reason)</span><br><span class="line">)</span><br><span class="line">----------</span><br><span class="line"><span class="keyword">const</span> p = (<span class="keyword">async</span> () =&gt;&#123;<span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="number">996</span>);&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(p) <span class="comment">//输出pending ,同时也说明了Promise.reject()是个异步函数</span></span><br><span class="line">p.then(</span><br><span class="line"><span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功了&#x27;</span>,value), </span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;失败了&#x27;</span>,reason)<span class="comment">//执行失败回调</span></span><br><span class="line">)</span><br><span class="line">----------</span><br><span class="line"><span class="keyword">const</span> p = (<span class="keyword">async</span> () =&gt;&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">()=&gt;</span>&#123;&#125;);&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(p) </span><br><span class="line">p.then(</span><br><span class="line"><span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功了&#x27;</span>,value), </span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;失败了&#x27;</span>,reason)</span><br><span class="line">)<span class="comment">//不调用任何一个,说明最后状态为pending</span></span><br><span class="line">----------</span><br><span class="line"><span class="keyword">const</span> p = (<span class="keyword">async</span> () =&gt;&#123;<span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">200</span>);&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(p) <span class="comment">//输出pending ,同时也说明了Promise.resolve()是个异步函数</span></span><br><span class="line">p.then(</span><br><span class="line"><span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功了&#x27;</span>,value), <span class="comment">//执行成功回调</span></span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;失败了&#x27;</span>,reason)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><p>await表达式</p><p>await右侧的表达式一般为Promise实例对象, 但也可以是其它的值</p><p>(1).如果表达式是Promise实例对象, await后的返回值是promise成功的值</p><p>(2).如果表达式是其它值, 直接将此值作为await的返回值</p></li><li><p>注意:</p><p>await必须写在async函数中, 但async函数中可以没有await</p><p>如果await的Promise实例对象失败了, 就会抛出异常, 需要通过try…catch来捕获处理</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reason</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;ok了&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;中断&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reason</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;Ok啊&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">4000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">;(<span class="keyword">async</span>()=&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> x1 = <span class="keyword">await</span> p1;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>,x1); <span class="comment">//输出:1 ok了</span></span><br><span class="line">        <span class="keyword">const</span> x2 = <span class="keyword">await</span> p2; <span class="comment">//该点直接失败转入失败回调 throw error</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>,x2);</span><br><span class="line">        <span class="keyword">const</span> x3 = <span class="keyword">await</span> p3;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>,x3);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err); <span class="comment">//catch接收上面throw 的 error 输出:中断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">------</span><br><span class="line"><span class="comment">//上面try里面的代码被浏览器翻译为</span></span><br><span class="line">p1.then(</span><br><span class="line"><span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>,value) <span class="keyword">return</span> p2;&#125; <span class="comment">//输出:1 ok了</span></span><br><span class="line">    <span class="comment">// 不写失败回调底层补上了 reason =&gt; throw reason</span></span><br><span class="line">).then(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>,value); <span class="keyword">return</span> p3;&#125;</span><br><span class="line">).then(</span><br><span class="line"><span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>,value);&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h3><p>目前为止，除了Promise里的成功和失败回调是微任务，其它异步回调都是宏任务</p><p>   宏队列:[宏任务1，宏任务2…..]</p><p>   微队列:[微任务1，微任务2…..]</p><p>   规则：每次要执行宏队列里的一个任务之前，先看微队列里是否有待执行的微任务</p><p>​      1.如果有，先执行微任务</p><p>​      2.如果没有，按照宏队列里任务的顺序，依次执行</p><h2 id="自我检测"><a href="#自我检测" class="headerlink" title="自我检测"></a>自我检测</h2><h3 id="初级版"><a href="#初级版" class="headerlink" title="初级版"></a>初级版</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// //代码一</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timeout&#x27;</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>).then(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功1&#x27;</span>,value)</span><br><span class="line">)</span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">2</span>).then(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功2&#x27;</span>,value)</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;主线程&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码二</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timeout1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timeout2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>).then(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功1&#x27;</span>,value)</span><br><span class="line">)</span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">2</span>).then(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;失败2&#x27;</span>,value)</span><br><span class="line">) </span><br><span class="line"></span><br><span class="line"><span class="comment">//代码三</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timeout1&#x27;</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">5</span>).then(</span><br><span class="line">        <span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功了5&#x27;</span>)</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timeout2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">3</span>).then(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功了3&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">4</span>).then(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;失败了4&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="高级版"><a href="#高级版" class="headerlink" title="高级版"></a>高级版</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">    &#125;).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;8&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>重绘与回流</title>
    <link href="http://example.com/2021/11/03/2021-11-03-%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81/"/>
    <id>http://example.com/2021/11/03/2021-11-03-%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81/</id>
    <published>2021-11-03T13:15:11.000Z</published>
    <updated>2021-11-03T13:16:22.798Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>重绘：样式改变重绘</p><p>回流：DOM改变回流</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="DOM" scheme="http://example.com/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>身份认证技术</title>
    <link href="http://example.com/2021/11/02/2021-11-02-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/"/>
    <id>http://example.com/2021/11/02/2021-11-02-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/</id>
    <published>2021-11-02T00:34:25.000Z</published>
    <updated>2021-11-02T01:46:40.406Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="身份认证的由来"><a href="#身份认证的由来" class="headerlink" title="身份认证的由来"></a>身份认证的由来</h2><p>平时我们在网页上进行交互时，例如登入自己的账号进行信息修改，往往需要服务器对我们进行身份的辨别，好让服务器能够拿到专属于我们自己账号的数据并返回给我们。由于http协议是无状态的，它并不会对会话进行控制。任何一个http请求对服务器来说都是独立的，毫不相干的请求。<a href="/2021/10/28/2021-10-28-http%E5%8D%8F%E8%AE%AE/" title="http协议">http协议</a>的这种特性就导致了我们需要自己想办法对用户进行识别，于是便有了身份认证技术。</p><p>现在流行的身份认证认证手段主要有三种，分别是：cookie、session和 JWT。这三种身份认证技术都有各自的适用场景，所以在前端中均有大量使用。下面就让我们深入了解一下这三种技术</p><h2 id="Cookie认证"><a href="#Cookie认证" class="headerlink" title="Cookie认证"></a>Cookie认证</h2><p>首先我们要明确什么是cookie。cookie实际上就是<strong>一份服务器给浏览器客户端设置的文本信息</strong>。当用户第一次登录进系统时，服务器会给用户设置一个cookie，后续用户每次发送http请求中都会携带cookie用于身份识别。</p><p>cookie信息都携带在请求头中，而且一个cookie的大小一般不超过4KB。</p><p><img src="https://i.loli.net/2021/11/02/uvhOaopbYzlVLrm.png" alt="请求头中的cookie"></p><p>它的内容由<strong>名称、值和一些用于控制有效期、安全性、使用范围的可选属性组成</strong>。不同域名下的cookie时各自独立的，不能拿一个网站的cookie去另一个网站做身份认证。每当客户端发起请求时，会<strong>自动</strong>把<strong>当前域名下</strong>所有<strong>未过期的</strong> <strong>Cookie</strong> 一同发送到服务器。</p><p>我们可以在浏览器的设置中查看cookie的内容</p><p><img src="https://i.loli.net/2021/11/02/vXBxOJRNS9u4Pqn.png" alt="某度的一个cookie"></p><p>因为cookie认证是用户单方面认证，用户完全可以自己伪造一个cookie发送给服务器来欺骗服务器，这使得cookie安全性较低。为了解决cookie的这个缺陷，进一步提高系统的安全性，所以又有了session机制来辅助身份认证。</p><h2 id="Session认证"><a href="#Session认证" class="headerlink" title="Session认证"></a>Session认证</h2><p>session认证即是在服务器上设置一个标识用户的信息，当用户拿cookie来认证时，服务器这边根据cookie拿出相应的session来必对认证。若服务器这边没有对应的session则说明该cookie是伪造的，拒绝响应。</p><p><img src="https://i.loli.net/2021/11/02/K75ZGYXQ6RJMjOC.png" alt="session认证原理"></p><p>有了session就可以防止用户伪造cookie登录进系统。进一步提高了安全性。</p><p>Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持 <a href="/2021/10/29/2021-10-29-%E5%90%8C%E6%BA%90%E4%B8%8E%E8%B7%A8%E5%9F%9F/" title="跨域访问">跨域访问</a>，所以，当涉及到前端跨域请求后端接口的时候，<strong>需要做很多额外的配置</strong>，才能实现跨域 Session 认证。</p><p>为了解决这个跨域问题，我们又升级了身份认证技术，采用JWT技术可以解决跨域认证的问题。</p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JWT（英文全称：JSON Web Token）是目前<strong>最流行</strong>的<strong>跨域认证解决方案</strong>。针对跨域问题，JWT采用Token加密字符串来实现身份认证。用户的信息通过 Token 字符串的形式，保存在客户端浏览器中。服务器通过还原 Token 字符串的形式来认证用户的身份。</p><p><img src="https://i.loli.net/2021/11/02/ZVlX2zeU5kWOug8.png" alt="JWT工作原理"></p><p>JWT 通常由三部分组成，分别是 Header（头部）、Payload（有效荷载）、Signature（签名）。</p><p>三者之间使用英文的“.”分隔，格式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Header.Payload.Signature</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><strong>Payload</strong> 部分<strong>才是真正的用户信息</strong>，它是用户信息经过加密之后生成的字符串。</li><li>Header 和 Signature 是<strong>安全性相关</strong>的部分，只是为了保证 Token 的安全性。</li></ul><p><img src="https://i.loli.net/2021/11/02/HCj5Ra2xt4MTiDz.png" alt="Payload部分"></p><p>客户端收到服务器返回的 JWT 之后，通常会将它储存在 <strong>localStorage 或 sessionStorage</strong> 中。</p><p>此后，客户端每次与服务器通信，都要带上这个 JWT 的字符串，从而进行身份认证。推荐的做法是<strong>把</strong> <strong>JWT</strong> <strong>放在</strong> <strong>HTTP</strong> <strong>请求头的</strong> <strong>Authorization</strong> <strong>字段中</strong>，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer &lt;token字符串&gt;</span><br></pre></td></tr></table></figure><h2 id="三种认证技术的区别与特点"><a href="#三种认证技术的区别与特点" class="headerlink" title="三种认证技术的区别与特点"></a>三种认证技术的区别与特点</h2><table><thead><tr><th align="center"><strong>认证技术</strong></th><th align="center"><strong>工作原理</strong></th><th align="center"><strong>生命周期</strong></th><th align="center">适用场景</th></tr></thead><tbody><tr><td align="center">cookie</td><td align="center">单向认证</td><td align="center">未设置expire属性的cookie关闭浏览器即失效</td><td align="center">服务器端渲染数据、同源认证</td></tr><tr><td align="center">session</td><td align="center">双向认证</td><td align="center">服务器未清除即一直生效</td><td align="center">服务器端渲染数据、同源认证</td></tr><tr><td align="center">JWT</td><td align="center">密钥认证</td><td align="center">服务器未更换secret就一直生效</td><td align="center">前后端分离架构、跨域认证</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Git快速上手指北</title>
    <link href="http://example.com/2021/10/29/2021-10-29-Git%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2021/10/29/2021-10-29-Git%E5%9F%BA%E7%A1%80/</id>
    <published>2021-10-29T11:36:37.000Z</published>
    <updated>2021-10-29T12:40:00.725Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Git基础使用"><a href="#Git基础使用" class="headerlink" title="Git基础使用"></a>Git基础使用</h2><h3 id="用户信息配置"><a href="#用户信息配置" class="headerlink" title="用户信息配置"></a>用户信息配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置自己的用户名和邮件地址 将用于记录谁操作了仓库</span></span><br><span class="line">git config --global user.name <span class="string">&quot;Asuhe&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;sphinx@asuhe.fun&quot;</span></span><br></pre></td></tr></table></figure><h3 id="配置信息检查"><a href="#配置信息检查" class="headerlink" title="配置信息检查"></a>配置信息检查</h3><p>通过 git config –global user.name 和 git config –global user.email 配置的用户名和邮箱地址，会被写<br>入到 C:/Users/用户名文件夹/.gitconfig文件中。这个文件是Git 的全局配置文件，配置一次即可永久生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有的全局配置</span></span><br><span class="line">git config --list --global</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定的全局配置项</span></span><br><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><h3 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取 config 命令的帮助手册，将会打开网页</span></span><br><span class="line">git <span class="built_in">help</span> config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 config 命令的快速参考手册</span></span><br><span class="line">git config -h</span><br></pre></td></tr></table></figure><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>在想要创建仓库的目录下启动 git 然后将文件跟踪提交即可在本地创建 git 仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化仓库</span></span><br><span class="line">git init</span><br><span class="line"><span class="comment"># 简要的显示文件状态</span></span><br><span class="line">git status -s | --short</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 跟踪会将文件放到暂存区</span></span><br><span class="line"><span class="comment"># 跟踪单个文件</span></span><br><span class="line">git add 文件名</span><br><span class="line"><span class="comment"># 跟踪目录下所有文件</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交文件,将会提交所有在暂存区的文件</span></span><br><span class="line">git commit -m <span class="string">&quot;更新描述&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 回滚，即将git仓库中文件版覆盖现有的文件版本</span></span><br><span class="line">git checkout -- 文件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件从暂存区移出</span></span><br><span class="line">git reset HEAD 文件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制提交所有已跟踪文件，跳过暂存阶段</span></span><br><span class="line">git commit -a -m <span class="string">&quot;更新描述&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时从git仓库和工作区中删除文件</span></span><br><span class="line">git rm -f 文件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅删除git仓库中的文件</span></span><br><span class="line">git rm --cached 文件名</span><br></pre></td></tr></table></figure><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>可以将不想提交的文件设置为忽略，这样文件就不会被 git 跟踪</p><p>创建一个名为.gitignore的配置文件，列出要忽略的文件的匹配模式。 文件 .gitignore 的格式规范如下： </p><p>① 以# 开头的是注释<br>② 以/结尾的是目录<br>③ 以/开头防止递归<br>④ 以!开头表示取反<br>⑤ 可以使用glob 模式进行文件和文件夹的匹配（glob 指简化了的正则表达式）</p><p>所谓的glob 模式是指简化了的正则表达式：<br>① 星号* 匹配零个或多个任意字符<br>② [abc] 匹配任何一个列在方括号中的字符（此案例匹配一个a或匹配一个b 或匹配一个c）<br>③ 问号?只匹配一个任意字符<br>④ 在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如[0-9] 表示匹配<br>所有0 到9 的数字）<br>⑤ 两个星号 ** 表示匹配任意中间目录（比如a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略所有的.a文件</span></span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跟踪所有的lib.a，即使前面设置了忽略.a文件</span></span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略当前目录下的TODO文件，而不忽略子目录下的TODO</span></span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略任何目录下名为build的文件夹</span></span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略doc/下的txt文件,但不忽略其子目录下的txt文件</span></span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略doc/目录及其所有子目录下的.pdf文件</span></span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure><h3 id="查看操作日志"><a href="#查看操作日志" class="headerlink" title="查看操作日志"></a>查看操作日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按时间降序列出提交历史</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示最近两条提交历史</span></span><br><span class="line">git <span class="built_in">log</span> -2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一行展示最近两条提交历史</span></span><br><span class="line">git <span class="built_in">log</span> -2 --pretty=oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义提交历史输出格式</span></span><br><span class="line"><span class="comment"># %h 提交的简写哈希值 %an作者名字 %ar作者修改日期 %s更新描述</span></span><br><span class="line">git <span class="built_in">log</span> -2 ---pretty=format:<span class="string">&quot;%h | %an | %ar | %s&quot;</span></span><br></pre></td></tr></table></figure><h3 id="回滚至指定版本"><a href="#回滚至指定版本" class="headerlink" title="回滚至指定版本"></a>回滚至指定版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回滚至指定ID的版本</span></span><br><span class="line">git reset --hard &lt;CommitID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br></pre></td></tr></table></figure><h3 id="将本地仓库推送至GitHub仓库"><a href="#将本地仓库推送至GitHub仓库" class="headerlink" title="将本地仓库推送至GitHub仓库"></a>将本地仓库推送至GitHub仓库</h3><p><strong>基于HTTPS</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关联远程仓库</span></span><br><span class="line">git remote add origin 远程仓库的地址</span><br><span class="line"><span class="comment"># 首次推送初始化</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p><strong>基于SSH</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成密钥对</span></span><br><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;github账号的邮箱&quot;</span></span><br><span class="line"><span class="comment"># 连续敲击 3 次回车，即可在 C:\Users\用户名文件夹\.ssh目录中生成id_rsa 和 id_rsa.pub 两个文件</span></span><br><span class="line"><span class="comment"># 复制id_rsa.pub的内容</span></span><br><span class="line"><span class="comment"># 在GitHub账号中添加公钥 Settings -&gt; SSH and GPG Keys -&gt; New SSH key</span></span><br><span class="line"><span class="comment"># 测试是否添加成功</span></span><br><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化操作类似HTTPS</span></span><br></pre></td></tr></table></figure><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前git仓库中的所有分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建分支</span></span><br><span class="line">git branch 分支名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换分支</span></span><br><span class="line">git checkout 分支名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建分支并切换到上面</span></span><br><span class="line">git checkout -b 分支名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并分支</span></span><br><span class="line">git merge 分支名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">git branch -d 分支名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送分支至远程仓库,仅第一次推送时要带-u参数</span></span><br><span class="line">git push -u 远程仓库别名(默认origin) 本地分支名称:远程分支名称</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例</span></span><br><span class="line">git push -u origin payment:pay <span class="comment"># 若不填写远程分支名称，远程分支名称将与本地分支一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看远程仓库分支信息</span></span><br><span class="line">git remote show 远程仓库名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载远程分支,本地分支名称默认与远程分支一致</span></span><br><span class="line">git checkout 远程分支名称</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从远程仓库把远程分支下载至本地，并对下载至本地的分支重命名</span></span><br><span class="line">git checkout -b 本地分支名称 远程仓库名:远程分支名称</span><br><span class="line"><span class="comment"># 实例</span></span><br><span class="line">git checkout -b payment origin/pay</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取当前分支中的远程分支代码</span></span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定远程分支</span></span><br><span class="line">git push 远程仓库名称 --delete 远程分支名称</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例</span></span><br><span class="line">git push origin --delete pay</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="tools" scheme="http://example.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>同源与跨域</title>
    <link href="http://example.com/2021/10/29/2021-10-29-%E5%90%8C%E6%BA%90%E4%B8%8E%E8%B7%A8%E5%9F%9F/"/>
    <id>http://example.com/2021/10/29/2021-10-29-%E5%90%8C%E6%BA%90%E4%B8%8E%E8%B7%A8%E5%9F%9F/</id>
    <published>2021-10-29T08:05:28.000Z</published>
    <updated>2021-11-02T01:53:12.464Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="域"><a href="#域" class="headerlink" title="域"></a>域</h2><p>在了解什么是同源和跨域之前我们首先要明确在浏览器中什么是域。浏览器中由协议名、服务器地址、端口号组成一个域。<img src="https://i.loli.net/2021/10/29/lLjnOkM3rZ6Q4m2.png" alt="默认网站的端口为80可以省略"></p><p><strong>同源</strong>指的是两个 URL 的协议、域名、端口一致，反之，则是<strong>跨域</strong>。</p><p>出现跨域的根本原因：<strong>浏览器的同源策略</strong>不允许非同源的 URL 之间进行资源的交互。</p><p>网页访问资源时，只要 url 的协议名、服务器地址、端口号中任何一个发生了改变就会产生跨域问题。</p><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>为了确保用户的上网安全，浏览器采用了同源策略来防止入侵。如果两个页面的协议，域名和端口都相同，则两个页面具有<strong>相同的源</strong>。。同源策略就是浏览器规定网页请求数据只能在同源站点中请求，不能跨域请求资源。浏览器规定，A 网站的 JavaScript，不允许和非同源的网站 C 之间，进行资源的交互。虽然我们的网络请求可以正常发送，服务器也会正常响应资源，但到浏览器这层资源就会被拦截下来，我们的 js 代码无法得到数据。例如：</p><p>①无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB</p><p>②无法接触非同源网页的 DOM</p><p>③无法向非同源地址发送 Ajax 请求</p><p><img src="https://i.loli.net/2021/10/29/nFq7L2iQuZzObN8.png" alt="数据被拦截"></p><h2 id="跨域解决方法"><a href="#跨域解决方法" class="headerlink" title="跨域解决方法"></a>跨域解决方法</h2><p>现如今，实现跨域数据请求，最主要的两种解决方案，分别是 JSONP 和 CORS。</p><p>JSONP：出现的早，兼容性好（兼容低版本IE）。是前端程序员为了解决跨域问题，被迫想出来的一种临时解决方案。缺点是只支持 GET 请求，不支持 POST 请求。</p><p>CORS：出现的较晚，它是 W3C 标准，属于跨域 Ajax 请求的根本解决方案。支持 GET 和 POST 请求。缺点是不兼容某些低版本的浏览器。</p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP (JSON with Padding) 是 JSON 的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。</p><p>由于浏览器同源策略的限制，网页中无法通过 Ajax 请求非同源的接口数据。但是 &lt;script&gt;标签不受浏览器同源策略的影响，可以通过 src 属性，请求非同源的 js 脚本。</p><p>因此，JSONP 的实现原理，就是通过 &lt;script&gt; 标签的 src 属性，请求跨域的数据接口，并通过<strong>函数调用</strong>的形式，接收跨域接口响应回来的数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//在这个标签页面定义函数</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> a + b;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//在另一个标签页调用函数</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://函数定义地址?callback=foo&amp;a=10s&amp;b=20&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于 JSONP 是通过 &lt;script&gt; 标签的 src 属性，来实现跨域数据获取的，所以，<strong>JSONP 只支持 GET 数据请求</strong>，不支持 POST 请求。</p><p><strong>JSONP</strong> <strong>和</strong> <strong>Ajax</strong> <strong>之间没有任何关系</strong>，不能把 JSONP 请求数据的方式叫做 Ajax，因为 JSONP 没有用到 XMLHttpRequest 这个对象。</p><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS （Cross-Origin Resource Sharing，跨域资源共享）由一系列 HTTP 响应头组成，<strong>这些</strong> <strong>HTTP</strong> <strong>响应头决定浏览器是否阻止前端</strong> <strong>JS</strong> <strong>代码跨域获取资源</strong>。</p><p>①CORS 主要在服务器端进行配置。客户端浏览器<strong>无须做任何额外的配置</strong>，即可请求开启了 CORS 的接口。</p><p>②CORS 在浏览器中有兼容性。只有支持 XMLHttpRequest Level2 的浏览器，才能正常访问开启了 CORS 的服务端接口（例如：IE10+、Chrome4+、FireFox3.5+）。</p><h3 id="CORS响应头部-Access-Control-Allow-Origin"><a href="#CORS响应头部-Access-Control-Allow-Origin" class="headerlink" title="CORS响应头部- Access-Control-Allow-Origin"></a>CORS响应头部- Access-Control-Allow-Origin</h3><p>响应头部中可以携带一个 <strong>Access-Control-Allow-Origin</strong> 字段，其语法如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin:&lt;origin&gt; | * //*为通配符</span><br></pre></td></tr></table></figure><p>其中，origin 参数的值指定了允许访问该资源的外域 URL。</p><p>例如，下面的字段值将<strong>只允许</strong>来自 <a href="http://asuhe.fun/">http://asuhe.fun</a> 的请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>,<span class="string">&#x27;http://asuhe.fun&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="CORS响应头部-Access-Control-Allow-Headers"><a href="#CORS响应头部-Access-Control-Allow-Headers" class="headerlink" title="CORS响应头部- Access-Control-Allow-Headers"></a>CORS响应头部- Access-Control-Allow-Headers</h3><p>默认情况下，CORS <strong>仅</strong>支持客户端向服务器发送如下的 9 个请求头：</p><p><strong>Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type （值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一）</strong></p><p>如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 Access-Control-Allow-Headers 对额外的请求头进行声明，否则这次请求会失败！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//允许客户端额外向服务器发送Content-Type请求头和X-Custom-Header请求头</span></span><br><span class="line">res.setHeader(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>,<span class="string">&#x27;Content-Type,X-Custon-Header&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="CORS响应头部-Access-Control-Allow-Methods"><a href="#CORS响应头部-Access-Control-Allow-Methods" class="headerlink" title="CORS响应头部- Access-Control-Allow-Methods"></a>CORS响应头部- Access-Control-Allow-Methods</h3><p>默认情况下，CORS 仅支持客户端发起 <strong>GET、POST、HEAD</strong> 请求。</p><p>如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 Access-Control-Alow-Methods来指明实际请求所允许使用的 HTTP 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//仅允许POST,GET,DELETE,HEAD方法</span></span><br><span class="line">res.setHeader(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>,<span class="string">&#x27;POST,GET,DELETE,HEAD&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//允许所有HTTP方法</span></span><br><span class="line">res.setHeader(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>,<span class="string">&#x27;*&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="CORS请求的分类"><a href="#CORS请求的分类" class="headerlink" title="CORS请求的分类"></a>CORS请求的分类</h3><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>同时满足以下两大条件的请求，就属于简单请求：</p><p>① 请求方式：GET、POST、HEAD 三者之一</p><p>② HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值application/x-www-form-urlencoded、multipart/form-data、text/plain）</p><h4 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h4><p>只要符合以下任何一个条件的请求，都需要进行预检请求：</p><p>① 请求方式为 GET、POST、HEAD 之外的请求 Method 类型</p><p>② 请求头中包含自定义头部字段</p><p>③ 向服务器发送了 application/json 格式的数据</p><p>在浏览器与服务器正式通信之前，浏览器会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求，所以这一次的 OPTION 请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据。</p><p><strong>其中OPTION预检请求的请求体为空，若预检成功则服务器返回的响应体也为空</strong></p><p><strong>简单请求的特点</strong>：客户端与服务器之间只会发生一次请求。</p><p><strong>预检请求的特点</strong>：客户端与服务器之间会发生两次请求，OPTION 预检请求成功之后，才会发起真正的请求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="BOM" scheme="http://example.com/tags/BOM/"/>
    
  </entry>
  
  <entry>
    <title>防抖与节流</title>
    <link href="http://example.com/2021/10/29/2021-10-29-%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
    <id>http://example.com/2021/10/29/2021-10-29-%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</id>
    <published>2021-10-29T07:11:24.000Z</published>
    <updated>2021-10-29T08:04:31.404Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>什么是防抖，在操作系统中如果一块数据在短时间内频繁地由内存换出到外存，再由外存换入内存。这种内存频繁进行换入换出的现象我们称之为内存抖动。类似的在前端中，如果一个页面过于地进行频繁地触发事件我们也将这种行为称之为抖动。</p><p><strong>防抖策略</strong>（debounce）是当事件被触发后，延迟 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。</p><p><img src="https://i.loli.net/2021/10/29/EYTveZJrRH21wV8.png" alt="防抖"></p><p>防抖最典型的应用例子就是我们在淘宝上进行商品搜索的时候，每当我们输入一个关键字，搜索框下面就会弹出相应关键字的搜索结果。</p><p><img src="https://i.loli.net/2021/10/29/YRlbuQnFfctiPZ6.png" alt="淘宝搜索匹配"></p><p>这里如果我们设置的是每当用户弹起键盘我们就发送一次ajax请求去刷新数据，那么在输入过程中就会导致太多的ajax请求被发送，造成抖动。所以我们需要减少一些不必要的网络请求来减轻服务器压力。</p><p><strong>代码实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置一个定时器记录</span></span><br><span class="line"><span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">ipt.addEventListener(<span class="string">&#x27;keyup&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//每次键盘按下就清除定时器,延迟触发</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    <span class="comment">//设置200ms后触发事件</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">/*进行相应操作*/</span></span><br><span class="line">    &#125;,<span class="number">200</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>和防抖类似减少事件触发的概念就是节流，节流的目的是让事件在规定的时间间隔内只能触发一次。和操作系统里同步问题使用互斥锁的思想类似。我们可以在触发某类事件时，先让它判断目前是否可以进入，若可以进入就让它进入后立即将flag置为false使后续事件不能继续进入，退出前在将flag置为true。</p><p><strong>节流策略</strong>（throttle），顾名思义，可以减少一段时间内事件的触发频率。</p><p><img src="https://i.loli.net/2021/10/29/iedsbl8ULn5Qyrq.png" alt="节流"></p><p>节流最典型的应用就是懒加载时要监听计算滚动条的位置，但不必每次滑动都触发，可以降低计算的频率，而不必去浪费 CPU 资源</p><p><strong>代码实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个节流阀</span></span><br><span class="line"><span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="comment">//关闭节流阀</span></span><br><span class="line">        flag = flase;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">/*进行相应操作*/</span></span><br><span class="line">            <span class="comment">//1000ms后开启节流阀</span></span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>防抖：如果事件被频繁触发，防抖能保证只有最后一次触发生效，前面 N 多次的触发都会被忽略！</p><p>节流：如果事件被频繁触发，节流能够减少事件触发的频率，因此，节流是有选择性地执行一部分事件！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="BOM" scheme="http://example.com/tags/BOM/"/>
    
  </entry>
  
  <entry>
    <title>http协议</title>
    <link href="http://example.com/2021/10/28/2021-10-28-http%E5%8D%8F%E8%AE%AE/"/>
    <id>http://example.com/2021/10/28/2021-10-28-http%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-10-28T00:43:22.000Z</published>
    <updated>2021-11-02T01:46:50.776Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是HTTP协议"><a href="#什么是HTTP协议" class="headerlink" title="什么是HTTP协议"></a>什么是HTTP协议</h2><p><strong>HTTP 协议</strong>即超文本传送协议 (HyperText Transfer Protocol) ，使用经典的<a href="https://en.wikipedia.org/wiki/Client%E2%80%93server_model">C/S模式</a>交互，它规定了客户端与服务器之间进行网页内容传输时，所必须遵守的传输格式。</p><p>在<a href="https://en.wikipedia.org/wiki/Internet_protocol_suite">TCP/IP网络模型</a>中，它位于<a href="https://en.wikipedia.org/wiki/Application_layer">应用层</a>采用传输层采用的是<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a>协议，端口号默认是<strong>80</strong>。虽然它采用的是TCP协议，但它实际上是一个<strong>无连接</strong>协议，这里的无连接是指服务器每次处理完客户端请求并收到客户端的响应回答后就会马上断开连接，并不会一直维持会话连接状态。同时它是一个<a href="https://en.wikipedia.org/wiki/Stateless_protocol">无状态协议</a>，即它并不会记录前后报文之间的关系。每一个请求报文在它看来都是独立的，没有上下文联系。这就给我们实际运用的时候带来了一些麻烦，例如在购物网站购买商品时，我们商品加入自己账号的购物车这就需要上下文联系。为了解决这个问题于是就有了<a href="/2021/11/02/2021-11-02%20%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/" title="cookie-session机制">cookie-session机制</a>来帮助我们建立上下文联系。</p><h2 id="为什么要HTTP协议"><a href="#为什么要HTTP协议" class="headerlink" title="为什么要HTTP协议"></a>为什么要HTTP协议</h2><p>它是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的，例如现在的电子邮箱流行使用http协议去传输内容。</p><h2 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h2><p>http的报文可以大致分为请求报文和响应报文两种，请求报文即为客户端向服务器发送的请求消息，而响应报文则是服务器根据客户端的请求响应回去的消息。</p><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p>HTTP 请求消息由请求行（request line）、请求头部（ header ） 、空行 和 请求体 4 个部分组成。</p><p><img src="https://i.loli.net/2021/10/28/MtukAIinQ2JCNvs.png" alt="请求报文基本格式"></p><h3 id="常见的请求头部"><a href="#常见的请求头部" class="headerlink" title="常见的请求头部"></a>常见的请求头部</h3><table><thead><tr><th><strong>头部字段</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Host</td><td>要请求的服务器域名</td></tr><tr><td>Connection</td><td>客户端与服务器的连接方式(close  或  keepalive)</td></tr><tr><td>Content-Length</td><td>用来描述请求体的大小</td></tr><tr><td><strong>Accept</strong></td><td>客户端可识别的响应内容类型列表</td></tr><tr><td><strong>User-Agent</strong></td><td>产生请求的浏览器类型</td></tr><tr><td><strong>Content-Type</strong></td><td>客户端告诉服务器实际发送的数据类型</td></tr><tr><td>Accept-Encoding</td><td>客户端可接收的内容压缩编码形式</td></tr><tr><td><strong>Accept-Language</strong></td><td>用户期望获得的自然语言的优先顺序</td></tr></tbody></table><p>我们可以在浏览器里具体抓一个请求报头来看看</p><p><img src="https://i.loli.net/2021/10/28/u236vDXOYrzJGZA.png" alt="GET请求头"></p><p><img src="https://i.loli.net/2021/10/28/dF9bL3phfgrlaRK.png" alt="POST请求头"></p><p>从上面请求头的对比中里我们可以得知一个结论。GET请求和POST请求的一个重要区别就是<strong>GET请求方式中，我们要发送的数据会携带在请求报头中，实际的请求体是为空的。而在POST请求方式中，我们要提交的数据会携带在请求体中，并不会夹带在请求头中。</strong></p><h3 id="响应报头"><a href="#响应报头" class="headerlink" title="响应报头"></a>响应报头</h3><p>HTTP响应消息由状态行、响应头部、空行 和 响应体 4 个部分组成，如下图所示：</p><p><img src="https://i.loli.net/2021/10/28/tq61CS3xo5hWckb.png" alt="响应报文基本格式"></p><p>实际浏览器中的响应报头</p><p><img src="https://i.loli.net/2021/10/28/rk643O5sEK9ljdp.png" alt="GET响应报头"></p><p><img src="https://i.loli.net/2021/10/28/2MERcynikH4O8T3.png" alt="POST响应报头"></p><h2 id="http请求方法"><a href="#http请求方法" class="headerlink" title="http请求方法"></a>http请求方法</h2><table><thead><tr><th><strong>序号</strong></th><th align="center"><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>1</td><td align="center"><strong>GET</strong></td><td>(查询)发送请求来获得服务器上的资源，请求体中不会包含请求数据，请求数据放在协议头中。</td></tr><tr><td>2</td><td align="center"><strong>POST</strong></td><td>(新增)向服务器提交资源（例如提交表单或上传文件）。数据被包含在请求体中提交给服务器。</td></tr><tr><td>3</td><td align="center"><strong>PUT</strong></td><td>(修改)向服务器提交资源，并使用提交的新资源，替换掉服务器对应的旧资源。</td></tr><tr><td>4</td><td align="center"><strong>DELETE</strong></td><td>(删除)请求服务器删除指定的资源。</td></tr><tr><td>5</td><td align="center">HEAD</td><td>HEAD  方法请求一个与 GET 请求的响应相同的响应，但没有响应体。</td></tr><tr><td>6</td><td align="center">OPTIONS</td><td>获取http服务器支持的http请求方法，允许客户端查看服务器的性能，比如ajax跨域时的预检等。</td></tr><tr><td>7</td><td align="center">CONNECT</td><td>建立一个到由目标资源标识的服务器的隧道。</td></tr><tr><td>8</td><td align="center">TRACE</td><td>沿着到目标资源的路径执行一个消息环回测试，主要用于测试或诊断。</td></tr><tr><td>9</td><td align="center">PATCH</td><td>是对  PUT 方法的补充，用来对已知资源进行局部更新 。</td></tr></tbody></table><h2 id="http响应状态码"><a href="#http响应状态码" class="headerlink" title="http响应状态码"></a>http响应状态码</h2><p>http的状态码可以分为5大类型</p><table><thead><tr><th align="center">分类</th><th align="left"><strong>分类描述</strong></th></tr></thead><tbody><tr><td align="center">1**</td><td align="left">信息，服务器收到请求，需要请求者继续执行操作（实际开发中很少遇到  1**  类型的状态码）</td></tr><tr><td align="center">2**</td><td align="left">成功，操作被成功接收并处理</td></tr><tr><td align="center">3**</td><td align="left">重定向，需要进一步的操作以完成请求</td></tr><tr><td align="center">4**</td><td align="left">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td align="center">5**</td><td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><h3 id="成功相关的响应状态码"><a href="#成功相关的响应状态码" class="headerlink" title="成功相关的响应状态码"></a>成功相关的响应状态码</h3><p>2** 范围的状态码，表示服务器已成功接收到请求并进行处理。常见的 2** 类型的状态码如下：</p><table><thead><tr><th align="center"><strong>状态码</strong></th><th align="center"><strong>状态码英文名称</strong></th><th><strong>中文描述</strong></th></tr></thead><tbody><tr><td align="center">200</td><td align="center">OK</td><td>请求成功。一般用于  GET 与 POST  请求</td></tr><tr><td align="center">201</td><td align="center">Created</td><td>已创建。成功请求并创建了新的资源，通常用于  POST 或 PUT  请求</td></tr></tbody></table><h3 id="重定向相关的响应状态码"><a href="#重定向相关的响应状态码" class="headerlink" title="重定向相关的响应状态码"></a>重定向相关的响应状态码</h3><p>3** 范围的状态码，表示表示服务器要求客户端重定向，需要客户端进一步的操作以完成资源的请求。常见的 3** 类型的状态码如下：</p><table><thead><tr><th align="center">状态码</th><th align="center"><strong>状态码英文名称</strong></th><th><strong>中文描述</strong></th></tr></thead><tbody><tr><td align="center">301</td><td align="center">Moved  Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td align="center">302</td><td align="center">Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td align="center">304</td><td align="center">Not  Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源（响应消息中不包含响应体）。客户端通常会缓存访问过的资源。</td></tr></tbody></table><h3 id="客户端错误相关的响应状态码"><a href="#客户端错误相关的响应状态码" class="headerlink" title="客户端错误相关的响应状态码"></a>客户端错误相关的响应状态码</h3><p>4** 范围的状态码，表示客户端的请求有非法内容，从而导致这次请求失败。常见的 4** 类型的状态码如下：</p><table><thead><tr><th align="center"><strong>状态码</strong></th><th align="center"><strong>状态码英文名称</strong></th><th><strong>中文描述</strong></th></tr></thead><tbody><tr><td align="center">400</td><td align="center">Bad  Request</td><td>语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。</td></tr><tr><td align="center">401</td><td align="center">Unauthorized</td><td>当前请求需要用户验证。</td></tr><tr><td align="center">403</td><td align="center">Forbidden</td><td>服务器已经理解请求，但是拒绝执行它。</td></tr><tr><td align="center">404</td><td align="center">Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。</td></tr><tr><td align="center">408</td><td align="center">Request  Timeout</td><td>请求超时。服务器等待客户端发送的请求时间过长，超时。</td></tr></tbody></table><h3 id="服务端错误相关的响应状态码"><a href="#服务端错误相关的响应状态码" class="headerlink" title="服务端错误相关的响应状态码"></a>服务端错误相关的响应状态码</h3><p>5** 范围的状态码，表示服务器未能正常处理客户端的请求而出现意外错误。前端甩锅码，只要出现5开头的响应码全部甩锅后端哈哈。常见的 5** 类型的状态码如下：</p><table><thead><tr><th align="center"><strong>状态码</strong></th><th align="center"><strong>状态码英文名称</strong></th><th><strong>中文描述</strong></th></tr></thead><tbody><tr><td align="center">500</td><td align="center">Internal  Server Error</td><td>服务器内部错误，无法完成请求。</td></tr><tr><td align="center">501</td><td align="center">Not  Implemented</td><td>服务器不支持该请求方法，无法完成请求。只有  GET 和 HEAD  请求方法是要求每个服务器必须支持的，其它请求方法在不支持的服务器上会返回501</td></tr><tr><td align="center">503</td><td align="center">Service  Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="CN" scheme="http://example.com/tags/CN/"/>
    
  </entry>
  
  <entry>
    <title>模板引擎的使用</title>
    <link href="http://example.com/2021/10/26/2021-10-26-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2021/10/26/2021-10-26-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2021-10-26T09:40:51.000Z</published>
    <updated>2021-10-27T00:41:16.535Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是模板引擎"><a href="#什么是模板引擎" class="headerlink" title="什么是模板引擎"></a>什么是模板引擎</h2><p>在我们要渲染相同的UI结构，如新闻列表、博客的文章列表时，用传统的方法我们需要大量拼接字符串。这使得代码运行效率低，页面加载也慢。不仅如此，当我们需要修改结构时，也需要在字符串中修改这使得代码维护起来十分麻烦而且灵活性非常差。</p><p>为了解决传统的方法的缺点，于是我们发明了模板引擎技术。使用模板引擎我们可以快速渲染出UI，同时由于清晰的模板结构我们要修改代码时也十分容易。</p><h2 id="art-template"><a href="#art-template" class="headerlink" title="art - template"></a>art - template</h2><p>art-template 是一个简约、超快的模板引擎，使用这个模板引擎我们可以很方便地生成一些UI结构。</p><h2 id="模板使用步骤"><a href="#模板使用步骤" class="headerlink" title="模板使用步骤"></a>模板使用步骤</h2><p>①导入 art-template</p><p>②定义数据</p><p>③定义模板</p><p>④调用 template 函数</p><p>⑤渲染HTML结构</p><h2 id="art-template基础语法"><a href="#art-template基础语法" class="headerlink" title="art-template基础语法"></a>art-template基础语法</h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>在标准语法中，可以进行变量的输出、对象属性的输出、三元表达式输出、逻辑或输出、加减乘除等表达式输出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;value&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;obj.key&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;obj[<span class="string">&#x27;key&#x27;</span>]&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;a ? b : c&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;a || b&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;a + b&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="原文输出"><a href="#原文输出" class="headerlink" title="原文输出"></a>原文输出</h3><p>如果要输出的 value 值中，包含了 HTML 标签结构，则需要使用<strong>原文输出</strong>语法，才能保证 HTML 标签被正常渲染。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;@ value &#125;&#125;  //类似innerHTML,会将value的文本内容当作HTML渲染</span><br></pre></td></tr></table></figure><h3 id="条件输出"><a href="#条件输出" class="headerlink" title="条件输出"></a>条件输出</h3><p>如果要实现条件输出，则可以在双花括号中使用 <strong>if</strong> … <strong>else if</strong> … <strong>/if</strong> 的方式，进行按需输出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;<span class="keyword">if</span> value&#125;&#125; 按需输出的内容 &#123;&#123;/<span class="keyword">if</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;<span class="keyword">if</span> v1&#125;&#125; 按需输出的内容 &#123;&#123;<span class="keyword">else</span> <span class="keyword">if</span> v2&#125;&#125; 按需输出的内容 &#123;&#123;/<span class="keyword">if</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>如果要实现循环输出，则可以在标准语法内，通过 each 语法循环数组，当前循环的索引使用 <strong>$index</strong> 进行访问，当前的循环项使用 <strong>$value</strong> 进行访问。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;each arr&#125;&#125;</span><br><span class="line">    &#123;&#123;$index&#125;&#125; &#123;&#123;$value&#125;&#125;</span><br><span class="line">&#123;&#123;/each&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>过滤器语法类似<strong>管道操作符</strong>，它的上一个输出作为下一个输入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;value | 处理函数名称&#125;&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//js文件中定义好处理函数的操作</span></span><br><span class="line">template.defaults.imports.处理函数名称 = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123; <span class="comment">//传入值为模板的value</span></span><br><span class="line">    <span class="comment">/*Code*/</span></span><br><span class="line">    <span class="keyword">return</span> res <span class="comment">//返回处理结果</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>注册时间：&#123;&#123;regTime | dateFormat&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template.defaults.imports.dateFormat = <span class="function"><span class="keyword">function</span>(<span class="params">date</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> y = date.getFullYear()</span><br><span class="line">   <span class="keyword">var</span> m = date.getMonth() + <span class="number">1</span></span><br><span class="line">   <span class="keyword">var</span> d = date.getDate()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> y + <span class="string">&#x27;-&#x27;</span> + m + <span class="string">&#x27;-&#x27;</span> + d <span class="comment">// 注意，过滤器最后一定要 return 一个值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="tips" scheme="http://example.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的继承</title>
    <link href="http://example.com/2021/10/23/2021-10-23-JavaScript%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
    <id>http://example.com/2021/10/23/2021-10-23-JavaScript%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/</id>
    <published>2021-10-23T00:33:54.000Z</published>
    <updated>2021-10-27T00:27:40.038Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="ES6以前"><a href="#ES6以前" class="headerlink" title="ES6以前"></a>ES6以前</h2><p>在es6以前 js 并没有专门的关键字可以实现继承特性，但是那时候我们又需要使用继承。于是就产生了一些方法可以实现继承的效果</p><h3 id="call调用实现继承父属性"><a href="#call调用实现继承父属性" class="headerlink" title="call调用实现继承父属性"></a>call调用实现继承父属性</h3><p>我们都知道<code>call</code>可以改变函数内<code>this</code>的指向，利用这个特性我们可以在子构造函数里面调用父构造函数，并利用<code>call</code>让父构造函数内的<code>this</code>指向子构造函数。这样就完成了继承操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = uname;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line">    Father.call(<span class="built_in">this</span>,uname,age); <span class="comment">//调用父构造函数，利用call传入自身的this实现继承</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用原型对象实现继承父方法"><a href="#利用原型对象实现继承父方法" class="headerlink" title="利用原型对象实现继承父方法"></a>利用原型对象实现继承父方法</h3><p>我们还可以通过让子构造函数的<code>prototype</code>指向一个父构造函数的实例的形式实现继承，不过需要注意的是在赋值完成后我们需要让<code>constructor</code>属性重新指回子构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = uname;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line">Father.prototype.say = <span class="function">()=&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;hello!&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = uname;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Son.prototype = Father.prototype 若我们直接赋值，会导致Son的原型对象和Father的原型对象是同一个，在Son中修改原型对象同时也会修改Father的。所以这样赋值是错误的</span></span><br><span class="line"></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();  <span class="comment">//通过一个Father实例化对象可以间接访问到Father的prototype</span></span><br><span class="line">Son.prototype.constructor = Son; <span class="comment">//让constructor指回Son构造函数，不然其会指向Father构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son(<span class="string">&#x27;Asuka&#x27;</span>,<span class="number">16</span>);</span><br><span class="line">son.say(); <span class="comment">//hello！</span></span><br></pre></td></tr></table></figure><h2 id="ES6以后"><a href="#ES6以后" class="headerlink" title="ES6以后"></a>ES6以后</h2><p>es6中引入了<code>class</code>关键字同时也引入了<code>extends</code>关键字，利用这些关键字我们可以很轻易的实现继承。同时若我们想要调用父类的方法和属性只需要使用<code>super</code>关键字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = uname;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;hello!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">uname,age,sex</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(uname,age); <span class="comment">//直接使用，调用父类constructor.一定要在this之前，不然SyntaxError</span></span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>.say();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;hi!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son(<span class="string">&#x27;Asuhe&#x27;</span>,<span class="number">16</span>,<span class="string">&#x27;male&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(son); <span class="comment">//Son &#123; name: &#x27;Asuhe&#x27;, age: 16, sex: &#x27;male&#x27; &#125;</span></span><br><span class="line">son.say();  <span class="comment">// hello! hi!</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>ES6新增特性</title>
    <link href="http://example.com/2021/10/22/2021-10-22-ES6%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2021/10/22/2021-10-22-ES6%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7/</id>
    <published>2021-10-22T00:14:57.000Z</published>
    <updated>2021-10-27T00:29:09.501Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="let关键字"><a href="#let关键字" class="headerlink" title="let关键字"></a>let关键字</h2><h3 id="作用域绑定在最近的-…-块中"><a href="#作用域绑定在最近的-…-块中" class="headerlink" title="作用域绑定在最近的{…}块中"></a>作用域绑定在最近的{…}块中</h3><p><code>let</code>在使用时会绑定离它最近的{…}作为作用域。原本在ES6以前是没有块级作用域的概念，在ES6引入了<code>let、const</code>关键字之后就有了块级作用域。<strong>实际上这个块级作用域并不是我们平常理解的块级作用域，仅当变量是由<code>let、const</code>关键字声明时，这些关键字声明的变量其作用域会绑定在这个块上，若是使用<code>var</code>关键字声明，其变量依然会成为全局变量。</strong></p><p>使用这个特性我们可以很好的解决 for 循环全局变量污染的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><h3 id="无变量提升"><a href="#无变量提升" class="headerlink" title="无变量提升"></a>无变量提升</h3><p><code>let</code>关键字在使用的时候，不像<code>var</code>那样存在变量提升的情况。它必须先声明再使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//ReferenceError</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"><span class="comment">//上述代码等价于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a;  <span class="comment">//var变量提升至所在作用域顶部</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//ReferenceError</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>所谓暂时性死区就是，你在块级作用域使用<code>let</code>声明了一个变量<code>i</code>，同时你在外部作用域也声明的一个同名变量<code>i</code>。若你在<code>let</code>声明这个变量前使用它，它并不会像以前的那样去上级作用域寻找这个变量，仅会在该作用域内寻找变量，又因为变量使用<code>let</code>声明，并且声明在其使用之后，就会抛出ReferenceError。<strong>因为使用<code>let</code>在作用域内声明了同名变量，它会屏蔽外界变量，这个块级区域就被称为暂时性死区</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//if&#123;&#125;内形成暂时性死区</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">-------------</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//不是同名变量，没有暂时性死区</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 20</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><h3 id="声明时必须赋值"><a href="#声明时必须赋值" class="headerlink" title="声明时必须赋值"></a>声明时必须赋值</h3><p><code>const</code>关键字的特性和<code>let</code>相同，<code>let</code>有的特性<code>const</code>都具有。不同点是<strong>它在声明的同时必须赋予一个值</strong>，否则抛出SyntaxError。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a;  <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure><h3 id="赋值后不可改变"><a href="#赋值后不可改变" class="headerlink" title="赋值后不可改变"></a>赋值后不可改变</h3><p>这里<code>const</code>关键字声明的变量能否更改还需要看具体的情况。</p><p>若<code>const</code>声明的是一个基本数据类型，则不能更改其值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">20</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>但是如果<code>const</code>声明的是一个复杂数据类型，则可以更改复杂数据类型变量内部的值，不可更改该复杂数据类型变量本身</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">100</span>; </span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// [1,100,3]</span></span><br><span class="line">b = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]; <span class="comment">//TypeError</span></span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>最初使用箭头函数的目的就是为了简化函数声明的操作，但它的作用不仅如此。我们都知道<code>this</code>指针的指向在不同地方其指向不同，例如在构造函数中其指向就是它的实例化对象，在<code>class</code>中的<code>constructor</code>中也是同样的指向自身的实例化对象，而在普通函数中其指向的是函数的调用者。</p><h3 id="箭头函数中的this是根据上下文环境确定的"><a href="#箭头函数中的this是根据上下文环境确定的" class="headerlink" title="箭头函数中的this是根据上下文环境确定的"></a>箭头函数中的<code>this</code>是根据上下文环境确定的</h3><p>箭头函数<code>this</code>指向的是<strong>被声明的作用域里面</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.querSelector(<span class="string">&#x27;.btn&#x27;</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line"><span class="comment">//在定时器的回调函数中使用箭头函数则其this会根据上下文指向btn对象，而不是指向window</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// btn</span></span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多种简写形式"><a href="#多种简写形式" class="headerlink" title="多种简写形式"></a>多种简写形式</h3><p>当形参只有一个且函数体内仅有一句返回值时</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="params">n</span> =&gt;</span> n*<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价一</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n*<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价二</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n*<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">a,b</span>) =&gt;</span> a+b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价一</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价二</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><h3 id="数组的解构"><a href="#数组的解构" class="headerlink" title="数组的解构"></a>数组的解构</h3><p>在es6中我们可以使用新的方式来命名多个变量，这种新的声明赋值方式就叫解构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统命名多个变量并赋值的方式</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>,b = <span class="number">20</span>,c = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//采用数组解构的方式</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>];</span><br><span class="line"><span class="keyword">let</span> [a,b,c] = arr;  <span class="comment">//a = 10,b = 20,c = 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当变量数量大于数组长度</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> [a,b,c,d] = arr; <span class="comment">//a = 1,b = 2, c = 3,d = undefined //多余的变量为未定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当变量数量少于数组长度</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> [a,b] = arr; <span class="comment">//a = 1,b = 2  //多余的直接被截断</span></span><br><span class="line"></span><br><span class="line">--------------</span><br><span class="line"><span class="comment">//对象解构</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;Asuhe&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>:myname,<span class="attr">age</span>:myage,<span class="attr">sex</span>:mysex&#125; = obj; <span class="comment">//myname = &#x27;Asuhe&#x27;,myage = 18,mysex = &#x27;男&#x27; //按匹配相同名称，即使乱序也会匹配上</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">let</span> myname = <span class="string">&#x27;Asuhe&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> myage = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">let</span> sex = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line"><span class="keyword">let</span> &#123;name,age,sex&#125; = obj;</span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Asuhe&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">let</span> sex = <span class="string">&#x27;男&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><p>在es6中新扩展了一种方法可以使函数的形参接收不定数量的实参，那就是使用<strong>剩余参数</strong>。我们知道在以前js同样支持函数形参和实参数量不匹配，即使定义函数时形参列表为空我们依然可以使用<code>arguments</code>对象获取到实参。<strong>但在es6新增的箭头函数中并不支持<code>arguments</code>，所以es6扩展了<code>...args</code>剩余参数来解决这个问题。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统获取所有形参</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">//2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">2</span>]); <span class="comment">//3</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用剩余参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,...args</span>)</span>&#123; <span class="comment">//剩余参数必须放在最后一个形参的位置</span></span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">console</span>.log(args); <span class="comment">//[2,3,4,5] //以数组的形式存储值</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>原型与原型链</title>
    <link href="http://example.com/2021/10/20/2021-10-20-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://example.com/2021/10/20/2021-10-20-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</id>
    <published>2021-10-20T00:04:04.000Z</published>
    <updated>2021-10-27T00:28:57.140Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是原型"><a href="#什么是原型" class="headerlink" title="什么是原型"></a>什么是原型</h2><p>在搞明白什么是原型之前我们首先要明白我们为什么要原型，毕竟语言的设计者不会无缘无故搞出一个完全没有用的东西，它肯定是为了解决某个问题而诞生的。那么原型它解决了什么问题呢？</p><p>我们都知道在es6之前，js是没有关键字<code>class</code>创建类的。那时候我们要使用类就用构造函数这种形式来实现它。在C++这种原生支持类的语言中，同一个类的多个实例里的方法只有一份，也就是说不管我们实例化了多少个对象，在计算机的内存中这个类的方法在内存中只有一份。只有每个实例的属性才会在内存中产生多个副本。例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">getName</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.name; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.age; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    foo a = <span class="keyword">new</span> <span class="built_in">foo</span>();</span><br><span class="line">    foo b = <span class="keyword">new</span> <span class="built_in">foo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在计算机的内存中，a、b这两个实例化对象的内存分布仅有private里的属性才有独立的内存副本，而public里的方法a、b是共享同一片内存的，这样设计就节约了内存空间。</p><p><img src="https://i.loli.net/2021/10/20/2PxV6KqCkLseEaQ.png" alt="C++的类方法只占一份内存"></p><p>而在es6以前没有<code>class</code>时候，我们通过构造函数实例化的类就会出现上图的第一种情况。每个实例的方法都有独有的内存空间。为了解决这个问题，所以就出现了原型。构造函数通过原型分配的函数是所有对象所共享的，也就实现了第二种内存分布。</p><h2 id="如何使用原型"><a href="#如何使用原型" class="headerlink" title="如何使用原型"></a>如何使用原型</h2><p>JavaScript 规定，每一个构造函数都有一个prototype 属性，指向prototype对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。</p><p>我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = uname;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="comment">//定义类共享的方法时我们将方法定义在原型上，而不是构造函数内部</span></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;哈喽&#x27;</span>); &#125;;  <span class="comment">//这样定义方法，多个实例对象就可以共享</span></span><br><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> Person(<span class="string">&#x27;Asuhe&#x27;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> woman = <span class="keyword">new</span> Person(<span class="string">&#x27;Asuka&#x27;</span>,<span class="number">16</span>);</span><br><span class="line">man.say();  <span class="comment">//输出 哈喽</span></span><br><span class="line">woman.say(); <span class="comment">//输出 哈喽</span></span><br></pre></td></tr></table></figure><h2 id="对象原型"><a href="#对象原型" class="headerlink" title="对象原型"></a>对象原型</h2><p>在构造函数拥有一个原型对象叫prototype，<strong>这个原型对象由构造函数内的prototype属性指明</strong>，每个构造函数都有一个这样的原型对象。经过上述学习我们知道共享的方法是定义在构造函数的原型prototype中的，但是我们的实例化对象却能使用定义在构造函数里prototype上的方法。这是如何实现的呢？</p><p>实现这个机制的就是我们即将要讲的<strong>对象原型</strong>。在每个实例化的对象中，都会包含一个<strong>属性</strong><code>__proto__</code>。这个<code>__protto__</code>属性就是令我们的实例化对象能够调用构造函数里<code>prototype</code>对象里定义的方法的原因，我们同时也称这个属性为对象原型。<code>__proto__</code>属性指向的是我们的构造函数的<code>prototype</code>原型对象，如上面的<code>man</code>当我们使用实例化的对象调用<code>prototype</code>里的方法时，我们的调用链是：<code>man</code> -&gt; <code>__proto__</code>  -&gt; <code>prototype</code> -&gt; <code>say()</code>。</p><p>经过这一层调用，我们的构造函数与实例化对象之间就形成了如下三角关系</p><p><img src="https://i.loli.net/2021/10/20/We5yfcVqx2bsZGk.png" alt="image-20211020094410424"></p><h2 id="constructor构造函数"><a href="#constructor构造函数" class="headerlink" title="constructor构造函数"></a>constructor构造函数</h2><p>不管我们构造函数里的原型对象<code>Prototype</code>，还是我们实例化的对象里的对象原型<code>__proto__</code>，它们都包含了一个<strong>属性</strong><code>constructor</code>。<code>constructor</code>属性的作用就是指明我们引用的构造函数是哪个。例如我们的<code>man、woman</code>它们都是通过构造函数<code>Person</code>创建出来的，所以它们的对象原型里的<code>construtctor</code>属性指向的就应该是<code>Person</code>这个构造函数。按这个指向顺序我们属性指向的关系应该是如下</p><p><img src="https://i.loli.net/2021/10/20/TKE9jX5aDgdJfsW.png" alt="直觉上对象原型里constructor的指向"></p><p>但事实情况是不是这样的呢？实际上对象原型里的constructor指向是通过构造函数里的<code>prototype.constructor</code>间接指回构造函数的。</p><p><img src="https://i.loli.net/2021/10/20/2CUPlsKLuvbJtGp.png" alt="20211020100310.png"></p><p>一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor  就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line"><span class="attr">say</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;哈喽&#x27;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果我们采用上述赋值的形式给原型对象添加新的方法，这意味着原本的那个原型对象被我们覆盖了。此时constructor指向的并不是Person</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所以我们需要手动指定constructor的指向，让它重新指向Person</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="attr">constructor</span>:Person,</span><br><span class="line"><span class="attr">say</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;哈喽&#x27;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>当我们继续打印出<code>prototype</code>这个对象的时候，我们可以看到<code>prototype</code>里面和已经实例化的对象一样里面也有一个<code>__proto__</code>对象原型。那么这个<code>__proto__</code>又指向哪里呢。实际上这个<code>__proto__</code>指向的是js内置的空对象<code>Object</code>的<code>prototype</code>。这个<code>Objerct</code>构造函数的对象原型里的<code>__proto__</code>还会继续往下指向最后的<code>null</code>。所以当我们查找方法时就会延着这条路径链式查找下去返回最先查找到的方法，若最后没找到则返回null。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = uname;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Person.prototype.__proto__指向的是Object的prototype，Object.prototype.__proto__指向null</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/20/Q4hrRYLdgxqDAGP.png" alt="输出结果"></p><p><img src="https://i.loli.net/2021/10/20/D1tKv4GVaNwAUu8.png" alt="实例对象查找共享方法的链式结构"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = uname;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;哈喽&#x27;</span>); &#125;;  </span><br><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> Person(<span class="string">&#x27;Asuhe&#x27;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> woman = <span class="keyword">new</span> Person(<span class="string">&#x27;Asuka&#x27;</span>,<span class="number">16</span>);</span><br><span class="line">man.say();  <span class="comment">//输出 哈喽  //在Person.prototype中找到了say方法，停止查找</span></span><br><span class="line">woman.sleep(); <span class="comment">//输出 TypeError //Person.prototype -&gt; Object.prototype中均未找到sleep方法，返回null</span></span><br></pre></td></tr></table></figure><p>像上面这种<code>__proto__</code>层层查找构成的链式结构就是我们常说的原型链。</p><p>还有一点需要我们注意的是，不管是构造函数里的<code>this</code> 还是构造函数的prototype里的<code>this</code>都是指向我们实例化出来的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = uname;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ptr = <span class="literal">null</span>;</span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;哈喽&#x27;</span>);</span><br><span class="line">    ptr = <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> Person(<span class="string">&#x27;Asuhe&#x27;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(man === ptr) <span class="comment">//输出 true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>sessionStorage 和 localStorage</title>
    <link href="http://example.com/2021/10/19/2021-10-19-sessionStorage-%E5%92%8C-localStorage/"/>
    <id>http://example.com/2021/10/19/2021-10-19-sessionStorage-%E5%92%8C-localStorage/</id>
    <published>2021-10-19T00:42:28.000Z</published>
    <updated>2021-10-19T01:05:37.096Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本文主要围绕What、Why、How这三个方面谈谈sessionStorage 和 localStorage的联系与区别。</p><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>sessionStorage 和 localStorage 都是BOM提供给我们在浏览器上进行本地存储数据的API，利用它我们可以实现在本地浏览器存储一些数据。这两个方法都是隶属于 Window这个顶级BOM下的，在需要的时候我们直接调用即可。</p><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>在某些场合下我们希望能够在用户本地的浏览器上存储一些数据以提高用户体验，所以本地存储技术就应运而生了。典型的应用场景就是我们在登录网站时希望下次登录网站能够记住我们的账号，以免再重新输入。这种时候就可以使用localStorage进行一个本地存储用户名，在用户加载完页面的时候就检测用户浏览器上有无存储相应账号数据，若有则自动填入。</p><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>在使用方式上sessionStorage和localStorage是类似的</p><h3 id="window-sessionStorage"><a href="#window-sessionStorage" class="headerlink" title="window.sessionStorage"></a>window.sessionStorage</h3><p>存储数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.setItem(key, value)</span><br></pre></td></tr></table></figure><p>获取数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.getItem(key)</span><br></pre></td></tr></table></figure><p>删除数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.removeItem(key)</span><br></pre></td></tr></table></figure><p>清空数据：(所有都清除掉)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.clear()</span><br></pre></td></tr></table></figure><h3 id="window-localStorage"><a href="#window-localStorage" class="headerlink" title="window.localStorage"></a>window.localStorage</h3><p>存储数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">localStorage</span>.setItem(key, value)</span><br></pre></td></tr></table></figure><p>获取数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">localStorage</span>.getItem(key)</span><br></pre></td></tr></table></figure><p>删除数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">localStorage</span>.removeItem(key)</span><br></pre></td></tr></table></figure><p>清空数据：(所有都清除掉)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">localStorage</span>.clear()</span><br></pre></td></tr></table></figure><h2 id="sessionStorage-和-localStorage的特点"><a href="#sessionStorage-和-localStorage的特点" class="headerlink" title="sessionStorage 和 localStorage的特点"></a>sessionStorage 和 localStorage的特点</h2><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p>1.存储容量约为5MB</p><p>2.同一个页面下可以共享数据</p><p>3.生命周期到页面关闭。当页面关闭后存储在浏览器上数据就会被清除，不会保留下来下次打开页面就没有数据了</p><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p>1.存储容量约为20MB</p><p>2.可以跨页面共享数据</p><p>3.生命周期为永久，仅当我们手动删除时才会清除数据，否则下次打开页面或者浏览器数据依然存在</p><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p>1.数据都存储在用户的浏览器中</p><p>2.数据都以键值对的形式存储</p><p>3.仅能存取字符串，可以将对象JSON.stringify() 编码后存储</p><p>4.读取方便，刷新页面也不会丢失数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="BOM" scheme="http://example.com/tags/BOM/"/>
    
  </entry>
  
  <entry>
    <title>事件对象</title>
    <link href="http://example.com/2021/10/13/2021-10-13-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/"/>
    <id>http://example.com/2021/10/13/2021-10-13-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-10-13T09:53:03.000Z</published>
    <updated>2021-10-14T01:00:34.791Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是事件对象"><a href="#什么是事件对象" class="headerlink" title="什么是事件对象"></a>什么是事件对象</h2><p>在浏览器中我们通常都是通过事件触发来实现网页与用户的交互效果的，在这个过程中js会产生一个事件对象。例如我们用常规方法给按钮绑定一个点击事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;btn&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    btn.addEventListiner(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"> e </span>)</span>&#123; <span class="comment">//这里我们给匿名函数的形参 e 就可以接收到 click 产生的事件对象</span></span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&#x27;哈喽&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="事件对象可以干什么"><a href="#事件对象可以干什么" class="headerlink" title="事件对象可以干什么"></a>事件对象可以干什么</h2><p>在返回的事件对象中包含了很多属性与方法，这些属性可以让我们准确的获取到用户目前的状态，例如用户按下了什么键、鼠标移动坐标、鼠标点击等等。然后我们可以根据用户的状态去设计我们的交互。我们可以打印一下这个对象看看里面都有什么</p><p><img src="https://i.loli.net/2021/10/14/91XMzcK2inRrb4k.png" alt="部分事件对象的内容"></p><h2 id="事件触发的三个阶段"><a href="#事件触发的三个阶段" class="headerlink" title="事件触发的三个阶段"></a>事件触发的三个阶段</h2><p>一个事件从产生到被触发可以分为三个阶段：捕获阶段、停留阶段、冒泡阶段。在捕获阶段，浏览器查找触发的事件顺序是从顶级DOM依次查找，直到找到源头。如果查找过程中有DOM元素绑定了和事件源头一样的事件，则会被触发。举个例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;father&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;son&#x27;</span>&gt;</span>Asuhe<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> father = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.father&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    father.addEventListiner(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&#x27;我是你爸爸&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,<span class="literal">true</span>) <span class="comment">//开启捕获阶段</span></span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> son = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.son&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    son.addEventListiner(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&#x27;我是你儿子&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种情况下会先弹出父亲的话，然后在弹出儿子的话。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Web API" scheme="http://example.com/tags/Web-API/"/>
    
  </entry>
  
</feed>
