<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Asuhe</title>
  
  <subtitle>Born in poverty, died of numbness</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-10-28T02:05:54.426Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Asuhe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>http协议</title>
    <link href="http://example.com/2021/10/28/2021-10-28-http%E5%8D%8F%E8%AE%AE/"/>
    <id>http://example.com/2021/10/28/2021-10-28-http%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-10-28T00:43:22.000Z</published>
    <updated>2021-10-28T02:05:54.426Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是HTTP协议"><a href="#什么是HTTP协议" class="headerlink" title="什么是HTTP协议"></a>什么是HTTP协议</h2><p><strong>HTTP 协议</strong>即超文本传送协议 (HyperText Transfer Protocol) ，使用经典的<a href="https://en.wikipedia.org/wiki/Client%E2%80%93server_model">C/S模式</a>交互，它规定了客户端与服务器之间进行网页内容传输时，所必须遵守的传输格式。</p><p>在<a href="https://en.wikipedia.org/wiki/Internet_protocol_suite">TCP/IP网络模型</a>中，它位于<a href="https://en.wikipedia.org/wiki/Application_layer">应用层</a>采用传输层采用的是<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a>协议，端口号默认是<strong>80</strong>。虽然它采用的是TCP协议，但它实际上是一个<strong>无连接</strong>协议，这里的无连接是指服务器每次处理完客户端请求并收到客户端的响应回答后就会马上断开连接，并不会一直维持会话连接状态。同时它是一个<a href="https://en.wikipedia.org/wiki/Stateless_protocol">无状态协议</a>，即它并不会记录前后报文之间的关系。每一个请求报文在它看来都是独立的，没有上下文联系。这就给我们实际运用的时候带来了一些麻烦，例如在购物网站购买商品时，我们商品加入自己账号的购物车这就需要上下文联系。为了解决这个问题于是就有了<a href="https://en.wikipedia.org/wiki/HTTP_cookie">cookie-session</a>机制来帮助我们建立上下文联系。</p><h2 id="为什么要HTTP协议"><a href="#为什么要HTTP协议" class="headerlink" title="为什么要HTTP协议"></a>为什么要HTTP协议</h2><p>它是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的，例如现在的电子邮箱流行使用http协议去传输内容。</p><h2 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h2><p>http的报文可以大致分为请求报文和响应报文两种，请求报文即为客户端向服务器发送的请求消息，而响应报文则是服务器根据客户端的请求响应回去的消息。</p><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p>HTTP 请求消息由请求行（request line）、请求头部（ header ） 、空行 和 请求体 4 个部分组成。</p><p><img src="https://i.loli.net/2021/10/28/MtukAIinQ2JCNvs.png" alt="请求报文基本格式"></p><h3 id="常见的请求头部"><a href="#常见的请求头部" class="headerlink" title="常见的请求头部"></a>常见的请求头部</h3><table><thead><tr><th><strong>头部字段</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Host</td><td>要请求的服务器域名</td></tr><tr><td>Connection</td><td>客户端与服务器的连接方式(close  或  keepalive)</td></tr><tr><td>Content-Length</td><td>用来描述请求体的大小</td></tr><tr><td><strong>Accept</strong></td><td>客户端可识别的响应内容类型列表</td></tr><tr><td><strong>User-Agent</strong></td><td>产生请求的浏览器类型</td></tr><tr><td><strong>Content-Type</strong></td><td>客户端告诉服务器实际发送的数据类型</td></tr><tr><td>Accept-Encoding</td><td>客户端可接收的内容压缩编码形式</td></tr><tr><td><strong>Accept-Language</strong></td><td>用户期望获得的自然语言的优先顺序</td></tr></tbody></table><p>我们可以在浏览器里具体抓一个请求报头来看看</p><p><img src="https://i.loli.net/2021/10/28/u236vDXOYrzJGZA.png" alt="GET请求头"></p><p><img src="https://i.loli.net/2021/10/28/dF9bL3phfgrlaRK.png" alt="POST请求头"></p><p>从上面请求头的对比中里我们可以得知一个结论。GET请求和POST请求的一个重要区别就是<strong>GET请求方式中，我们要发送的数据会携带在请求报头中，实际的请求体是为空的。而在POST请求方式中，我们要提交的数据会携带在请求体中，并不会夹带在请求头中。</strong></p><h3 id="响应报头"><a href="#响应报头" class="headerlink" title="响应报头"></a>响应报头</h3><p>HTTP响应消息由状态行、响应头部、空行 和 响应体 4 个部分组成，如下图所示：</p><p><img src="https://i.loli.net/2021/10/28/tq61CS3xo5hWckb.png" alt="响应报文基本格式"></p><p>实际浏览器中的响应报头</p><p><img src="https://i.loli.net/2021/10/28/rk643O5sEK9ljdp.png" alt="GET响应报头"></p><p><img src="https://i.loli.net/2021/10/28/2MERcynikH4O8T3.png" alt="POST响应报头"></p><h2 id="http请求方法"><a href="#http请求方法" class="headerlink" title="http请求方法"></a>http请求方法</h2><table><thead><tr><th><strong>序号</strong></th><th align="center"><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>1</td><td align="center"><strong>GET</strong></td><td>(查询)发送请求来获得服务器上的资源，请求体中不会包含请求数据，请求数据放在协议头中。</td></tr><tr><td>2</td><td align="center"><strong>POST</strong></td><td>(新增)向服务器提交资源（例如提交表单或上传文件）。数据被包含在请求体中提交给服务器。</td></tr><tr><td>3</td><td align="center"><strong>PUT</strong></td><td>(修改)向服务器提交资源，并使用提交的新资源，替换掉服务器对应的旧资源。</td></tr><tr><td>4</td><td align="center"><strong>DELETE</strong></td><td>(删除)请求服务器删除指定的资源。</td></tr><tr><td>5</td><td align="center">HEAD</td><td>HEAD  方法请求一个与 GET 请求的响应相同的响应，但没有响应体。</td></tr><tr><td>6</td><td align="center">OPTIONS</td><td>获取http服务器支持的http请求方法，允许客户端查看服务器的性能，比如ajax跨域时的预检等。</td></tr><tr><td>7</td><td align="center">CONNECT</td><td>建立一个到由目标资源标识的服务器的隧道。</td></tr><tr><td>8</td><td align="center">TRACE</td><td>沿着到目标资源的路径执行一个消息环回测试，主要用于测试或诊断。</td></tr><tr><td>9</td><td align="center">PATCH</td><td>是对  PUT 方法的补充，用来对已知资源进行局部更新 。</td></tr></tbody></table><h2 id="http响应状态码"><a href="#http响应状态码" class="headerlink" title="http响应状态码"></a>http响应状态码</h2><p>http的状态码可以分为5大类型</p><table><thead><tr><th align="center">分类</th><th align="left"><strong>分类描述</strong></th></tr></thead><tbody><tr><td align="center">1**</td><td align="left">信息，服务器收到请求，需要请求者继续执行操作（实际开发中很少遇到  1**  类型的状态码）</td></tr><tr><td align="center">2**</td><td align="left">成功，操作被成功接收并处理</td></tr><tr><td align="center">3**</td><td align="left">重定向，需要进一步的操作以完成请求</td></tr><tr><td align="center">4**</td><td align="left">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td align="center">5**</td><td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><h3 id="成功相关的响应状态码"><a href="#成功相关的响应状态码" class="headerlink" title="成功相关的响应状态码"></a>成功相关的响应状态码</h3><p>2** 范围的状态码，表示服务器已成功接收到请求并进行处理。常见的 2** 类型的状态码如下：</p><table><thead><tr><th align="center"><strong>状态码</strong></th><th align="center"><strong>状态码英文名称</strong></th><th><strong>中文描述</strong></th></tr></thead><tbody><tr><td align="center">200</td><td align="center">OK</td><td>请求成功。一般用于  GET 与 POST  请求</td></tr><tr><td align="center">201</td><td align="center">Created</td><td>已创建。成功请求并创建了新的资源，通常用于  POST 或 PUT  请求</td></tr></tbody></table><h3 id="重定向相关的响应状态码"><a href="#重定向相关的响应状态码" class="headerlink" title="重定向相关的响应状态码"></a>重定向相关的响应状态码</h3><p>3** 范围的状态码，表示表示服务器要求客户端重定向，需要客户端进一步的操作以完成资源的请求。常见的 3** 类型的状态码如下：</p><table><thead><tr><th align="center">状态码</th><th align="center"><strong>状态码英文名称</strong></th><th><strong>中文描述</strong></th></tr></thead><tbody><tr><td align="center">301</td><td align="center">Moved  Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td align="center">302</td><td align="center">Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td align="center">304</td><td align="center">Not  Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源（响应消息中不包含响应体）。客户端通常会缓存访问过的资源。</td></tr></tbody></table><h3 id="客户端错误相关的响应状态码"><a href="#客户端错误相关的响应状态码" class="headerlink" title="客户端错误相关的响应状态码"></a>客户端错误相关的响应状态码</h3><p>4** 范围的状态码，表示客户端的请求有非法内容，从而导致这次请求失败。常见的 4** 类型的状态码如下：</p><table><thead><tr><th align="center"><strong>状态码</strong></th><th align="center"><strong>状态码英文名称</strong></th><th><strong>中文描述</strong></th></tr></thead><tbody><tr><td align="center">400</td><td align="center">Bad  Request</td><td>语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。</td></tr><tr><td align="center">401</td><td align="center">Unauthorized</td><td>当前请求需要用户验证。</td></tr><tr><td align="center">403</td><td align="center">Forbidden</td><td>服务器已经理解请求，但是拒绝执行它。</td></tr><tr><td align="center">404</td><td align="center">Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。</td></tr><tr><td align="center">408</td><td align="center">Request  Timeout</td><td>请求超时。服务器等待客户端发送的请求时间过长，超时。</td></tr></tbody></table><h3 id="服务端错误相关的响应状态码"><a href="#服务端错误相关的响应状态码" class="headerlink" title="服务端错误相关的响应状态码"></a>服务端错误相关的响应状态码</h3><p>5** 范围的状态码，表示服务器未能正常处理客户端的请求而出现意外错误。前端甩锅码，只要出现5开头的响应码全部甩锅后端哈哈。常见的 5** 类型的状态码如下：</p><table><thead><tr><th align="center"><strong>状态码</strong></th><th align="center"><strong>状态码英文名称</strong></th><th><strong>中文描述</strong></th></tr></thead><tbody><tr><td align="center">500</td><td align="center">Internal  Server Error</td><td>服务器内部错误，无法完成请求。</td></tr><tr><td align="center">501</td><td align="center">Not  Implemented</td><td>服务器不支持该请求方法，无法完成请求。只有  GET 和 HEAD  请求方法是要求每个服务器必须支持的，其它请求方法在不支持的服务器上会返回501</td></tr><tr><td align="center">503</td><td align="center">Service  Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="CN" scheme="http://example.com/tags/CN/"/>
    
  </entry>
  
  <entry>
    <title>模板引擎的使用</title>
    <link href="http://example.com/2021/10/26/2021-10-26-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2021/10/26/2021-10-26-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2021-10-26T09:40:51.000Z</published>
    <updated>2021-10-27T00:41:16.535Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是模板引擎"><a href="#什么是模板引擎" class="headerlink" title="什么是模板引擎"></a>什么是模板引擎</h2><p>在我们要渲染相同的UI结构，如新闻列表、博客的文章列表时，用传统的方法我们需要大量拼接字符串。这使得代码运行效率低，页面加载也慢。不仅如此，当我们需要修改结构时，也需要在字符串中修改这使得代码维护起来十分麻烦而且灵活性非常差。</p><p>为了解决传统的方法的缺点，于是我们发明了模板引擎技术。使用模板引擎我们可以快速渲染出UI，同时由于清晰的模板结构我们要修改代码时也十分容易。</p><h2 id="art-template"><a href="#art-template" class="headerlink" title="art - template"></a>art - template</h2><p>art-template 是一个简约、超快的模板引擎，使用这个模板引擎我们可以很方便地生成一些UI结构。</p><h2 id="模板使用步骤"><a href="#模板使用步骤" class="headerlink" title="模板使用步骤"></a>模板使用步骤</h2><p>①导入 art-template</p><p>②定义数据</p><p>③定义模板</p><p>④调用 template 函数</p><p>⑤渲染HTML结构</p><h2 id="art-template基础语法"><a href="#art-template基础语法" class="headerlink" title="art-template基础语法"></a>art-template基础语法</h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>在标准语法中，可以进行变量的输出、对象属性的输出、三元表达式输出、逻辑或输出、加减乘除等表达式输出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;value&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;obj.key&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;obj[<span class="string">&#x27;key&#x27;</span>]&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;a ? b : c&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;a || b&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;a + b&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="原文输出"><a href="#原文输出" class="headerlink" title="原文输出"></a>原文输出</h3><p>如果要输出的 value 值中，包含了 HTML 标签结构，则需要使用<strong>原文输出</strong>语法，才能保证 HTML 标签被正常渲染。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;@ value &#125;&#125;  //类似innerHTML,会将value的文本内容当作HTML渲染</span><br></pre></td></tr></table></figure><h3 id="条件输出"><a href="#条件输出" class="headerlink" title="条件输出"></a>条件输出</h3><p>如果要实现条件输出，则可以在双花括号中使用 <strong>if</strong> … <strong>else if</strong> … <strong>/if</strong> 的方式，进行按需输出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;<span class="keyword">if</span> value&#125;&#125; 按需输出的内容 &#123;&#123;/<span class="keyword">if</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;<span class="keyword">if</span> v1&#125;&#125; 按需输出的内容 &#123;&#123;<span class="keyword">else</span> <span class="keyword">if</span> v2&#125;&#125; 按需输出的内容 &#123;&#123;/<span class="keyword">if</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>如果要实现循环输出，则可以在标准语法内，通过 each 语法循环数组，当前循环的索引使用 <strong>$index</strong> 进行访问，当前的循环项使用 <strong>$value</strong> 进行访问。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;each arr&#125;&#125;</span><br><span class="line">    &#123;&#123;$index&#125;&#125; &#123;&#123;$value&#125;&#125;</span><br><span class="line">&#123;&#123;/each&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>过滤器语法类似<strong>管道操作符</strong>，它的上一个输出作为下一个输入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;value | 处理函数名称&#125;&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//js文件中定义好处理函数的操作</span></span><br><span class="line">template.defaults.imports.处理函数名称 = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123; <span class="comment">//传入值为模板的value</span></span><br><span class="line">    <span class="comment">/*Code*/</span></span><br><span class="line">    <span class="keyword">return</span> res <span class="comment">//返回处理结果</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>注册时间：&#123;&#123;regTime | dateFormat&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template.defaults.imports.dateFormat = <span class="function"><span class="keyword">function</span>(<span class="params">date</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> y = date.getFullYear()</span><br><span class="line">   <span class="keyword">var</span> m = date.getMonth() + <span class="number">1</span></span><br><span class="line">   <span class="keyword">var</span> d = date.getDate()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> y + <span class="string">&#x27;-&#x27;</span> + m + <span class="string">&#x27;-&#x27;</span> + d <span class="comment">// 注意，过滤器最后一定要 return 一个值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="tips" scheme="http://example.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的继承</title>
    <link href="http://example.com/2021/10/23/2021-10-23-JavaScript%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
    <id>http://example.com/2021/10/23/2021-10-23-JavaScript%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/</id>
    <published>2021-10-23T00:33:54.000Z</published>
    <updated>2021-10-27T00:27:40.038Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="ES6以前"><a href="#ES6以前" class="headerlink" title="ES6以前"></a>ES6以前</h2><p>在es6以前 js 并没有专门的关键字可以实现继承特性，但是那时候我们又需要使用继承。于是就产生了一些方法可以实现继承的效果</p><h3 id="call调用实现继承父属性"><a href="#call调用实现继承父属性" class="headerlink" title="call调用实现继承父属性"></a>call调用实现继承父属性</h3><p>我们都知道<code>call</code>可以改变函数内<code>this</code>的指向，利用这个特性我们可以在子构造函数里面调用父构造函数，并利用<code>call</code>让父构造函数内的<code>this</code>指向子构造函数。这样就完成了继承操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = uname;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line">    Father.call(<span class="built_in">this</span>,uname,age); <span class="comment">//调用父构造函数，利用call传入自身的this实现继承</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用原型对象实现继承父方法"><a href="#利用原型对象实现继承父方法" class="headerlink" title="利用原型对象实现继承父方法"></a>利用原型对象实现继承父方法</h3><p>我们还可以通过让子构造函数的<code>prototype</code>指向一个父构造函数的实例的形式实现继承，不过需要注意的是在赋值完成后我们需要让<code>constructor</code>属性重新指回子构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = uname;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line">Father.prototype.say = <span class="function">()=&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;hello!&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = uname;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Son.prototype = Father.prototype 若我们直接赋值，会导致Son的原型对象和Father的原型对象是同一个，在Son中修改原型对象同时也会修改Father的。所以这样赋值是错误的</span></span><br><span class="line"></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();  <span class="comment">//通过一个Father实例化对象可以间接访问到Father的prototype</span></span><br><span class="line">Son.prototype.constructor = Son; <span class="comment">//让constructor指回Son构造函数，不然其会指向Father构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son(<span class="string">&#x27;Asuka&#x27;</span>,<span class="number">16</span>);</span><br><span class="line">son.say(); <span class="comment">//hello！</span></span><br></pre></td></tr></table></figure><h2 id="ES6以后"><a href="#ES6以后" class="headerlink" title="ES6以后"></a>ES6以后</h2><p>es6中引入了<code>class</code>关键字同时也引入了<code>extends</code>关键字，利用这些关键字我们可以很轻易的实现继承。同时若我们想要调用父类的方法和属性只需要使用<code>super</code>关键字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = uname;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;hello!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">uname,age,sex</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(uname,age); <span class="comment">//直接使用，调用父类constructor.一定要在this之前，不然SyntaxError</span></span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>.say();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;hi!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son(<span class="string">&#x27;Asuhe&#x27;</span>,<span class="number">16</span>,<span class="string">&#x27;male&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(son); <span class="comment">//Son &#123; name: &#x27;Asuhe&#x27;, age: 16, sex: &#x27;male&#x27; &#125;</span></span><br><span class="line">son.say();  <span class="comment">// hello! hi!</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>ES6新增特性</title>
    <link href="http://example.com/2021/10/22/2021-10-22-ES6%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2021/10/22/2021-10-22-ES6%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7/</id>
    <published>2021-10-22T00:14:57.000Z</published>
    <updated>2021-10-27T00:29:09.501Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="let关键字"><a href="#let关键字" class="headerlink" title="let关键字"></a>let关键字</h2><h3 id="作用域绑定在最近的-…-块中"><a href="#作用域绑定在最近的-…-块中" class="headerlink" title="作用域绑定在最近的{…}块中"></a>作用域绑定在最近的{…}块中</h3><p><code>let</code>在使用时会绑定离它最近的{…}作为作用域。原本在ES6以前是没有块级作用域的概念，在ES6引入了<code>let、const</code>关键字之后就有了块级作用域。<strong>实际上这个块级作用域并不是我们平常理解的块级作用域，仅当变量是由<code>let、const</code>关键字声明时，这些关键字声明的变量其作用域会绑定在这个块上，若是使用<code>var</code>关键字声明，其变量依然会成为全局变量。</strong></p><p>使用这个特性我们可以很好的解决 for 循环全局变量污染的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><h3 id="无变量提升"><a href="#无变量提升" class="headerlink" title="无变量提升"></a>无变量提升</h3><p><code>let</code>关键字在使用的时候，不像<code>var</code>那样存在变量提升的情况。它必须先声明再使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//ReferenceError</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"><span class="comment">//上述代码等价于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a;  <span class="comment">//var变量提升至所在作用域顶部</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//ReferenceError</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>所谓暂时性死区就是，你在块级作用域使用<code>let</code>声明了一个变量<code>i</code>，同时你在外部作用域也声明的一个同名变量<code>i</code>。若你在<code>let</code>声明这个变量前使用它，它并不会像以前的那样去上级作用域寻找这个变量，仅会在该作用域内寻找变量，又因为变量使用<code>let</code>声明，并且声明在其使用之后，就会抛出ReferenceError。<strong>因为使用<code>let</code>在作用域内声明了同名变量，它会屏蔽外界变量，这个块级区域就被称为暂时性死区</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//if&#123;&#125;内形成暂时性死区</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">-------------</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//不是同名变量，没有暂时性死区</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 20</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><h3 id="声明时必须赋值"><a href="#声明时必须赋值" class="headerlink" title="声明时必须赋值"></a>声明时必须赋值</h3><p><code>const</code>关键字的特性和<code>let</code>相同，<code>let</code>有的特性<code>const</code>都具有。不同点是<strong>它在声明的同时必须赋予一个值</strong>，否则抛出SyntaxError。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a;  <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure><h3 id="赋值后不可改变"><a href="#赋值后不可改变" class="headerlink" title="赋值后不可改变"></a>赋值后不可改变</h3><p>这里<code>const</code>关键字声明的变量能否更改还需要看具体的情况。</p><p>若<code>const</code>声明的是一个基本数据类型，则不能更改其值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">20</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>但是如果<code>const</code>声明的是一个复杂数据类型，则可以更改复杂数据类型变量内部的值，不可更改该复杂数据类型变量本身</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">100</span>; </span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// [1,100,3]</span></span><br><span class="line">b = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]; <span class="comment">//TypeError</span></span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>最初使用箭头函数的目的就是为了简化函数声明的操作，但它的作用不仅如此。我们都知道<code>this</code>指针的指向在不同地方其指向不同，例如在构造函数中其指向就是它的实例化对象，在<code>class</code>中的<code>constructor</code>中也是同样的指向自身的实例化对象，而在普通函数中其指向的是函数的调用者。</p><h3 id="箭头函数中的this是根据上下文环境确定的"><a href="#箭头函数中的this是根据上下文环境确定的" class="headerlink" title="箭头函数中的this是根据上下文环境确定的"></a>箭头函数中的<code>this</code>是根据上下文环境确定的</h3><p>箭头函数<code>this</code>指向的是<strong>被声明的作用域里面</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.querSelector(<span class="string">&#x27;.btn&#x27;</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line"><span class="comment">//在定时器的回调函数中使用箭头函数则其this会根据上下文指向btn对象，而不是指向window</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// btn</span></span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多种简写形式"><a href="#多种简写形式" class="headerlink" title="多种简写形式"></a>多种简写形式</h3><p>当形参只有一个且函数体内仅有一句返回值时</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="params">n</span> =&gt;</span> n*<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价一</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n*<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价二</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n*<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">a,b</span>) =&gt;</span> a+b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价一</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价二</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><h3 id="数组的解构"><a href="#数组的解构" class="headerlink" title="数组的解构"></a>数组的解构</h3><p>在es6中我们可以使用新的方式来命名多个变量，这种新的声明赋值方式就叫解构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统命名多个变量并赋值的方式</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>,b = <span class="number">20</span>,c = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//采用数组解构的方式</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>];</span><br><span class="line"><span class="keyword">let</span> [a,b,c] = arr;  <span class="comment">//a = 10,b = 20,c = 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当变量数量大于数组长度</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> [a,b,c,d] = arr; <span class="comment">//a = 1,b = 2, c = 3,d = undefined //多余的变量为未定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当变量数量少于数组长度</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> [a,b] = arr; <span class="comment">//a = 1,b = 2  //多余的直接被截断</span></span><br><span class="line"></span><br><span class="line">--------------</span><br><span class="line"><span class="comment">//对象解构</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;Asuhe&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>:myname,<span class="attr">age</span>:myage,<span class="attr">sex</span>:mysex&#125; = obj; <span class="comment">//myname = &#x27;Asuhe&#x27;,myage = 18,mysex = &#x27;男&#x27; //按匹配相同名称，即使乱序也会匹配上</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">let</span> myname = <span class="string">&#x27;Asuhe&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> myage = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">let</span> sex = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line"><span class="keyword">let</span> &#123;name,age,sex&#125; = obj;</span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Asuhe&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">let</span> sex = <span class="string">&#x27;男&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><p>在es6中新扩展了一种方法可以使函数的形参接收不定数量的实参，那就是使用<strong>剩余参数</strong>。我们知道在以前js同样支持函数形参和实参数量不匹配，即使定义函数时形参列表为空我们依然可以使用<code>arguments</code>对象获取到实参。<strong>但在es6新增的箭头函数中并不支持<code>arguments</code>，所以es6扩展了<code>...args</code>剩余参数来解决这个问题。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统获取所有形参</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">//2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">2</span>]); <span class="comment">//3</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用剩余参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,...args</span>)</span>&#123; <span class="comment">//剩余参数必须放在最后一个形参的位置</span></span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">console</span>.log(args); <span class="comment">//[2,3,4,5] //以数组的形式存储值</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>原型与原型链</title>
    <link href="http://example.com/2021/10/20/2021-10-20-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://example.com/2021/10/20/2021-10-20-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</id>
    <published>2021-10-20T00:04:04.000Z</published>
    <updated>2021-10-27T00:28:57.140Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是原型"><a href="#什么是原型" class="headerlink" title="什么是原型"></a>什么是原型</h2><p>在搞明白什么是原型之前我们首先要明白我们为什么要原型，毕竟语言的设计者不会无缘无故搞出一个完全没有用的东西，它肯定是为了解决某个问题而诞生的。那么原型它解决了什么问题呢？</p><p>我们都知道在es6之前，js是没有关键字<code>class</code>创建类的。那时候我们要使用类就用构造函数这种形式来实现它。在C++这种原生支持类的语言中，同一个类的多个实例里的方法只有一份，也就是说不管我们实例化了多少个对象，在计算机的内存中这个类的方法在内存中只有一份。只有每个实例的属性才会在内存中产生多个副本。例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">getName</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.name; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.age; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    foo a = <span class="keyword">new</span> <span class="built_in">foo</span>();</span><br><span class="line">    foo b = <span class="keyword">new</span> <span class="built_in">foo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在计算机的内存中，a、b这两个实例化对象的内存分布仅有private里的属性才有独立的内存副本，而public里的方法a、b是共享同一片内存的，这样设计就节约了内存空间。</p><p><img src="https://i.loli.net/2021/10/20/2PxV6KqCkLseEaQ.png" alt="C++的类方法只占一份内存"></p><p>而在es6以前没有<code>class</code>时候，我们通过构造函数实例化的类就会出现上图的第一种情况。每个实例的方法都有独有的内存空间。为了解决这个问题，所以就出现了原型。构造函数通过原型分配的函数是所有对象所共享的，也就实现了第二种内存分布。</p><h2 id="如何使用原型"><a href="#如何使用原型" class="headerlink" title="如何使用原型"></a>如何使用原型</h2><p>JavaScript 规定，每一个构造函数都有一个prototype 属性，指向prototype对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。</p><p>我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = uname;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="comment">//定义类共享的方法时我们将方法定义在原型上，而不是构造函数内部</span></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;哈喽&#x27;</span>); &#125;;  <span class="comment">//这样定义方法，多个实例对象就可以共享</span></span><br><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> Person(<span class="string">&#x27;Asuhe&#x27;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> woman = <span class="keyword">new</span> Person(<span class="string">&#x27;Asuka&#x27;</span>,<span class="number">16</span>);</span><br><span class="line">man.say();  <span class="comment">//输出 哈喽</span></span><br><span class="line">woman.say(); <span class="comment">//输出 哈喽</span></span><br></pre></td></tr></table></figure><h2 id="对象原型"><a href="#对象原型" class="headerlink" title="对象原型"></a>对象原型</h2><p>在构造函数拥有一个原型对象叫prototype，<strong>这个原型对象由构造函数内的prototype属性指明</strong>，每个构造函数都有一个这样的原型对象。经过上述学习我们知道共享的方法是定义在构造函数的原型prototype中的，但是我们的实例化对象却能使用定义在构造函数里prototype上的方法。这是如何实现的呢？</p><p>实现这个机制的就是我们即将要讲的<strong>对象原型</strong>。在每个实例化的对象中，都会包含一个<strong>属性</strong><code>__proto__</code>。这个<code>__protto__</code>属性就是令我们的实例化对象能够调用构造函数里<code>prototype</code>对象里定义的方法的原因，我们同时也称这个属性为对象原型。<code>__proto__</code>属性指向的是我们的构造函数的<code>prototype</code>原型对象，如上面的<code>man</code>当我们使用实例化的对象调用<code>prototype</code>里的方法时，我们的调用链是：<code>man</code> -&gt; <code>__proto__</code>  -&gt; <code>prototype</code> -&gt; <code>say()</code>。</p><p>经过这一层调用，我们的构造函数与实例化对象之间就形成了如下三角关系</p><p><img src="https://i.loli.net/2021/10/20/We5yfcVqx2bsZGk.png" alt="image-20211020094410424"></p><h2 id="constructor构造函数"><a href="#constructor构造函数" class="headerlink" title="constructor构造函数"></a>constructor构造函数</h2><p>不管我们构造函数里的原型对象<code>Prototype</code>，还是我们实例化的对象里的对象原型<code>__proto__</code>，它们都包含了一个<strong>属性</strong><code>constructor</code>。<code>constructor</code>属性的作用就是指明我们引用的构造函数是哪个。例如我们的<code>man、woman</code>它们都是通过构造函数<code>Person</code>创建出来的，所以它们的对象原型里的<code>construtctor</code>属性指向的就应该是<code>Person</code>这个构造函数。按这个指向顺序我们属性指向的关系应该是如下</p><p><img src="https://i.loli.net/2021/10/20/TKE9jX5aDgdJfsW.png" alt="直觉上对象原型里constructor的指向"></p><p>但事实情况是不是这样的呢？实际上对象原型里的constructor指向是通过构造函数里的<code>prototype.constructor</code>间接指回构造函数的。</p><p><img src="https://i.loli.net/2021/10/20/2CUPlsKLuvbJtGp.png" alt="20211020100310.png"></p><p>一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor  就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line"><span class="attr">say</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;哈喽&#x27;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果我们采用上述赋值的形式给原型对象添加新的方法，这意味着原本的那个原型对象被我们覆盖了。此时constructor指向的并不是Person</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所以我们需要手动指定constructor的指向，让它重新指向Person</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="attr">constructor</span>:Person,</span><br><span class="line"><span class="attr">say</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;哈喽&#x27;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>当我们继续打印出<code>prototype</code>这个对象的时候，我们可以看到<code>prototype</code>里面和已经实例化的对象一样里面也有一个<code>__proto__</code>对象原型。那么这个<code>__proto__</code>又指向哪里呢。实际上这个<code>__proto__</code>指向的是js内置的空对象<code>Object</code>的<code>prototype</code>。这个<code>Objerct</code>构造函数的对象原型里的<code>__proto__</code>还会继续往下指向最后的<code>null</code>。所以当我们查找方法时就会延着这条路径链式查找下去返回最先查找到的方法，若最后没找到则返回null。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = uname;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Person.prototype.__proto__指向的是Object的prototype，Object.prototype.__proto__指向null</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/20/Q4hrRYLdgxqDAGP.png" alt="输出结果"></p><p><img src="https://i.loli.net/2021/10/20/D1tKv4GVaNwAUu8.png" alt="实例对象查找共享方法的链式结构"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = uname;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;哈喽&#x27;</span>); &#125;;  </span><br><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> Person(<span class="string">&#x27;Asuhe&#x27;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> woman = <span class="keyword">new</span> Person(<span class="string">&#x27;Asuka&#x27;</span>,<span class="number">16</span>);</span><br><span class="line">man.say();  <span class="comment">//输出 哈喽  //在Person.prototype中找到了say方法，停止查找</span></span><br><span class="line">woman.sleep(); <span class="comment">//输出 TypeError //Person.prototype -&gt; Object.prototype中均未找到sleep方法，返回null</span></span><br></pre></td></tr></table></figure><p>像上面这种<code>__proto__</code>层层查找构成的链式结构就是我们常说的原型链。</p><p>还有一点需要我们注意的是，不管是构造函数里的<code>this</code> 还是构造函数的prototype里的<code>this</code>都是指向我们实例化出来的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">uname,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = uname;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ptr = <span class="literal">null</span>;</span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;哈喽&#x27;</span>);</span><br><span class="line">    ptr = <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> Person(<span class="string">&#x27;Asuhe&#x27;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(man === ptr) <span class="comment">//输出 true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>sessionStorage 和 localStorage</title>
    <link href="http://example.com/2021/10/19/2021-10-19-sessionStorage-%E5%92%8C-localStorage/"/>
    <id>http://example.com/2021/10/19/2021-10-19-sessionStorage-%E5%92%8C-localStorage/</id>
    <published>2021-10-19T00:42:28.000Z</published>
    <updated>2021-10-19T01:05:37.096Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本文主要围绕What、Why、How这三个方面谈谈sessionStorage 和 localStorage的联系与区别。</p><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>sessionStorage 和 localStorage 都是BOM提供给我们在浏览器上进行本地存储数据的API，利用它我们可以实现在本地浏览器存储一些数据。这两个方法都是隶属于 Window这个顶级BOM下的，在需要的时候我们直接调用即可。</p><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>在某些场合下我们希望能够在用户本地的浏览器上存储一些数据以提高用户体验，所以本地存储技术就应运而生了。典型的应用场景就是我们在登录网站时希望下次登录网站能够记住我们的账号，以免再重新输入。这种时候就可以使用localStorage进行一个本地存储用户名，在用户加载完页面的时候就检测用户浏览器上有无存储相应账号数据，若有则自动填入。</p><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>在使用方式上sessionStorage和localStorage是类似的</p><h3 id="window-sessionStorage"><a href="#window-sessionStorage" class="headerlink" title="window.sessionStorage"></a>window.sessionStorage</h3><p>存储数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.setItem(key, value)</span><br></pre></td></tr></table></figure><p>获取数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.getItem(key)</span><br></pre></td></tr></table></figure><p>删除数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.removeItem(key)</span><br></pre></td></tr></table></figure><p>清空数据：(所有都清除掉)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.clear()</span><br></pre></td></tr></table></figure><h3 id="window-localStorage"><a href="#window-localStorage" class="headerlink" title="window.localStorage"></a>window.localStorage</h3><p>存储数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">localStorage</span>.setItem(key, value)</span><br></pre></td></tr></table></figure><p>获取数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">localStorage</span>.getItem(key)</span><br></pre></td></tr></table></figure><p>删除数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">localStorage</span>.removeItem(key)</span><br></pre></td></tr></table></figure><p>清空数据：(所有都清除掉)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">localStorage</span>.clear()</span><br></pre></td></tr></table></figure><h2 id="sessionStorage-和-localStorage的特点"><a href="#sessionStorage-和-localStorage的特点" class="headerlink" title="sessionStorage 和 localStorage的特点"></a>sessionStorage 和 localStorage的特点</h2><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p>1.存储容量约为5MB</p><p>2.同一个页面下可以共享数据</p><p>3.生命周期到页面关闭。当页面关闭后存储在浏览器上数据就会被清除，不会保留下来下次打开页面就没有数据了</p><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p>1.存储容量约为20MB</p><p>2.可以跨页面共享数据</p><p>3.生命周期为永久，仅当我们手动删除时才会清除数据，否则下次打开页面或者浏览器数据依然存在</p><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p>1.数据都存储在用户的浏览器中</p><p>2.数据都以键值对的形式存储</p><p>3.仅能存取字符串，可以将对象JSON.stringify() 编码后存储</p><p>4.读取方便，刷新页面也不会丢失数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="BOM" scheme="http://example.com/tags/BOM/"/>
    
  </entry>
  
  <entry>
    <title>关于Javascript的作用域</title>
    <link href="http://example.com/2021/10/13/2021-10-13-%E5%85%B3%E4%BA%8EJavascript%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://example.com/2021/10/13/2021-10-13-%E5%85%B3%E4%BA%8EJavascript%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/</id>
    <published>2021-10-13T09:53:03.000Z</published>
    <updated>2021-10-27T00:28:38.784Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>js里若我们包装函数的声明，则该函数会被当做一个<strong>函数表达式</strong>，而不是一个函数声明。如何理解?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); </span><br><span class="line">&#125;)(); <span class="comment">//输出3</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 输出2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当我们继续想要调用foo</span></span><br><span class="line">foo(); <span class="comment">//ReferenceError</span></span><br><span class="line"></span><br><span class="line">---------</span><br><span class="line"><span class="comment">//foo函数的书写还有一个改进的形式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//输出3</span></span><br><span class="line">&#125;())  <span class="comment">//即将()调用也包含进外层的()中，书写形式变了但其功能含义与上面的写法是一致的</span></span><br></pre></td></tr></table></figure><p>上述例子中，foo函数的作用域仅限于<code>&#123;...&#125;</code>即第五行，foo函数不能再在后续代码被调用。这种情况就是被包装函数声明foo，被编译器当作一个函数表达式而不是一个标准的函数声明。</p><p><code>(function foo()&#123;...&#125;)</code>作为函数表达式意味着，foo只能在<code>&#123;...&#125;</code>所代表的位置中被访问，外部作用域无法访问。但是若是有一个变量去接收该函数表达式的返回值，则该函数依然可以被继续保留调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最常见的函数表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> n = (<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); </span><br><span class="line">&#125;);</span><br><span class="line">n();<span class="comment">//输出3</span></span><br></pre></td></tr></table></figure><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>在js中只有全局作用域和函数作用域这两个基本的单位，<strong>块级作用域在js中是不存在的</strong>。如何理解呢，请看如下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(i);  <span class="comment">//此时输出 10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">//输出 ?     并不是输出 ReferenceError 而是输出 10</span></span><br></pre></td></tr></table></figure><p>在C++或Java中，i 这个变量其作用域仅在 {…} 中，在 {…} 外调用变量 i 是无法通过编译的，会产生一个报错。而在 js 中，如果你用 <code>var</code>关键字声明的变量不在一个函数中，则其作用域会为上级外部作用域。这就导致了如果我们在后续代码中同样声明一样的变量，使用该变量时就会产生预料外的结果。</p><p>很多时候我们希望变量仅在块级作用域里生效，用完以后就被GC回收。例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)  <span class="comment">//在这个循环里我们通常希望 i 在for循环执行完之后就失效，这一我们就可以在后续代码中重复定义使用 i</span></span><br><span class="line">&#123;<span class="comment">//但是实际上 变量 i for循环完以后并不会失效，而是继续作用在全局作用域中</span></span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">//输出 10</span></span><br><span class="line">--------</span><br><span class="line">上述代码等效于</span><br><span class="line"><span class="keyword">var</span> i;  <span class="comment">// i的作用域不是仅限于 for 循环内</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解决这个问题，es6中引入了 <code>let</code>关键字进行解决。我们使用<code>let</code>关键字对其进行改进，让 i 的作用域限定在for循环内</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)  </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">//此时输出 ReferenceError</span></span><br></pre></td></tr></table></figure><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p><code>let</code>的作用域会与其最近的{…}绑定，也就是说js在编译<code>let</code>关键字声明的变量时，会将该变量的作用域限定在包含该变量的{…}内。举个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(i);  <span class="comment">//输出 10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i)  <span class="comment">//输出ReferenceError</span></span><br><span class="line"></span><br><span class="line">变量 i 的作用域被限定在<span class="keyword">if</span>结构的代码块内</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line">如果我们用<span class="keyword">var</span>声明</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(i);  <span class="comment">//输出 10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);  <span class="comment">//依然输出 10</span></span><br><span class="line"></span><br><span class="line">上述代码等效于</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br></pre></td></tr></table></figure><p>这就是<code>var</code>关键字与<code>let</code>关键字的区别。<code>var</code>关键字定义的变量如果不是被包裹在函数体中，那么它就可以被外部作用域所访问。而<code>let</code>关键字声明的变量会将作用域绑定在最近的{…}包裹的块级作用域中。做个小测验</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line">该程序会输出啥？</span><br><span class="line">会是 <span class="number">10</span> <span class="number">10</span> 吗？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">该程序的输出是?</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一题的答案为: 10  ReferenceError，第二题的答案为：10 10 10。这个例子可以很形象的说明<code>let</code>关键字的特性。</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p><code>const</code>关键字的特性与<code>let</code>一样，都是将变量的作用域绑定在最近{…}中，唯一的不同就是当我们在其作用域中不允许修改其变量值，被<code>const</code>定义的变量都为常量，若想修改则会产生 TypeError.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> i = <span class="number">10</span>;</span><br><span class="line">i = <span class="number">20</span>; <span class="comment">//TypeError</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">//ReferenceError</span></span><br></pre></td></tr></table></figure><h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><p>我们都知道函数和变量若都声明在调用后面，js依然会通过编译。因为函数和变量的声明会被提升至所在作用域顶部，而赋值却留在原地。<strong>若代码中出现多个重复的声明，函数提升会先于变量提升。而且若有多个重复的函数声明，则以最后一个为准</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">30</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">为什么foo();输出的是<span class="number">30</span>?</span><br><span class="line"><span class="comment">//若再调用一次foo()</span></span><br><span class="line">foo(); <span class="comment">// 输出 ?            输出20</span></span><br><span class="line">    </span><br><span class="line">----------</span><br><span class="line"><span class="comment">//在编译器眼中上述代码的执行顺序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">30</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>普通块内的函数声明通常会被提升至顶级作用域的顶部，且这个过程不可被条件判断控制</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">//&#x27;asuhe&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;ashitahe&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;asuhe&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>事件对象</title>
    <link href="http://example.com/2021/10/13/2021-10-13-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/"/>
    <id>http://example.com/2021/10/13/2021-10-13-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-10-13T09:53:03.000Z</published>
    <updated>2021-10-14T01:00:34.791Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是事件对象"><a href="#什么是事件对象" class="headerlink" title="什么是事件对象"></a>什么是事件对象</h2><p>在浏览器中我们通常都是通过事件触发来实现网页与用户的交互效果的，在这个过程中js会产生一个事件对象。例如我们用常规方法给按钮绑定一个点击事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;btn&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    btn.addEventListiner(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"> e </span>)</span>&#123; <span class="comment">//这里我们给匿名函数的形参 e 就可以接收到 click 产生的事件对象</span></span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&#x27;哈喽&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="事件对象可以干什么"><a href="#事件对象可以干什么" class="headerlink" title="事件对象可以干什么"></a>事件对象可以干什么</h2><p>在返回的事件对象中包含了很多属性与方法，这些属性可以让我们准确的获取到用户目前的状态，例如用户按下了什么键、鼠标移动坐标、鼠标点击等等。然后我们可以根据用户的状态去设计我们的交互。我们可以打印一下这个对象看看里面都有什么</p><p><img src="https://i.loli.net/2021/10/14/91XMzcK2inRrb4k.png" alt="部分事件对象的内容"></p><h2 id="事件触发的三个阶段"><a href="#事件触发的三个阶段" class="headerlink" title="事件触发的三个阶段"></a>事件触发的三个阶段</h2><p>一个事件从产生到被触发可以分为三个阶段：捕获阶段、停留阶段、冒泡阶段。在捕获阶段，浏览器查找触发的事件顺序是从顶级DOM依次查找，直到找到源头。如果查找过程中有DOM元素绑定了和事件源头一样的事件，则会被触发。举个例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;father&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;son&#x27;</span>&gt;</span>Asuhe<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> father = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.father&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    father.addEventListiner(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&#x27;我是你爸爸&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,<span class="literal">true</span>) <span class="comment">//开启捕获阶段</span></span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> son = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.son&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    son.addEventListiner(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&#x27;我是你儿子&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种情况下会先弹出父亲的话，然后在弹出儿子的话。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Web API" scheme="http://example.com/tags/Web-API/"/>
    
  </entry>
  
  <entry>
    <title>Javascript的坑</title>
    <link href="http://example.com/2021/10/10/2021-10-10-js%E7%9A%84%E5%9D%91/"/>
    <id>http://example.com/2021/10/10/2021-10-10-js%E7%9A%84%E5%9D%91/</id>
    <published>2021-10-10T12:31:38.000Z</published>
    <updated>2021-10-27T00:28:26.978Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="坑一：变量提升"><a href="#坑一：变量提升" class="headerlink" title="坑一：变量提升"></a>坑一：变量提升</h2><p>js在解析时，会将所有的变量与函数先声明再进行赋值操作。例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先输出再声明并赋值变量</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//输出结果为undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>像这类代码，在执行时等于如下效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>这说明js在执行时，会将变量提至最前面先声明，再进行赋值操作。</strong>同理，我们进行函数调用时也是如此进行函数提升</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fu1();  <span class="comment">//在未定义fu1()时就调用它，此时我们执行时是可以输出xxx的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">fu1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;xxx&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//但我们使用变量保存函数时，函数无法执行</span></span><br><span class="line">fun();  <span class="comment">//此时控制台报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;asuhe&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="坑二：逻辑中断"><a href="#坑二：逻辑中断" class="headerlink" title="坑二：逻辑中断"></a>坑二：逻辑中断</h2><p>当出现<code>表达式1 &amp;&amp; 表达式2</code>时，前面的<strong>表达式1</strong>返回 true 则返回<strong>表达式2</strong>值，若<strong>表达式1</strong>返回 false 则返回<strong>表达式1</strong>的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span> &gt; <span class="number">3</span> &amp;&amp; <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//输出 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">1</span> &gt; <span class="number">3</span> &amp;&amp; <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//输出 false</span></span><br></pre></td></tr></table></figure><p>当出现<code>表达式1 || 表达式2</code>时，<strong>表达式1</strong>返回 true 则返回<strong>表达式1</strong>的值，若<strong>表达式1</strong>返回 false 则返回<strong>表达式2</strong>的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span> &gt; <span class="number">3</span> || <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//输出 true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">1</span> &gt; <span class="number">3</span> || <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//输出 10</span></span><br></pre></td></tr></table></figure><h2 id="坑三：变量声明"><a href="#坑三：变量声明" class="headerlink" title="坑三：变量声明"></a>坑三：变量声明</h2><p>在js中我们可以不使用<code>var</code>关键字直接对一个变量名进行赋值，而且该变量还会成为一个全局变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">//输出 10</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//输出 10</span></span><br></pre></td></tr></table></figure><h2 id="坑四：函数的形参与实参可以不匹配"><a href="#坑四：函数的形参与实参可以不匹配" class="headerlink" title="坑四：函数的形参与实参可以不匹配"></a>坑四：函数的形参与实参可以不匹配</h2><p>js的函数在定义时可以不书写形参，但是在调用该函数时，我们却可以传入实参。传入的实参会被一个<code>argument</code>对象保存，在函数内部可以使用该对象获取传入实参的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">//输出 10</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">//输出 20</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">2</span>]); <span class="comment">//输出 undefined</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//形参多于实参时，未匹配的形参值为undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//输出 10</span></span><br><span class="line">    <span class="built_in">console</span>.log(b); <span class="comment">//输出 undefined</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//形参少于实参时，多余的实参值不会赋值给形参，但仍然保存在arguments中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//输出 10</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">//输出 20</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">10</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p><code>arugments</code>的内部结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">//输出 arguments结构</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">10</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/10/ET3LHMgmd8rVUD2.png" alt="arguments中保存的东西"></p><h2 id="坑五：内置Array-sort方法里的比较默认是按第一位大小比较的"><a href="#坑五：内置Array-sort方法里的比较默认是按第一位大小比较的" class="headerlink" title="坑五：内置Array.sort方法里的比较默认是按第一位大小比较的"></a>坑五：内置Array.sort方法里的比较默认是按第一位大小比较的</h2><p>在js的内置Array.sort方法里，大小默认是为按第一位的大小比较的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">8</span>,<span class="number">31</span>,<span class="number">40</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">16</span>];</span><br><span class="line">a.sort();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; a.length; index++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/10/YJzjXpPocntudgw.png" alt="数组按第一位的大小比较"></p><p>若要变成正确的升序办法要传入特定的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">8</span>,<span class="number">31</span>,<span class="number">40</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">16</span>];</span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123; <span class="keyword">return</span> a - b;&#125;); <span class="comment">//a - b是升序，固定写法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; a.length; index++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/10/OTUrlYLp5KMRs1x.png" alt="正确的升序"></p><p>降序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">8</span>,<span class="number">31</span>,<span class="number">40</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">16</span>];</span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123; <span class="keyword">return</span> b - a;&#125;); <span class="comment">//b - a是降序，固定写法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; a.length; index++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/10/qXFoMdr1c72ipgk.png" alt="降序"></p><h2 id="坑六：所谓的构造函数"><a href="#坑六：所谓的构造函数" class="headerlink" title="坑六：所谓的构造函数"></a>坑六：所谓的构造函数</h2><p>js里的所谓的构造函数<strong>实际上就是一个自定义的用来创建对象的普通函数</strong>，只是因为它的功能是用来创建对象所以才叫构造函数。本质上与普通函数并没有区别，不是C++或Java里构造函数的概念。<strong>这也就是说，js本质上不是面向对象的，只是实现了类似面向对象的功能</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,sex</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name; <span class="comment">//this指针写出成员赋值</span></span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.name;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Person(<span class="string">&#x27;Asuhe&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;保密&#x27;</span>); <span class="comment">//创建对象时还是要使用 new 关键字</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.getName()); <span class="comment">//输出 Asuhe</span></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//输出obj的结构</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/10/OhNTdpIZF31sinP.png" alt="构造函数"></p><h2 id="坑七：作用域链"><a href="#坑七：作用域链" class="headerlink" title="坑七：作用域链"></a>坑七：作用域链</h2><p>因为变量提升导致我们在调用一个在后面定义并赋值的变量时，会先输出这个变量未赋值的状态。作用域链就是，当我们发现在当前作用域寻找不到变量声明时，就会往上一级作用域去寻找，<strong>找到为止</strong>。若在全局作用域中都未寻找到该变量声明，则报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>; <span class="comment">//变量提升</span></span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">//此时输出undefined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">//此时依然输出undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>; <span class="comment">//变量提升</span></span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>; <span class="comment">//变量提升</span></span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">//依然输出undefined , 因为在foo函数内部作用域中已经找到a的声明，所以不会继续往外查找</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="坑八：类没有变量提升"><a href="#坑八：类没有变量提升" class="headerlink" title="坑八：类没有变量提升"></a>坑八：类没有变量提升</h2><p>前面我们讲到对于函数有函数提升，变量有变量提升，我们可以先使用后声明不会报错。而es6中引入的class关键字就没有类似的提升机制。我们只能先把class的定义放在使用它之前。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Man();  <span class="comment">//此行报错,不能先于Man类的定义使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;hello world!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="坑九：类里面的this指向"><a href="#坑九：类里面的this指向" class="headerlink" title="坑九：类里面的this指向"></a>坑九：类里面的this指向</h2><p>在es6中引入了class关键字，用于实现类似面向对象的功能。但是这个class里的this指针的指向并不是总是指向实例化对象本身。在constructor函数中，this指针是一直指向实例化对象本身的。而在这个<strong>class的方法中，this指针指向的是调用该方法的对象</strong>，有时候调用该方法的并不是该实例化对象所以this指向会发生改变。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span> //点击该按钮输出 undefined</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="title">constructor</span>(<span class="params">name,word</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.name = name;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.word = word;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>); <span class="comment">//绑定至btn</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.btn.onclick = <span class="built_in">this</span>.Say; <span class="comment">//button 调用Say方法</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">Say</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.word);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> asuhe = <span class="keyword">new</span> Person(<span class="string">&#x27;Asuhe&#x27;</span>,<span class="string">&#x27;up&#x27;</span>);</span></span><br><span class="line"><span class="javascript">asuhe.getName(); <span class="comment">//输出 Asuhe</span></span></span><br><span class="line"><span class="javascript">asuhe.Say(); <span class="comment">//输出 up</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="坑十：supre关键字在子类constructor中的使用"><a href="#坑十：supre关键字在子类constructor中的使用" class="headerlink" title="坑十：supre关键字在子类constructor中的使用"></a>坑十：supre关键字在子类constructor中的使用</h2><p>我们都知道 supre 不仅可以调用父类的 constructor ，还可以用于调用父类的普通成员函数。</p><p>子类<strong>在 constructor 中使用 super 关键字, 必须放到 this指针 前面</strong> ，但在普通成员函数中无此规则 (必须先调用父类的构造方法,在使用子类构造方法)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.x = x;</span><br><span class="line"><span class="built_in">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">sum</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.x + <span class="built_in">this</span>.y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.x = x;</span><br><span class="line"><span class="built_in">this</span>.y = y;</span><br><span class="line"><span class="built_in">super</span>(x,y); <span class="comment">//此行报错，super在constructor中必须先于this。super.sum();同样报错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">subtract</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.x - <span class="built_in">this</span>.y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Son(<span class="number">5</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Boostrap初探</title>
    <link href="http://example.com/2021/10/09/2021-10-09-Boostrap%E5%88%9D%E6%8E%A2/"/>
    <id>http://example.com/2021/10/09/2021-10-09-Boostrap%E5%88%9D%E6%8E%A2/</id>
    <published>2021-10-09T11:35:43.000Z</published>
    <updated>2021-10-09T12:15:52.702Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Boostrap简介"><a href="#Boostrap简介" class="headerlink" title="Boostrap简介"></a>Boostrap简介</h2><p>Boostrap是一套基于 HTML、CSS 和 Javascript的的响应式前端框架。简单来说就是一套预先定义好的css文件和js文件，当我们需要使用时在html页面中用<code>link</code>标签引入我们需要的文件，然后使用即可。</p><h2 id="Boostrap的使用"><a href="#Boostrap的使用" class="headerlink" title="Boostrap的使用"></a>Boostrap的使用</h2><p>Boostrap的使用极其简单，我们只需要根据它定义好的类名，在我们要引入样式的标签上添加它给的类名就可以使用了。若默认样式不满足我们的需求，我们可以自己使用选择器更改对应属性。</p><p>Bootstrap 需要为页面内容和栅格系统包裹一个 .container 容器，它提供了两个作此用处的类：container类和container-fluid类，container-fluid类一般用于移动端页面开发。这个.container容器被预定好响应式样式，当我们定义这个类时，引入的Boostrap文件会对其进行一系列初始化操作。</p><h3 id="container和container-fluid的区别"><a href="#container和container-fluid的区别" class="headerlink" title="container和container-fluid的区别"></a>container和container-fluid的区别</h3><h4 id="container类"><a href="#container类" class="headerlink" title="container类"></a>container类</h4><ul><li>响应式布局的容器 固定宽度</li><li>大屏 ( &gt;=1200px)  宽度定为 1170px </li><li>中屏 ( &gt;=992px)   宽度定为 970px </li><li>小屏 ( &gt;=768px)   宽度定为 750px </li><li>超小屏 (100%)</li></ul><h4 id="container-fluid类"><a href="#container-fluid类" class="headerlink" title="container-fluid类"></a>container-fluid类</h4><ul><li>流式布局容器百分百宽度</li><li>占据全部视口（viewport）的容器</li></ul><h3 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h3><p>Bootstrap 提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加， 系统会自动分为最多12列。</p><p>它是指将页面布局划分为等宽的列，然后通 过列数的定义来模块化页面布局。</p><p>当我们使用栅格系统时都是通过使用一系列<code>row</code>和<code>column</code>来进行布局操作。例如携程的移动端页面<img src="https://i.loli.net/2021/10/09/s1eycKh4ALHdiav.png" alt="image-20211009195752403"></p><p>这种布局我们可以用flex布局，也可用栅格系统快速制作。</p><p>container里页面已经被分为十二等份，而这个页面中我们可以很容易知道，先将页面份为三列，再在第二列与第三列中分为上下两行。栅格系统中我们 html 可以这样写</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">    //col-sm-4 即让我们三个盒子各自分到了四份空间</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-sm-4 column1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-sm-4 column2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-sm-4 column3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们需要进行行切分时，html 中可以这样写</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//row-cols-2 让我们的盒子再次按行切分为两行</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">    //col-sm-4 即让我们三个盒子各自分到了四份空间</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-sm-4 column1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-sm-4 row-cols-2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span>Column<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span>Column<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-sm-4 row-cols-2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span>Column<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span>Column<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如上我们在row盒子里可以得到一个 3 * 2 布局</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="code" scheme="http://example.com/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>flex布局</title>
    <link href="http://example.com/2021/10/09/2021-10-09-flex%E5%B8%83%E5%B1%80/"/>
    <id>http://example.com/2021/10/09/2021-10-09-flex%E5%B8%83%E5%B1%80/</id>
    <published>2021-10-09T09:42:16.000Z</published>
    <updated>2021-10-09T11:00:58.292Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是flex布局"><a href="#什么是flex布局" class="headerlink" title="什么是flex布局"></a>什么是flex布局</h2><p>传统布局解决方案主要是依赖<code>display</code> 属性 + <code>float</code>属性 + <code>position</code>属性来控制我们盒模型的位置，用这三个属性相互配合达到将盒子摆放至预期位置的目的。而flex布局主要是利用在父元素中添加<code>display:flex</code>属性，使用与其相关的属性配合达到布局的目的。</p><p>在传统布局中有些特殊布局并不好实现，而在flex布局中我们可以轻松实现。例如将三个盒子同时水平对齐和垂直居中对齐。</p><h2 id="flex布局原理"><a href="#flex布局原理" class="headerlink" title="flex布局原理"></a>flex布局原理</h2><p>flex布局里我们可以指定任意一个元素为父元素，即使是行内元素我们也可以设置flex布局。</p><p>将父盒子作为一个容器，父盒子的儿子元素作为容器的成员。使用父元素控制属性可以控制儿子元素的排列位置。同时flex布局也提供了儿子元素控制属性，令我们可以单独控制特定子元素的位置。父元素控制属性可以理解为游戏里的群体控制效果，子元素控制属性可以理解单体控制效果。</p><p>在flex布局中，我们将页面看作一个二维坐标系，主轴正方向为从左至右，侧轴正方向为从上至下。</p><p><img src="https://i.loli.net/2021/10/09/lxCpiurQ5AbY4eE.png" alt="flex坐标轴"></p><p>利用父元素控制属性我们可以进行切换主轴、设置换行等系列操作。接下来我们可以看看主要的父元素控制元素有哪些。</p><h2 id="常见父元素属性"><a href="#常见父元素属性" class="headerlink" title="常见父元素属性"></a>常见父元素属性</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex-direction</span>：设置主轴的方向 </span><br><span class="line"><span class="attribute">justify-content</span>：设置主轴上的子元素排列方式 </span><br><span class="line"><span class="attribute">flex-wrap</span>：设置子元素是否换行</span><br><span class="line"><span class="attribute">align-content</span>：设置侧轴上的子元素的排列方式（多行） </span><br><span class="line"><span class="attribute">align-items</span>：设置侧轴上的子元素排列方式（单行） </span><br><span class="line"><span class="attribute">flex-flow</span>：复合属性，相当于同时设置了 <span class="attribute">flex-direction</span> 和 <span class="attribute">flex-wrap</span></span><br></pre></td></tr></table></figure><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p><code>flex-direction</code>用于设置主轴为哪个，默认情况下flex主轴为x轴，正方向是从左至右的。</p><p><img src="https://i.loli.net/2021/10/09/YNQTgrkiF8eSwqP.png" alt="flex-direction属性值"></p><p><code>flex-direction:row </code>效果（默认方向），<strong>主轴方向</strong>为从左至右</p><p><img src="https://i.loli.net/2021/10/09/765eRbhkcVWaiqQ.png" alt="flex-direction:row"></p><p><code>flex-direction:row-reverse </code>效果，<strong>主轴方向</strong>为从右至左</p><p><img src="https://i.loli.net/2021/10/09/5I3k2TsWvpAu4oP.png" alt="image-20211009181827790"></p><p><code>flex-direction:column </code>效果，<strong>主轴方向</strong>为从上至下</p><p><img src="https://i.loli.net/2021/10/09/tRj8GibZuxDHkFP.png" alt="flex-direction:column"></p><p><code>flex-direction:column-reverse </code>效果，<strong>主轴方向</strong>为从下至上</p><p><img src="https://i.loli.net/2021/10/09/3Ty9nv5pOoxl24V.png" alt="flex-direction:column-recerse"></p><h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p><code>justify-content</code>的作用是设置<strong>主轴</strong>上子元素的排列方式</p><p><img src="https://i.loli.net/2021/10/09/rkaxRVUWpyLocHF.png" alt="justify-content属性值"></p><p>下列中的示例效果，主轴皆为默认的从左至右</p><p><code>justify-content:flex-start</code>效果（默认）</p><p><img src="https://i.loli.net/2021/10/09/S5789RBDwpvmtQh.png" alt="justify-content:flex-start"></p><p><code>justify-content:flex-end</code>效果（注意和<code>flex-direction:row-reverse</code>的区别）</p><p><img src="https://i.loli.net/2021/10/09/epTGnWflVFsqKkm.png" alt="justify-content:flex-end"></p><p><code>justify-content:center</code>效果</p><p><img src="https://i.loli.net/2021/10/09/cbAU9a7YCRLXIV8.png" alt="justify-content:center"></p><p><code>justify-content:space-around</code>效果（平分剩余空间）</p><p><img src="https://i.loli.net/2021/10/09/YjNS3qDA8FaUpMh.png" alt="justify-content:space-around"></p><p><code>justify-content:space-between</code>效果（头尾元素贴紧边缘）</p><p><img src="https://i.loli.net/2021/10/09/HBqDgMu2Fw8VRkL.png" alt="justify-content:space-between"></p><h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p><code>flex-wrap</code>设置当子元素一行排不下时，是否换行。默认为不换行，将每个子元素宽度压缩至能一行排列。</p><p>当<code>flex-wrap:nowrap</code>时，flex子元素都会挤压在一行而<strong>不会</strong>像<code>float</code>一样空间不够时自动换行</p><p>当<code>flex-wrap:wrap</code>时，flex子元素保持原有大小，一行排不下时<strong>会</strong>像<code>float</code>一样空间不够时自动换行</p><h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p><code>align-items</code>设置<strong>侧轴</strong>上子元素排列方式（单行），<strong>当子元素不止一行时此属性不生效</strong></p><p><img src="https://i.loli.net/2021/10/09/brXIQGHRkuntC64.png" alt="align-items属性值"></p><p><code>align-items:flex-start</code>效果（默认）</p><p><img src="https://i.loli.net/2021/10/09/6ZrzaxDKd1UknLV.png" alt="align-items:flex-start"></p><p><code>align-items:flex-end</code>效果，在侧轴顶部排列</p><p><img src="https://i.loli.net/2021/10/09/Gq9C5svxzOyPoDI.png" alt="align-items:flex-end"></p><p><code>align-items:center</code>效果，在侧轴中部排列</p><p><img src="https://i.loli.net/2021/10/09/pJUaHMNGVLPhIOR.png" alt="align-items:center"></p><p><code>align-items:stretch</code>效果（当子元素的<code>height</code>属性不设置时才显示效果），将子元素拉伸到和父元素一样高</p><p><img src="https://i.loli.net/2021/10/09/gxXsAWk3Nz9rb4H.png" alt="align-items:stretch"></p><h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><p>align-content设置侧轴上的子元素的排列方式（多行）</p><p>设置子项在侧轴上的排列方式并且只能用于子项出现换行的情况（多行），在单行下是没有效果的。</p><p><img src="https://i.loli.net/2021/10/09/PmbyIid5qYpx9uJ.png" alt="align-content属性值"></p><p><code>align-content:flex-end</code>效果，在侧轴尾部排列</p><p><img src="https://i.loli.net/2021/10/09/fORD7b9Ul1oJWZN.png" alt="align-content:flex-end"></p><p><code>align-content:center</code>效果，在侧轴中间排列</p><p><img src="https://i.loli.net/2021/10/09/l9O3rR1XNFcfDZ4.png" alt="align-content:center"></p><p><code>align-content: space-around</code> 效果，平分剩余空闲空间并在侧轴两侧排列</p><p><img src="https://i.loli.net/2021/10/09/xKrhMCI1XmOAw7Q.png" alt="align-content: space-around;"></p><p><code>align-content: space-between </code>效果，首行和尾行紧贴侧轴两端，中间行平分剩余空间</p><p><img src="https://i.loli.net/2021/10/09/KtlQ17b3WqAYmis.png" alt="align-content: space-between"></p><h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p><code>flex-flow</code>是<code>flex-direction</code>和<code>flex-wrap</code>的复合写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex-flow</span>:flex-direction-value flex-wrap-value </span><br></pre></td></tr></table></figure><h2 id="常见子元素属性"><a href="#常见子元素属性" class="headerlink" title="常见子元素属性"></a>常见子元素属性</h2><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p><code>flex </code>属性定义子项目分配剩余空间，用flex来表示占多少<strong>份数</strong> </p><p>设置<code>中</code>的属性为<code>flex:2</code>,空白空间被分为四份，中间的占两份</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//父容器空间被分为四等份，中间元素占<span class="number">2</span>份，两边元素占<span class="number">1</span>份</span><br><span class="line"><span class="selector-class">.zuo</span> &#123;</span><br><span class="line"><span class="attribute">flex</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.zhong</span> &#123;</span><br><span class="line"><span class="attribute">flex</span>:<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.you</span> &#123;</span><br><span class="line"><span class="attribute">flex</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/09/l6uzL1tUy9bw5nJ.png" alt="flex:2"></p><h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p><code>align-self </code>控制子项<strong>自己</strong>在<strong>侧轴</strong>上的排列方式，可以单独控制一个子元素的位置</p><p>align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。 默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//如设置 右 元素，在底部</span><br><span class="line"><span class="selector-class">.you</span> &#123;</span><br><span class="line"><span class="attribute">align-self</span>:flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/09/eXoJMHfayB6qAY4.png" alt="align-self"></p><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p>order 属性定义项目的排列顺序,数值越小，排列越靠前，<strong>默认值为0</strong>。</p><p>设置<code>中</code>元素在第一个位置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.zhong</span> &#123;</span><br><span class="line"><span class="attribute">order</span>:-<span class="number">1</span>;  //<span class="number">0</span> &gt; -<span class="number">1</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/09/xzeqv2lV69jBwmr.png" alt="order"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="code" scheme="http://example.com/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>Windows terminal 免密码登录Linux服务器</title>
    <link href="http://example.com/2021/10/08/2021-10-08-%E4%BD%BF%E7%94%A8Windows-terminal-%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95Linux%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://example.com/2021/10/08/2021-10-08-%E4%BD%BF%E7%94%A8Windows-terminal-%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95Linux%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2021-10-08T12:12:16.000Z</published>
    <updated>2021-10-09T11:35:06.910Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Linxu服务器配置"><a href="#Linxu服务器配置" class="headerlink" title="Linxu服务器配置"></a>Linxu服务器配置</h2><h3 id="登录Linux并生成密钥对"><a href="#登录Linux并生成密钥对" class="headerlink" title="登录Linux并生成密钥对"></a>登录Linux并生成密钥对</h3><p>首先我们使用putty登录Linux服务器</p><p><img src="https://i.loli.net/2021/10/08/KNjAHIwMhWoTBU2.png" alt="putty登录服务器"></p><p>再让Linux服务器先生成 rsa 密钥对供我们认证。使用如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p>命令执行后对于弹出的选项我们一路回车就行</p><p><img src="https://i.loli.net/2021/10/08/IRbGlNqvMUCSgrA.png" alt="生成密钥对"></p><p>密钥对生成后我们要将其中的公钥文件<code>id_rsa.pub</code>更改为<code> authorized_keys</code>，然后将私钥文件<code>id_rsa</code>下载至本地Windows</p><h3 id="更改Linux公钥文件名称"><a href="#更改Linux公钥文件名称" class="headerlink" title="更改Linux公钥文件名称"></a>更改Linux公钥文件名称</h3><p>我们找到生成密钥的地址<code> /home/unbuntu/.ssh</code>，因为我们现在就是在当前用户目录下生成的密钥，所以只需要输入<code>cd .ssh</code>即可跳转至密钥存放的文件夹，<code>ls</code>查看一下。确实存在我们刚刚生成的密钥，最后更改公钥文件名称Linux端就大功告成了。再查看一下，文件是否更改成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//跳转到密钥文件所在目录</span><br><span class="line">cd .ssh</span><br><span class="line"></span><br><span class="line">//更改公钥文件名</span><br><span class="line">mv id_rsa.pub authorized_keys</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/08/p7y5bLd8Y4vwNso.png" alt="更改公钥文件名称"></p><h2 id="Windows端配置"><a href="#Windows端配置" class="headerlink" title="Windows端配置"></a>Windows端配置</h2><h3 id="从Linux服务器下载私钥"><a href="#从Linux服务器下载私钥" class="headerlink" title="从Linux服务器下载私钥"></a>从Linux服务器下载私钥</h3><p>Linux服务器已经生成了密钥对，并且我们也成功将Linux中的公钥文件修改成功。接下来我们只要将Linux生成的私钥下载至本地即可。</p><p>首先我们需要确定Linux上私钥的存放地址，然后再确定Windows中我们将私钥存放的地址。比如Windows中我就将私钥存放在<code>D:\ssh_keys\tencent</code></p><p>找到Linux中文件存放的地址，其实地址之前我们生成密钥对的时候就已经显示过了，我们只需要复制下来即可。私钥文件路径<code>/home/ubuntu/.ssh/id_rsa</code></p><p><img src="https://i.loli.net/2021/10/08/HM9rK5IytaZNpeo.png" alt="获取私钥"></p><p>使用scp将文件下载至我们指定的位置:<code> scp ubuntu@Linux的IP:/home/ubuntu/.ssh/id_rsa D:\ssh_keys\tencent</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//scp命令格式</span><br><span class="line">scp Linux用户名@Linxu的IP地址:密钥的文件路径 Windows存放密钥的文件路径</span><br></pre></td></tr></table></figure><p>根据提示输入Linxu用户密码</p><p><img src="https://i.loli.net/2021/10/08/Iva5uWUGbtTC6Yc.png" alt="下载私钥"></p><p>下载完成后我们可以看见我们的密钥文件</p><p><img src="https://i.loli.net/2021/10/08/FtJqo8wEWRHfG45.png" alt="找到私钥"></p><p>到了这一步我们就可以使用密钥登录啦，在命令行中输入:<code>ssh -i D:\ssh_keys\tencent\id_rsa ubuntu@Linux的IP地址</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//登录命令格式</span><br><span class="line">ssh -i Windows中私钥的文件路径 Linux用户名@Linxu的IP地址</span><br></pre></td></tr></table></figure><p>登录成功</p><p><img src="https://i.loli.net/2021/10/08/z2efD4Nit97U5xg.png" alt="密钥登录"></p><h3 id="设置私钥文件权限"><a href="#设置私钥文件权限" class="headerlink" title="设置私钥文件权限"></a>设置私钥文件权限</h3><p>走到这一步我们已经基本完成了，但是还有一个问题就是当我们执行密钥登录时Windows可能会提示我们私钥文件过权限大，忽视这个私钥，导致我们无法使用密钥登录</p><p><img src="https://i.loli.net/2021/10/08/EUnf5Lp2QgGZqDx.png" alt="私钥文件权限过于开放"></p><p>这时我们需要将私钥文件<code>id_rsa</code>的权限设置为仅<strong>所有者</strong>控制</p><p>在Windows资源管理器中找到<code>id_rsa</code>文件，右键单击该文件，然后选择“属性”。导航到“安全性”选项卡，然后单击“高级”。</p><p>将所有者更改为你，禁用继承并删除所有权限，把除了自己以外的权限条目全部删除。然后授予自己“完全控制权”并保存权限。</p><p><img src="https://i.loli.net/2021/10/08/sbrithHIYfGSwlU.png" alt="删除其它用户对私钥文件的权限"></p><p>现在SSH不再抱怨文件权限太开放了。</p><p>若原本权限条目中没有拥有者，则去添加中寻找并加入</p><p><img src="https://i.loli.net/2021/10/08/xfqCWE7l2KDMJnt.png" alt="寻找本机用户组"></p><h2 id="设置Windows-terminal"><a href="#设置Windows-terminal" class="headerlink" title="设置Windows terminal"></a>设置Windows terminal</h2><p>只需要去设置中将我们刚才登录Linux的命令复制一份并保存就可以了</p><p><img src="https://i.loli.net/2021/10/08/URK3hpTQWH569cX.png" alt="Windows terminal设置"></p><p>这样以后我们打开Windows terminal选择选项卡就可以登录服务器了，打完收工！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="tips" scheme="http://example.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>浅谈rem布局</title>
    <link href="http://example.com/2021/10/07/rem%20+%20less%20+%20%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E5%B8%83%E5%B1%80/"/>
    <id>http://example.com/2021/10/07/rem%20+%20less%20+%20%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E5%B8%83%E5%B1%80/</id>
    <published>2021-10-07T15:14:23.000Z</published>
    <updated>2021-10-07T15:14:26.807Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="rem-less-媒体查询布局"><a href="#rem-less-媒体查询布局" class="headerlink" title="rem + less + 媒体查询布局"></a>rem + less + 媒体查询布局</h1><h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><h3 id="初识rem"><a href="#初识rem" class="headerlink" title="初识rem"></a>初识rem</h3><p>什么是rem，rem的全称为root em。em我们都知道，1em代表一个字符的大小。而root em顾名思义，我们可以大致猜测出是以某个源为标准的单位。实际上rem代表的是以<html>标签里font-size属性的单位，举个例子</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">设置<span class="selector-tag">html</span>文件的默认字体大小为<span class="number">16px</span></span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line">此时 <span class="number">1</span> rem = <span class="number">16</span> px;</span><br></pre></td></tr></table></figure><p>由此可以看出，html标签里设置的字体像素值为多少，其每单位rem就是多少像素的大小。</p><h3 id="为什么要rem"><a href="#为什么要rem" class="headerlink" title="为什么要rem"></a>为什么要rem</h3><p>我们都知道当我们缩放浏览器窗口时，网页的内容会因为我们的而改变缩放。如果我们进行开发时，使用的是rem则采用rem进行设置大小的内容都会进行等比缩放，从而实现自适应效果。但如果我们使用px规定了大小，此时我们进行缩放或者使用不同分辨率的设备查看网页内容时，里面的字体的内容并不会进行一个等比缩放而是依然使用规定的像素值。</p><p>rem的出现很好的解决了不同分辨率下查看同一网页字体不会自适应的问题。</p><p>相比于em仅依靠父元素来设置文字大小，在实际开发中父元素文字大小可能不一致，但是整个页面只有一个html，使用rem可以很好来控制整个页面的元素大小。</p><h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><h3 id="什么是less"><a href="#什么是less" class="headerlink" title="什么是less"></a>什么是less</h3><p>为解决css代码冗余，无法使用变量、函数等概念的问题。引入less简化css代码的开发。</p><p>Less （Leaner Style Sheets 的缩写） 是一门 CSS 扩展语言，也称为CSS预处理器。</p><h3 id="典型场景"><a href="#典型场景" class="headerlink" title="典型场景"></a>典型场景</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">当我们需要在不同选择器重复使用同一属性并对其修改时，需要一个一个找到相应属性然后修改十分麻烦，如下情形</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    backgroud-<span class="attribute">color</span>:green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>:green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">我们要同时修改背景颜色时，需要一个一个去修改很麻烦。若我们使用less开发，则可以同时修改背景颜色，只需如下</span><br><span class="line"></span><br><span class="line"><span class="keyword">@Color</span>:black;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    backgroud-<span class="attribute">color</span>:@Color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>:@Color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">改变变量<span class="attribute">Color</span>的值即可同时修改<span class="selector-tag">body</span> 和 <span class="selector-tag">div</span> 的背景颜色为black</span><br><span class="line"></span><br><span class="line">可以将其理解为一个全局变量</span><br></pre></td></tr></table></figure><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><h5 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h5><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@varname:</span>value; </span><br></pre></td></tr></table></figure><p>注意事项</p><ul><li>必须有@为前缀</li><li>不能包含特殊字符</li><li> 不能以数字开头</li><li> 大小写敏感</li></ul><h5 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h5><p>直接选中div里的子元素span</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="selector-tag">CSS-Code</span>;</span><br><span class="line">    <span class="selector-tag">span</span> &#123;</span><br><span class="line">        <span class="selector-tag">CSS-Code</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">编译出的<span class="selector-tag">css</span>代码为</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="selector-tag">CSS-Code</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="selector-tag">CSS-Code</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项</p><ul><li>如果遇见（交集|伪类|伪元素选择器）</li><li>内层选择器的前面没有&amp; 符号，则它被解析为父选择器的后代；</li><li>如果有&amp; 符号，它就被解析为父元素自身或父元素的伪类。</li></ul><p>如，使用伪类选择器</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="selector-tag">CSS-Code</span></span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">        <span class="selector-tag">CSS-Code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">编译出来的<span class="selector-tag">CSS</span>代码为</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="selector-tag">CSS-Code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="selector-tag">CSS-Code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h5><p>可使用的运算符有 + - * / ，运算符前后左右都要空格</p><p>运算优先级为先乘除后加减，从左往右</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>:<span class="number">50px</span> - <span class="number">5</span>; <span class="comment">//最终值为 45px </span></span><br><span class="line"></span><br><span class="line">若改变运算优先级，则使用()即可，如下</span><br><span class="line"></span><br><span class="line">witdth:(50px + 10px) * 2; <span class="comment">//最终值为 120px</span></span><br></pre></td></tr></table></figure><p>注意事项</p><ul><li><p>对于两个不同的单位的值之间的运算，运算结果的值取第一个值的单位</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">10rem</span> / <span class="number">5px</span>; <span class="comment">//最终值为 2rem</span></span><br></pre></td></tr></table></figure></li><li><p>如果两个值之间只有一个值有单位，则运算结果就取该单位</p></li></ul><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><h3 id="什么是媒体查询"><a href="#什么是媒体查询" class="headerlink" title="什么是媒体查询"></a>什么是媒体查询</h3><p>媒体查询（Media Query）是CSS3新语法。 使用媒体查询可以令我们针对不同的设备开发不同的css样式用以适配，当查看网页的设备不同，就可以根据媒体查询的结果去使用不同的css样式以达到最佳的显示效果。</p><h3 id="媒体查询使用"><a href="#媒体查询使用" class="headerlink" title="媒体查询使用"></a>媒体查询使用</h3><h4 id="基础范式"><a href="#基础范式" class="headerlink" title="基础范式"></a>基础范式</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">检测设备分辨率</span><br><span class="line"><span class="keyword">@media</span> -mediatype- -and | <span class="keyword">not</span> | <span class="keyword">only</span> -(media feature)- &#123;</span><br><span class="line">CSS-<span class="selector-tag">Code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">根据设备分辨率引入文件</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; media=&quot;mediatype and|not|only (media feature)&quot; href=&quot;mystylesheet<span class="selector-class">.css</span>&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>用 @media 开头 注意@符号 </li><li>mediatype  媒体类型 </li><li>关键字 and  not   only</li><li> media feature 媒体特性 必须有小括号包含</li></ul><h4 id="属性详解"><a href="#属性详解" class="headerlink" title="属性详解"></a>属性详解</h4><p>mediatype 查询类型，将不同的终端设备划分成不同的类型，称为媒体类型，<strong>一般使用 screen</strong></p><p><img src="https://i.loli.net/2021/10/07/D8iPs1ZbQXMKA7I.png" alt="image-20211007222508126"></p><p>关键字 </p><ul><li>and：可以将多个媒体特性连接到一起，相当于“且”的意思。 </li><li>not：排除某个媒体类型，相当于“非”的意思，可以省略。 </li><li>only：指定某个特定的媒体类型，可以省略。</li></ul><p>媒体特性</p><p>每种媒体类型都具体各自不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格。我们暂且了解三个。注意他们要加小括号包含</p><p><img src="https://i.loli.net/2021/10/07/E1rsOG5hjDNeFqB.png" alt="image-20211007222823943"></p><h4 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">当分辨率小于<span class="number">540px</span>的设备查看时.使<span class="selector-tag">html</span>字体大小为<span class="number">16px</span>，且<span class="selector-tag">body</span>变蓝</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">540px</span>) &#123;</span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>:blue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当分辨率 <span class="number">540px</span> &lt; X &lt; <span class="number">970px</span> 的设备查看时，使<span class="selector-tag">html</span>字体大小为<span class="number">25px</span>，且<span class="selector-tag">body</span>变黑</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">540px</span>) &#123;</span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">25px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>:black;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当分辨率大于<span class="number">970px</span>的设备查看时，使<span class="selector-tag">html</span>字体大小为<span class="number">50px</span>，且<span class="selector-tag">body</span>变红</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">970px</span>) &#123;</span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用媒体查询引入不同css文件，当设备分辨率大于<span class="number">400px</span>时引入styleA<span class="selector-class">.css</span></span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;styleA<span class="selector-class">.css</span>&quot; media=&quot;screen and (<span class="attribute">min-width</span>: <span class="number">400px</span>)<span class="string">&quot;&gt;</span></span><br></pre></td></tr></table></figure><h4 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h4><p>分析媒体查询的里的css层叠特性</p><p><img src="https://i.loli.net/2021/10/07/GwktRdAie3QYoZM.png" alt="image-20211007224005323"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="code" scheme="http://example.com/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>没出息的一天</title>
    <link href="http://example.com/2021/09/20/2021-09-20-%E6%B2%A1%E5%87%BA%E6%81%AF%E7%9A%84%E4%B8%80%E5%A4%A9/"/>
    <id>http://example.com/2021/09/20/2021-09-20-%E6%B2%A1%E5%87%BA%E6%81%AF%E7%9A%84%E4%B8%80%E5%A4%A9/</id>
    <published>2021-09-20T14:21:09.000Z</published>
    <updated>2021-09-26T12:02:40.196Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天又是没出息的一天，晚上在万达吃烤肉等将近两个小时。吃着烤肉不知道怎么的聊起了家事，中午奶奶给我打电话说要怕我没钱要给我打一千块钱当生活费。当时我极力说不要，自己其实有生活费，内心里早已破防。情绪在吃烤肉的时候爆发了，一边忍着不让眼泪流出来一边在吃。旁边的店员走过，向我投来疑惑的目光，真丢人。我的性格从来都是报喜不报忧的，自己本身过的再苦再累也不想让家里人知道让他们担心，习惯了一个人排解。每次一想到奶奶快八十的人了，自己还让她担心这担心那的就觉得对不起他。我知道，自己作为家族里当二个上大学的，一直让她很骄傲。我要承载着她的希望，过的越来越好，不能让她看到自己难过，落魄的一面。</p><p>学校心理咨询室的老师说我内心没有力量支撑，仔细想想确实有道理。从八个月大就留守在家，成长过程中最亲近的人就是奶奶还有姑姑。每次遇到困难、面临重要时刻都会想到不能让她们失望。对于父亲母亲心里仅有一点感情，体会不到父爱母爱。对于父亲憎恨的感情更多，90%的苦难都是因为他造成的，可以说毫无责任感。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="live" scheme="http://example.com/tags/live/"/>
    
  </entry>
  
  <entry>
    <title>生即是罪恶</title>
    <link href="http://example.com/2021/09/10/2021-09-10-%E7%94%9F%E5%8D%B3%E6%98%AF%E6%81%B6/"/>
    <id>http://example.com/2021/09/10/2021-09-10-%E7%94%9F%E5%8D%B3%E6%98%AF%E6%81%B6/</id>
    <published>2021-09-10T12:58:06.000Z</published>
    <updated>2021-09-11T14:54:13.278Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当生活的痛苦超越了死亡，你将做何选择？</p><p><img src="https://i.loli.net/2021/09/10/1lORgFWJDqiu6Hn.png" alt="生即是罪恶.png"></p><p><img src="https://i.loli.net/2021/09/10/VMKS27ICeG3xZv1.png" alt="生即是罪恶.png"></p><p>Live = evil,death is the best destination</p><p>今天是教师节，同时也是<a href="https://www.who.int/zh/news-room/events/detail/2019/09/10/default-calendar/world-suicide-prevention-day-(wspd)">世界预防自杀日</a>。请务必龃龉地、苟且地，活下去。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="live" scheme="http://example.com/tags/live/"/>
    
  </entry>
  
  <entry>
    <title>开学</title>
    <link href="http://example.com/2021/09/05/2021-09-05-%E5%BC%80%E5%AD%A6/"/>
    <id>http://example.com/2021/09/05/2021-09-05-%E5%BC%80%E5%AD%A6/</id>
    <published>2021-09-05T14:46:05.000Z</published>
    <updated>2021-09-10T12:57:45.063Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    今天是开学的日子，6号就要去生产实习了。对于开学，我既开心又焦虑。开心是开学了大家都会回来，校园里也逐渐有些生气。因为留校两个月让我意识到了与人交流的重要性。日复一日地学习，回到寝室也是只有寥寥几句。我本以为我已经可以和孤独相处，但经历了这个暑假我才发现，原来我是如此害怕孤独。以前上课虽然都是一个人独来独往，但是起码那时还有课程这个纽带让整个专业里的人都联系在一起，总觉得朋友同学们还会聚在一起。暑假的时候，大家都蒙头备考。每天非饭点时期，图书馆的电梯是不动的。一切在默默运行，大家都为了自己的未来各自拼搏着忙碌着，再也没有上课时活跃的氛围，空气中弥漫着无形的压抑。焦虑是因为生产实习要占用三周的时间，而备考的日子已经所剩无几。面对考试，显然我心里是没有底气的。生活令人快乐，也令人痛苦。不管如何，剩下的日子里只管努力便是，不问结果几何但求回首无悔。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="live" scheme="http://example.com/tags/live/"/>
    
  </entry>
  
  <entry>
    <title>认识新朋友</title>
    <link href="http://example.com/2021/09/03/2021-09-03%20%20%E8%AE%A4%E8%AF%86%E6%96%B0%E6%9C%8B%E5%8F%8B/"/>
    <id>http://example.com/2021/09/03/2021-09-03%20%20%E8%AE%A4%E8%AF%86%E6%96%B0%E6%9C%8B%E5%8F%8B/</id>
    <published>2021-09-03T14:49:44.000Z</published>
    <updated>2021-09-11T14:58:46.583Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="714729d59989c643cdd873c142e9f9bfe32ba858dc8513be05f49e81c1490e43">f4411ca0c68ccd1e14d2008ea7b3f1fe61e418eb25744978027663736f4855172fa3c1d890fd2e635bae09ffd1c36d47273690b7f3075f502012ca732c60a5cbb44ed69d041f78755f71164cca016e00d5e367807a51a224be86ceac8119cb1d882b7d338890eea97d95cafe2fc6ca03bbc23546d846582d549646a4213c775bfc2090f2a18394f6619c0125aeb9e8490628fc8218cbba36f78f0c80c34c4c0f55c2811a1af68af9b879917c1f4c650ca7986aa59aed827c50c67ec444259b88e9a35097b00bcfe0a31ee4386a783475d9f6d5d7160184aa0e0f9025deb3228bf17bc188fa3508c4fd1c82f6f0d2d7d4dfc4cbd44abc976d27501e8c73874b6bbd54f62b9b0cdeab603dc857ab1878bdb9724e3bf0f47216252172964340775d79c9e7eab7454c20fe71efae8f373306ef975df2256409cd18d8aca8f2178ef290134dff8e7e0ea17619e73bda890f5d9f47b596206b31d057b033bd7e8b4fa2449a815120b3c4da2975e219215f0f3de1b7eba47cf80ee92c0aae23db4806684476bc2297b90e3c8c5987d3c0493d9ca270257b04322a6d526398f97afc20181df1a15ef00de695a43f0e51829534fcf914f261efc7bea9d8aa6cab6f63941761f5c61eb18335d6636df15ad0b057a1756bda4a07315d5ce36bdcef5737f943ae4273d5b5a143ffe5c535bdb139f25da024dfc5d19fabb709db4117e1c018a7253f63707ede4c07028299ec88d0ddf6392a9fd5ce49c0db36b62c0385f9d30b3ae170f4dd72b7a4ae6726d58c1a5eb1f2f257aed0a55fa5371468bbb8419283aa45ceb047f28bbc3b474785415c6e30ecb076aa28d8a9dc319a21301956a76fbe24c29e35e96ffa83105c56c93cf3748cc57a495e73ce75dd657a927aeee79918161c160a7109f41daad21dd7a479f168e16b3790aec4f8b4704cc86e5bf219f0647e9db0ff5f95a7964976081d6d605b50789de6d8637086392d7a196acd8595a930282aa6fa77fad5e570ceaf86ec72838cca6603d3df299c081a65694e84be400562c8d02a7f37ce973aef702288ad152a98a97c9bc15c548f9979782a9b61c18df8561f621abd6d7a1135fcf9fd3943e73bafb441bc0f2290e96c5ffcc1490784704e97e53c5ef39a10a59ae5bcd54113523a1c0e567567e25350f589e28ee6fbe6b77f96a8b7f3eadd3ed79967760b05824c88ffe412a6ecbfb06a3adab31db415cb7933f681a0ae35932aaeee09a5bec5c1a471fee59456ec95173f5ff081efa36a1093ad647d226acef0e8e3d6002d36e160826cc2562d8c9adc872bb97eb426fdd37d562859e3969919c8215fe8ddf11e4ae3d4d5e8aa12e69240eb48291b495e5f16cd926bdfb5c4d032a3daa8944155539ac8f1f95d5af42767c4eab00ab87c5a1c4601a6ea18adf857a8c9d9fbb993db3d482697f30f77e9bf136935527a16bbf1b63e2e8135f3fbec4cede352e53e788a2cc7a0932238ac74090b001ab16729c8a448b463d7cc17835e3e770b7ce79f050f6b310a1cde86ca3debf218dc1538f8573e228f207713e3a714472a77a8f5cfe3e90ac03d96eba21bf90e90b80a93c483bf31c27445a5f99eb3c377c91b148126ece293b108fcc2cc17a0c5b971f48a6ca6ebd2e0ed6c6b55c1781d4d822512a08f1ca6a58c0d9129a8ea9eef42120abde3db3c468d731f317fc70f20e7605794d876cde32128a6fb6bd59dff97b6754ec10a8c730946b4b2d12aa0413157ad44bdcb07de37aa8ad4ebc67edbfa3f6f7bcdbaf4bc7c82b7279bbb6c08f05099eb1cbde05761b69518666cb4aa99e5837af19dfdc62e93d9199b43729da309cd80a99d4439d1f0852847df75579b4bafb2e1e079b41f67ee9c94d73d89547e52e27aa78204abc3ecd5b402667a47569ec9c5078e53fc2cde5871da576869913266c4ce95a1a615346a7aa86d601db553b1d990d7f93bfdf1c558fc2ccb586e5902b379e43738260884fe1ede3a7b5e22af6285a64a1f819b9d4ed2b791bb6fa5fdf7503040c7a26d380626022a7ba189b89d61f228cf04dd460fe8d64884a69690f726f3ef858b547f59a66b218ef723f077101d62b147c5e243f028ff1c2a38f094b3a37f9c393d632b85bae57da18b183f17aafe7917d57bc4197934c95fa43e15a66e090e0e717109af5d797646ee862e49317f0820e6f815431a9202d1a561c642ccf03edcc8f8a65ee7fd619da194b52640aff552d55c24a7bc0230c85c3fc958da3bcda68e1ad8ff2e8e27461e05f0f04dfc306ffee377650cc5a6537ebb113f104dfadc911e498695ecb039fe28ed47dfd97bfec16ea4686682cee0080b78c12c983eef3fd41f32c80f9ec9c057aadf03bd1a4a8f95b658c50b69de8f3f097ab97de4f0d40fc7508ade2d270e597ecf85fa542e3fbd50dcf2c2ce3a7458a428385d37151ffc5c28ff662bd80f4c924172fbf9574a2643101784876e2d3667f5d78759de97553d27c06da28041e814301166ea30fd8013f26cd6a79891ba2faa8b01aeeedaca857cf0fdc38e7b31881edd400d65815bb62ccdec1f548df862b636be0977584b64ce9dc79ef001514dd4dbb9b370e72bc16f04211771e5cdc2ea43408b1512d996103292526b15867b91b67b84a66b165fb130cada251851655689e8538bb91fc512fe344a5540f233039175117a9e4774b49b32adc1f7615a3f74384001265d141eb49e2071fb4152001c9707740129a262fee2b01ecd3d94b99b95acc8ebbf473641664c7dcbde3cf0ea00eb3026deb27447282c5dbcfc536cae92584b3adc43efd437ea7d9e96224537d3ff2546fced436847bd5111125edc886a0dbda3494fc0c98b2f8a734cecd5944eabf96ebc0c09d31986fbb0ddc31684605aac0ad235e6b67f5cca12e716bc00476320ba7d237df7c856475f49b52e10d385f6470db383674be238b3e4ecdd45c3fad0e1868ba0afebe1e2e3d4dc6632f159ae3d68aa5634cb8dcb8c8b69c5a1cfdf7778706faade4dffedc9ba8f45984f8fc7f49b66d8d3dc72923d76901ef6fafc9463f156c9691e45a201d46cd8a292ccda61f8bdb5029cc816386afd2fa28e216f509ac16a97f396232aeada026cbef9863f687be98a59c93fb269d273228141ad2ab4c71c1d0801c8f45ff26f89c889f1800ad2eba8ef3cb4e2547fb7935729db2cca08f1a0dacd5375134f34e1e1e77813bbe45fcaaa95a41f3f362f4390953369fc4ab7c5eaa0c2761f5e0847da337d5537ec5a7d61265964fd4e57dc014c8ebbc94150ff78b9eaa5d5767322a41ce6b7631b4461a6c2fe4c7ea779a72320cb96609ada7c4399fc7b3595382237ac35d58d368959ad7276178506d920e65ae4ffb2c1f024f310b78017a0150c8c3198a793ddbf02d45e6bcc843691e1ad106013bfb371ec1a6f4f5bcdf5acb6a8a7b5ff56b6a1eb07f7c290547ebef182617948b9f672d3541dcac7ce23c2b82f22ed93ce0ec9030f25372d0d41582c1007bf256bf7c8ee92e79473ed6069212489c691d83d933c8dac2e923e9f2e39822771142ef5ef779007c0a4b61136a5c57a8f662c9f16053907952f8da9eb62f2832e69ae96e1f0d5f38eb403a2e44d8f111714aaaaa4129af6b9c664eaf23c6b2708f7f0b9966dd1ba12d35479f64e3ac10d00c0b833061282ca29a6bbe4e68ed4e1acf3a36c4bebddb65ff52d429320d39982d5af89aa1256cfb82d0d2c592b703fd51f329df41b82d9b23a8adc41d0342a943430a3cb980afe02874df38f955e4c5dbba5e00a8ec142d5846640f28d6b4095385e2f98a09ff16568ba840ddb42c07b3f90ff91e944d2254d60158e5e019daa4de1c64aee491fa131a47678931cc403d9a7abd75ae9e6a69ae8c9b20b28a3455f48182bc301d92e418f45b6ef4eb54e301ffaa0ff8ea25baf8f85df9b5eefe5d1d921649292473e0f0e79371622dd27685e57f71bb41ca7e32116869710d53a6fdf50cf8d23a962ddc5331b7ebed58d57ff481e8a5726d40c07546044a994fabb2abdd35563dbb74d67df55eba478927acf15462d686123a086427ab8caa9e80a6276f1c10cc742a2254133bbc55ca797718302ce3b7f7df463f2df27b115b4b10195a327afc8aa75b6076ee1175530e8982ecfb9c31ce9fa8a1dac65f75300a3624760da018b17019ea217450f3b9f90186c483f03d85ee1a1004fc10450a011d59c3a1cf5dc5754ec0bfad4e76861a58d5c34b45f18a7cf095e0f2c8b4b937d236b83109bf15337626e78f1e69bea0eb8d2f66497a65954a668ed2287e4e4b7a23021484a8a710a54606e8baabb60c584844aa6fe77cb3bbca72485423372892500c764494482083fa69c4152b39e6b331aaeac57093cca2d4bd7fe714361ebdf4a7b13edd79335b58f0bec000058adc69aa72bb468238a099b6abf0b6084800add39b858af603780bff2b4da6cc054029cdd5f82436cf9148145a7171bdb2c1190c1007e99ed597c13ab6dac2ea11c8a975ede0521d7d1877acbe6d64ebb0a79f61e3860efa2c8828e2e3b8c13d49de02601245f93139f912aaef4379a93b60b7ea05a88633ac1716ce7b3536c86f4f919e3e40c526ef97fb34eaecb78e344162185afe85fa4a3df743ad50979d3eb5638ef6c3690aa1a0363246cf11924531cb0d1d981a25811bfbcdc63602c29ad2dfbb08f2da559195a333b9b8e467ab1f4b2978804b0cae9bda3e7f3a27349e2ea193f475ecba968bae9496084a2f6ea525bee9f8c8afe1003ab2962c43ba93e7f10382d61d0dd014e9bf655aaa0e3b76f9cbd310edebc02acadf28cb6989061963eb724e4a92d0d4052f4574b4b4f92b1db56f49dc20e5ebc91b6f95b20219da3e75acb855590466fc6d16874c1172b2f464eed35c9612d7dce9d2c7bed56e3d97a8f65f39c7cb2dbf309da7b6990123bf34c28c41d7f560712ef311266fa453e1a6f77e510dd5b73a9e8e1270a452648b9b815f351097dc5b0a36460ec74f24aa1945ce2f56fde9d99fab0ee1fe60ebc9c69191cb72365c4b3a9f60d16a5cf4aba580cc02cf594319c504bc5a2fbdaad3dc52277d59416b61c7d0c9ad339f01ee4ed89a64dabf96f8197b129dc00b4183d12cfea1f34785591b1bc7bb1ba5bed321aa7f55173767f4d3edec76bdfdf7ad2a877270a5db72afc2f79e2c46449ae53660c04a686eb16dfa5288696042bb1cc087bb22313e6cef3740c9889cb624d749d46590fe5bfb5fe7ef41a309870fd47d6dfac15c6fc60238835c3a293b8af7c8494852df3223cb95a472d65659adf8ca4bd819bf6fb454ba8154a7a13d08c3f296b29b2e559f97fdb28dfd9ea8d5a6bc498a003d327c251674eb3880461718feaeffdc4ea74b46de1534890090679b303be996d39eadca7d1ba3263dd7da3b5316e2aa84449496bc8fd63e2378fe56d60f1b5dec2bbfd8bb13e8928c0f42f40515781db450cfdd6d479e3f5d176a1454e14233d6dfd5abae13970e2b75c582efe8da1f914dfbbc54f255f4066893fe02e2489902a34fd7c6e0b1d8a58a1db2c2a37e3b504d5d38f976ba4f116db047055923f866b45cf4db9fc9d64cb18a8d8c1cc5a0d5628708cf622caa10d9b540747c8f6d9a0d59744c39e2526932d96a6d62c8e7bbfa393660d707e84e9fe9563dab0de75e08ae7f02c5daa318550fd99d47c9bec9741ee7fd49a18fad3cd6ba51ac5ac6ecdf0acb276a5cf1fea8331439cd5b53fe741a865c08294adc6e191246f0b06fe6162c504899bc77668dfe3fff06d5bd61e7290e91ff20be8e782827b6828311cb2edced53b66fe8c565498dd432fbe1640b80dcbe3272f919eb6d1a19882789905f12b729807e3450f7313b264ef912de2d33384040e78956f6f89d33ae1e0ad73cc47e9e10914edc48f6a509391cd420b97e0e45f5a79247ececd1684e4cdc484fd05e4b2d5085ce83e8c72c87b2ffd59fa9c3b9560193323b79f97498d574c20f5d7a75ee19d9b625268f05e186f9de6c4880ba348339da31e70ff54dbb16946d3e0f695bab9cb898b817120344010a8a313810b06f1c80d3d4bc3db2daf190c5aafb880cf8fd70140f02ce1179cee2ed73bf2bdbaa062a97f2fb1698f9a47c4b497bf1c8b1ae2d52dd2ccdaf6ae14357def10534cb2a81e8c79995d6854a8c95dabefe4d17d682d8ebe7e07d84818b0cd34cbb9cdbe25fd77c18d0125602779b849a67bae48867a6c7b07bb1b7c91538dce484a6fb0299569b7c8ffc11d7a33f303a5ec375c6cb658bc6be4bcc1d9e7f65db02128adf8ffdb33015531ae331595e9918eb8f5b137c88a2b8c6c43e11e8ed893eb31e8da7bd221bef9b2b30e3272c2fa58d00334bbf0b44c6e440eb1fc9ed5de637e538c6c69951a90b3a68230a5322bcc7612de9c5901a2dbe8f73b4cc0b2c326edcb5042dfa290af1c607c7f6df3997f2e8db51a29fa11ac5b82bba90d9fd295962d2fa987544d06f8eb3e7b301d3aa1929870fb35ae7c245cadb0eea78da11cd203fd7c282aaf65dbbc518eb1229ffbdc0cc52446ecd2e5854af70630919efbbf46a4e73ad6b7870277c56616ca0867052f05346111450175d80c0e6283178efcbd6fe0256cf3f480cc3cff4579f05260a4c9eb1169b69c9e37581e6d772ac885bdfa9a6d889e2d058ce6905540d6e4ceaf06db6299793d58c7919ab9bcb7b62b560491e480752d0eddaf6f35f9c401c534169df21b9172dcac64239755b50852424455fa3eada46e7dcbc9f572fbe4bc3b56109e90181e0b0f8cfbe65188d351bdaa5c7eec28964be57ca1bcb1e80f9af31df12518baf32ce17633914ca19dbf07f505ee0a78cb7f7330934e285599cb25eea017c1029eaad613af50efa7f474845717401dcb6425a32fcd7b490efe249eb17f1fea2dd8886e72c4136dcac0b0282827bf4df2c518a550a639c322c155a9df4806b8d1200a8a4caa96209ef29d5d739825605c8734e893f968090d0e0a992ff80d74858c4177e8a85f0f54988f1b7f1d0c9eb1642d5456d0f686136dc30c27ee685b778970080a22882ac185cefab73d7ef0edc1ff33031970e1249b08b225dbba</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">开学新朋友</summary>
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="live" scheme="http://example.com/tags/live/"/>
    
  </entry>
  
  <entry>
    <title>依然恐惧未来</title>
    <link href="http://example.com/2021/08/15/2021-08-15/"/>
    <id>http://example.com/2021/08/15/2021-08-15/</id>
    <published>2021-08-15T12:47:04.000Z</published>
    <updated>2021-09-05T15:22:26.612Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    只要一停下来，脑子里就会焦虑。焦虑未来，焦虑人生，好像这辈子就这样了。自从上大学，可以说没有哪年是过得比较顺心的。别人的大学的生活似乎多姿多彩，而自己却总是多灾多难的样子。每个失眠的夜里反思着自己的人生，或许在家里人看来我考上大学似乎是一件非常成功的事情，但只有当自己上了大学。逐渐明白社会的残酷性后才懂得，你拼尽一切得到的这一切在别人眼里不过如此。你迄今为止所有的一切，其实并不值得一提。现实的毒打直接否定了你一直以来的努力，信念崩塌的痛苦强烈地撕扯着。所有的一切都没有发生根本改变，这个世界是现实的，只有你用努力和自我，令它柔软。</p><p>​    越长大就越能感觉到自己的渺小，努力挣扎只为能做个普通人，过着普通的生活，做着普通的事情。从小听着要努力出人头地，就天真的以为只要努力就能出人头地，现在明白以为努力便能做到一切那是一种傲慢，只有努力才能过上别人唾手可得的普通人的生活。面对命运时常感到绝望，干脆就这样被命运拍死在沙滩上算了。等自己还完了所有的恩情，除去心里的牵挂就可以随时准备死去了。</p><p>​    人真是一种神奇的生物，有时候会自己一个人咬着牙走了很长一段路，有时候却会因为几句话而泪流满面。我曾以为自己已经正视了自己的懦弱，但是最近发现其实并没有。我依然是那个懦弱的，遇到困难首先想着如何逃避的人。心里非常清楚，逃避解决不了任何问题反而会让问题愈发严重，即便如此还是会想着逃避以获取当下短暂的、虚假的安宁。</p><p>​    对未来的恐惧总是如影随形，惧怕未知，惧怕失败，害怕得不到一个好结果。内心已经被对未来的恐惧所占据，想要行动起来去抵抗，发现身体动不起来。恐惧在内心已经占据太多分量，一路以来诚惶诚恐、患得患失。明明知道这样下去不行，行动上还是放任自己。</p><p>​    就像一株浮萍，只能随着命运的长河漂流。无论昨夜发生了什么，清晨醒来这个城市依旧车水马龙。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="live" scheme="http://example.com/tags/live/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/07/26/2021-07-26/"/>
    <id>http://example.com/2021/07/26/2021-07-26/</id>
    <published>2021-07-26T14:09:16.000Z</published>
    <updated>2021-07-26T14:19:04.873Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>时不时的失眠令人憔悴，无论选择哪条路，在路上遇到挫折时抑或是未来遭受打击时，都会怀疑当初自己的选择。</p><p>只能安慰自己，硬着头皮走下去。欲壑难填，人是环境的产物。当大环境鼓吹焦虑时，不受其影响的终归是少数人。而我显然是大多数，只能被环境裹挟着往前走，什么时候才能独辟蹊径呢。终归是难有坚韧的毅力以及决心，当外界逼迫时才愿意动一动。</p><p>愿最终都有一个好结果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机总线系统概述</title>
    <link href="http://example.com/2021/06/14/%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2021/06/14/%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-06-14T13:34:31.000Z</published>
    <updated>2021-07-14T13:50:35.442Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="总线系统"><a href="#总线系统" class="headerlink" title="总线系统"></a>总线系统</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>总线用于将计算机各个部件连接起来，成为一个整体，是多个系统功能部件之间进行数据传输的公共通道</p><p>单处理器系统中总线分为三大类</p><ul><li>内部总线：CPU内部连接寄存器、运算部件</li><li>系统总线：计算机系统用于连接其它高速设备，存储器、通道等</li><li>I/O总线：用于连接中、低速 I/O 设备</li></ul><h2 id="总线的特性"><a href="#总线的特性" class="headerlink" title="总线的特性"></a>总线的特性</h2><ul><li>物理特性：指总线的物理连接方式，包括总线的根数，总线插头、引脚数等</li><li>功能特性：描述总线中每一根线的功能</li><li>电气特性：定义每根线上信号的传递方向以及有效的电平范围</li><li>时间特性：定义了每根线在何时有效</li></ul><h2 id="总线连接方式"><a href="#总线连接方式" class="headerlink" title="总线连接方式"></a>总线连接方式</h2><p>通常采用适配器部件来完成</p><ul><li>单总线系统：要总线上的所有逻辑部件都高速运行，以便某些设备需要使用总线时能迅速获得总线控制权</li><li>多总线系统：将高速设备（北桥）和低速设备（南桥）分开，用不同类型的桥扩展出不同层次的总线</li></ul><h2 id="总线内部结构"><a href="#总线内部结构" class="headerlink" title="总线内部结构"></a>总线内部结构</h2><ul><li>地址线：单向，用于传送主存与设备的地址</li><li>数据线：双向，用来传送数据</li><li>控制线：对每根线是单向（CPU发向接口，或接口发向CPU），用来指明数据传送的方向（存储器读写、I/O读写）、中断控制和定时控制等</li></ul><h2 id="总体总线分类"><a href="#总体总线分类" class="headerlink" title="总体总线分类"></a>总体总线分类</h2><h3 id="数据传送总线"><a href="#数据传送总线" class="headerlink" title="数据传送总线"></a>数据传送总线</h3><p>由地址线、数据线、控制线组成</p><h3 id="仲裁总线"><a href="#仲裁总线" class="headerlink" title="仲裁总线"></a>仲裁总线</h3><p>包括总线请求线和总线授权线</p><h3 id="中断和同步总线"><a href="#中断和同步总线" class="headerlink" title="中断和同步总线"></a>中断和同步总线</h3><p>用于处理带优先级的中断操作，包括中断请求线和中断认可线</p><h3 id="公用线"><a href="#公用线" class="headerlink" title="公用线"></a>公用线</h3><p>包括时钟信号线、电源线、地线、系统复位线以及加电或断电的时序信号线</p><h2 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h2><h3 id="集中式仲裁"><a href="#集中式仲裁" class="headerlink" title="集中式仲裁"></a>集中式仲裁</h3><ul><li><p>链式查询</p><p>菊花链式查询，授权信号串行地从一个接口发送到下一个接口，若中间有设备请求总线则获得授权，信号不再传递。离CPU越近的设备优先级越高</p><p>该种方式优点是简单、节省线路；其缺点是优先级不能改变，不灵活，可能存在优先级低的设备饿死，对电路故障十分敏感，若中间设备故障则后面的设备都无法工作</p></li><li><p>计数器定时查询</p><p>设备通过BR线发出请求，总线仲裁器接受到请求后，在BS线为0的情况下计数，计数值通过地址线发往各设备。每个设备都有设备地址判别电路，当地址线计数值与设备地址一致时，该设备获得总线使用权，BS置1，终止计数</p><p>该种方式优点是可以通过决定是否从上次终止点开始继续计数还是从0计数来改变各个设备的优先级；其缺点是要增加线的数量</p></li><li><p>独立请求</p><p>每个设备都有一对独立的总线请求线和授权线，请求的信号在排队电路中被总线仲裁器以优先级次序处理授权</p><p>该种方式优点是响应快，优先级次序控制灵活；其缺点是线数大量增加</p></li></ul><p><strong>现代计算机基本采用独立请求方式</strong></p><h3 id="分布式仲裁"><a href="#分布式仲裁" class="headerlink" title="分布式仲裁"></a>分布式仲裁</h3><p>不需要集中的总线仲裁器，每个设备都有自己的总线仲裁器。请求总线时，将它们唯一的仲裁号发送到共享的仲裁总线上，每个仲裁器将从仲裁总线上得到的号与自己比较。若仲裁总线上的号大，则不予响应并撤销其仲裁号，最后获胜者的仲裁号保留在仲裁总线上获得授权</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="CS" scheme="http://example.com/tags/CS/"/>
    
  </entry>
  
</feed>
