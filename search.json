[{"title":"VUE基础(二)","date":"2021-11-09T14:53:35.000Z","url":"/2021/11/09/2021-11-09-VUE%E5%9F%BA%E7%A1%80(%E4%BA%8C)/","tags":[["vue","/tags/vue/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"Vue的生命周期根据官网给的图可以大致将Vue的生命周期分为四个阶段：初始化阶段、挂载阶段、更新阶段、销毁阶段。而每个阶段又可以分为前、后两个阶段。 初始化阶段beforeCreate() 钩子可以让我们在初始化之前进行一些操作。在这个阶段，数据还没有被代理到我们创建的实例中，所以此时我们无法获取data里的数据。 created() 钩子可以让我们在初始化完成时进行一些操作。在这个阶段，数据完成了代理，此时我们可以获取 data中的数据。 挂载阶段beforeMount()钩子可以让我们在DOM实际渲染到页面前进行一些操作，这时挂载点的数据已经被渲染好了，但还没有实际插入页面，我们无法获取到DOM节点。 mounted()钩子可以让我们的在DOM实际渲染到页面后进行一些操作，此时DOM节点已经挂载，我们可以获取到DOM节点。通常这时我们会向服务器发送请求获得数据。 更新阶段当数据更新的时候，data配置项里的数据是马上更新的，但页面上的数据并不是能马上更新。所以有beforeUpdate()和updated()这两个钩子供我们在页面数据更新前后进行操作。 销毁阶段"},{"title":"const 和 Object.freeze()","date":"2021-11-08T12:12:48.000Z","url":"/2021/11/08/2021-11-08-const-%E5%92%8C-Object.freeze()/","tags":[["javascript","/tags/javascript/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"const 关键字是用来声明一个常量的，它可以使一个变量引用不能被改变，而且在定义之初就要赋予初值，不然会报语法错误。这个变量如果是数组或者对象，则它里面的内容其实是可以修改的。 而Object.freeze()方法是冻结了一个对象里面属性的引用，对象的属性值不能改变，但如果对象的属性值是另一个数组或对象，则这个属性值的内部依然可以修改。所以Object.freeze()实际上是一个浅冻结 参考资料： Object.freeze() vs const const vs Object.freeze() in JavaScript"},{"title":"VUE基础(一)","date":"2021-11-07T23:54:23.000Z","url":"/2021/11/08/2021-11-08-VUE%E5%9F%BA%E7%A1%80(%E4%B8%80)/","tags":[["vue","/tags/vue/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"VUE的数据代理原理 我们都知道当我们使用模板语法去输出msg时并不是直接输出data的msg，而是经过 vm 这层代理输出的。 我们在模板中输出的所有数据、方法都是经过 vm 代理的，而不是直接使用配置对象中东西。同样地，当我们修改 msg或者方法时，我们修改的也是 data 、methods中的东西。而不是 vm 上挂载的，修改结果将直接影响到配置对象中的值。 那么这种数据代理是如何做到的呢，答案就是 Object.defineProperty()方法。 Object.defineProperty()这个方法可以添加或修改一个属性，将其变为响应式属性。什么叫响应式属性呢，就是随着你源属性值的变化。它的属性值也跟随着变化。举个简单的例子 实际上我们可以 set 和 get 函数上做任何我们想做的事情。根据这个特性我们可以想到 vm 是如何做数据代理的 我们可以看到 vm 原本就是个空对象，但是我们使用了Object.defineProperty()方法后，它就增添了一个属性msg，每当这个msg被输出时就会自动调用get函数，被修改时就会自动调用set函数 当我们只设置 get 函数进行操作时在 vue 中实际上就是单向数据绑定基础，而我们同时设置好 get 和 set 函数时在 vue 中就变成了双向数据绑定的基础 computed和watchcomputed我们把上例中obj变量拿过来，在这个变量中我们定义了fullName属性。实际上这个属性是由firstName和lastName这两个源头属性组合而成的。既然它是由其它属性组合而成的，那么我们就可以在配置对象的 data 中省略它的定义，直接在 vue 的模板中动态生成。 当我们使用字符串拼接它有一个很大的缺点就是，一旦数据多了起来。拼接字符串这种方法维护起来十分麻烦。而在 vue 它提供了一种计算属性的方式让我们可以更加高效地得到这个由其它属性组合而来的属性。 表面上看起来使用computed去计算一个属性和第一种、第二种方法比起来貌似并没有什么区别，但是实际上用计算属性的方式去获取一个全新的响应式属性效率更高，因为它会被缓存起来。当fullName被多次使用时，它将会直接从缓存中拿出来使用不会多次使用this.firstName + &#39;-&#39; + this.lastName去拼接字符串。 由上我们可以总结出computed的特性： 可以动态创建出一个属性，不用预先定义属性 创建出来的这个属性会被缓存，当属性的值不改变时使用该属性将会直接从缓存中拿出，提高效率 watch除了上面三种方法来获得fullName属性我还有第四种方法得到fullName。那就是使用watch监视属性。使用监视的前提是这个属性必须预先存在，也就是说我们必须在data里预先就有需要监视的属性，然后才能去对它使用watch监视。这是和computed的一个重要区别。继续使用上面的例子，我们只需要在data后面在跟一个watch属性 通过上面例子我们可以体会到watch的特点： 被监视的属性必须预先存在 当被监视的属性不发生变化时，handler函数其实不会被调用 可以使用 immediat:true 强制执行 handler 回调 computed 和 watch 最重要的区别实际上 computed 和 watch 有一个最重要的区别就是，computed里面只能获取到同步的数据，而不能获取到异步的数据。而 watch 里面同步异步的数据都可以获取到。 "},{"title":"TypeError:this.getOptions is not a function","date":"2021-11-07T03:29:37.000Z","url":"/2021/11/07/2021-11-07-webpack%E4%B8%AD%E6%89%93%E5%8C%85css%E7%9A%84%E5%9D%91/","tags":[["tools","/tags/tools/"]],"categories":[["报错处理","/categories/%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86/"]],"content":"webpack 中打包 css、less、sass文件的坑vscode用import语法引入css文件不显示css路径：安装一个路径显示插件即可，推荐使用Path Autocomplete即可解决 原本安装好css-loader准备用webpack打包css文件时出现一堆底层报错说TypeError: this.getOptions is not a function 原因：loader版本不匹配 解决方案：安装配套版本的style-loader和css-loader stackoverflow YYDS less文件无法打包 原因：less-loader版本过高 解决方案：安装低于5.0版本的less-loader stackoverflow YYDS"},{"title":"深入浅出Promise","date":"2021-11-05T00:26:46.000Z","url":"/2021/11/05/2021-11-05-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAPromise/","tags":[["javascript","/tags/javascript/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"同步与异步在学习Promise之前我们需要先明白一些基础知识，首先我们要知道什么叫实例对象，什么叫函数对象。所谓实例对象就是我们使用 new 关键字创建出来的对象，称为实例对象，一般简称对象。而函数对象是指当我们把一个函数当作对象使用时，此时我们称这个函数为函数对象 按函数的调用者分类我们可以将某些函数称为回调函数，回调函数就是我们定义的，我们没调用，最终执行了。最典型的例子就是定时器里我们传入的函数。根据回调函数执行时机的不同，我们又可以将回调函数分为同步回调函数和异步回调函数。 同步回调函数的特点就是立即执行，完全执行完了才结束，不会放入回调队列中。换言之就是它是在主线程上执行的。例如数组遍历相关的回调函数、Promise的excutor函数 上述例子中可以明显看到，数组forEach方法里的回调函数先于主线程上的 console.log 输出，这表明这个回调函数就是一个同步回调 与同步回调函数相反，异步回调函数的特点就是延迟执行，它会被放入回调队列里，等主线程上的函数都执行完以后将来再根据条件执行。例如定时器上的回调函数、ajax回调、Promise的成功 | 失败回调 即便定时器的延迟设为 0 ，它里面的回调函数依然要等待主线程执行完毕才能执行。这就是一个典型的异步回调 通过理解同步回调和异步回调的例子，我们可以明白。所谓同步就是绝对的串行执行，只有上一步执行完了下一步才能继续执行。想象这样的一个场景，我们去做饭，电饭煲在煮饭的同时我们可以继续处理我们的菜，我们不必等饭完全煮好了才开始做菜，这样太浪费时间了。这种就是异步执行。如果我们必须等到饭煮好了才开始炒菜之类的，那这种就是同步执行。 Promise有了上面同步异步的概念以后，接下来我们就可以开始学习Promise了。我们先来看看它是什么，官方给的定义是啥。 抽象表达: Promise是JS中进行异步编程的新方案(旧的是谁?—纯回调) 具体表达: 从语法上来说: Promise是一个构造函数 从功能上来说: promise对象用来封装一个异步操作并可以获取其结果 其实看了上面的表达我们还是不懂什么是Promise。从异步这个词入手，我们都知道ajax就是一个典型的异步操作。那么我们就可以用Promise来封装ajax请求。那我们为什么非要用Promise来封装异步操作，我们用普通的回调函数形式不一样可以吗？这就涉及到回调地狱这个问题，关于[Promise的优越性](# 回调地狱 )我们后面再谈。首先来明确一些基础的Promise知识 Promise不是回调，是一个内置的构造函数，是程序员自己new调用的。 new Promise的时候，要传入一个回调函数，它是同步的回调，会立即在主线程上执行，它被称为executor函数 每一个Promise实例都有3种状态：初始化(pending)、成功(fulfilled)、失败(rejected) 每一个Promise实例在刚被new出来的那一刻，状态都是初始化(pending) executor函数会接收到2个参数，它们都是函数，分别用形参：resolve、reject接收 调用resolve函数会： 让Promise实例状态变为成功(fulfilled) 可以指定成功的value。 调用reject函数会： 让Promise实例状态变为失败(rejected) 可以指定失败的reason。 当我们使用一个Promise管理异步操作的时候，我们要在excutor函数内启动异步任务然后再用它的 then 方法来指定异步任务结束后根据Promise实例的状态来调用相应的回调函数。 关于状态的注意点： 三个状态: pending: 未确定的——初始状态 fulfilled: 成功的——调用resolve()后的状态 rejected: 失败的——-调用reject()后的状态 两种状态改变 pending ==&gt; fulfilled pending ==&gt; rejected 状态只能改变一次！ Promise基本方法Promise构造函数: new Promise (executor) {} executor函数: 是同步执行的，(resolve, reject) =&gt; {} resolve函数: 调用resolve将Promise实例内部状态改为成功(fulfilled)。 reject函数: 调用reject将Promise实例内部状态改为失败(rejected)。 说明: excutor函数会在Promise内部立即同步调用,异步代码放在excutor函数中。 Promise.prototype.then方法: Promise实例.then(onFulfilled,onRejected) onFulfilled: 成功的回调函数 (value) =&gt; {} onRejected: 失败的回调函数 (reason) =&gt; {} 特别注意(难点)：then方法会返回一个新的Promise实例对象 如果上一个回调返回的是一个非promise对象，则这个新的Promise实例状态为fulfilled 当上一个回调返回一个Promise对象则该新返回的Promise对象的状态与回调返回的Promise对象一致 Promise.prototype.catch方法: Promise实例.catch(onRejected) onRejected: 失败的回调函数 (reason) =&gt; {} 说明: catch方法是then方法的语法糖, 相当于: then(undefined, onRejected) Promise.resolve方法: Promise.resolve(value) 说明: 用于快速返回一个状态为fulfilled或rejected的Promise实例对象 备注：value的值可能是：(1)非Promise值 (2)Promise值 当传入的值为非Promise值时或空值时，直接返回一个 fulfilled 状态的 Promise实例 当传入的值为 Promise 时，返回的Promise状态跟随传入的Promise Promise.reject方法: Promise.reject方法(reason) 说明: 用于快速返回一个状态必为rejected的Promise实例对象 Promise.all方法: Promise.all(promiseArr) promiseArr: 包含n个Promise实例的数组 说明: 返回一个新的Promise实例, 只有所有的promise都成功才成功, 只要有一个失败了就直接失败。 若没有失败的值，且没有pending的值即全都成功返回的新Promise状态为fulfilled 若没有失败的值，但存在pending的值即数组内仅有pending和fulfilled两种值，则返回的新Promise状态为pending Promise.race方法: Promise.race(promiseArr) promiseArr: 包含n个Promise实例的数组 说明: 返回一个新的Promise实例, 成功还是很失败？以最先出结果的promise为准。 若最先出结果的promise为pending则跳过该promise 这也就意味着race返回的Promise实例仅有fulfilled和rejected两种状态，不存在pending状态的值 回调地狱上面我们学习了基本Promise使用，但是我们依然没有看出来Promise的优越性在哪里。现在我们有这么一个需求，连发三次Ajax请求，仅当上次请求成功时才发送下一次请求，若请求失败则中断以后的所有请求。 可以看到当我们要进行三次链式的异步请求时，采用纯回调的方式来处理就导致了回调地狱的问题。要对代码进行维护十分困难。而如果我们采用Promise去封装异步请求，则可以解决回调地狱的问题 可以明显地对比出来，利用Promise进行链式异步操作能清晰地看到调用结构，维护起来相比纯回调方便了很多。这就解决了回调地狱的问题。 Promise的优势 指定回调函数的方式更加灵活: 旧的: 必须在启动异步任务前指定 Promise: 启动异步任务 =&gt; 返回promie对象 =&gt; 给promise对象绑定回调函数(甚至可以在异步任务结束后指定) 支持链式调用, 可以解决回调地狱问题 什么是回调地狱：回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调函数执行的条件 回调地狱的弊病：代码不便于阅读、不便于异常的处理 一个不是很优秀的解决方案：then的链式调用 终极解决方案：async/await（底层实际上依然使用then的链式调用） Promise关键问题如何改变一个Promise实例的状态? 执行resolve(value): 如果当前是pending就会变为fulfilled 执行reject(reason): 如果当前是pending就会变为rejected 执行器函数(executor)抛出异常: 如果当前是pending就会变为rejected 改变Promise实例的状态和指定回调函数谁先谁后? 都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调 如何先改状态再指定回调? 延迟一会再调用then() Promise实例什么时候才能得到数据? 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据 Promise实例.then()返回的是一个【新的Promise实例】，它的值和状态由什么决定? 简单表达: 由then()所指定的回调函数执行的结果决定 详细表达: 如果then所指定的回调返回的是非Promise值a: 那么【新Promise实例】状态为：成功(fulfilled), 成功的value为a 如果then所指定的回调返回的是一个Promise实例p: 那么【新Promise实例】的状态、值，都与p一致 如果then所指定的回调抛出异常: 那么【新Promise实例】状态为rejected, reason为抛出的那个异常 如何中断promise链： 当使用promise的then链式调用时, 在中间中断, 不再调用后面的回调函数。 办法: 在失败的回调函数中返回一个pendding状态的Promise实例。 Promise错误穿透的原理： 当使用promise的then链式调用时, 可以在最后用catch指定一个失败的回调, 前面任何操作出了错误, 都会传到最后失败的回调中处理了 备注：如果不存在then的链式调用，就不需要考虑then的错误穿透。 async &amp; await async修饰的函数 函数的返回值为promise对象 Promise实例的结果由async函数执行的返回值决定，返回非Promise值则返回的Promise对象状态为fulfilled，返回Promise则状态跟随返回的Promise，但是不能返回一个 rejected的Promise，否则报错 await表达式 await右侧的表达式一般为Promise实例对象, 但也可以是其它的值 (1).如果表达式是Promise实例对象, await后的返回值是promise成功的值 (2).如果表达式是其它值, 直接将此值作为await的返回值 注意: await必须写在async函数中, 但async函数中可以没有await 如果await的Promise实例对象失败了, 就会抛出异常, 需要通过try…catch来捕获处理 宏任务与微任务目前为止，除了Promise里的成功和失败回调是微任务，其它异步回调都是宏任务 宏队列:[宏任务1，宏任务2…..] 微队列:[微任务1，微任务2…..] 规则：每次要执行宏队列里的一个任务之前，先看微队列里是否有待执行的微任务 ​ 1.如果有，先执行微任务 ​ 2.如果没有，按照宏队列里任务的顺序，依次执行 自我检测初级版 高级版"},{"title":"重绘与回流","date":"2021-11-03T13:15:11.000Z","url":"/2021/11/03/2021-11-03-%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81/","tags":[["DOM","/tags/DOM/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"重绘：样式改变重绘 回流：DOM改变回流"},{"title":"身份认证技术","date":"2021-11-02T00:34:25.000Z","url":"/2021/11/02/2021-11-02-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/","categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"身份认证的由来平时我们在网页上进行交互时，例如登入自己的账号进行信息修改，往往需要服务器对我们进行身份的辨别，好让服务器能够拿到专属于我们自己账号的数据并返回给我们。由于http协议是无状态的，它并不会对会话进行控制。任何一个http请求对服务器来说都是独立的，毫不相干的请求。http协议的这种特性就导致了我们需要自己想办法对用户进行识别，于是便有了身份认证技术。 现在流行的身份认证认证手段主要有三种，分别是：cookie、session和 JWT。这三种身份认证技术都有各自的适用场景，所以在前端中均有大量使用。下面就让我们深入了解一下这三种技术 Cookie认证首先我们要明确什么是cookie。cookie实际上就是一份服务器给浏览器客户端设置的文本信息。当用户第一次登录进系统时，服务器会给用户设置一个cookie，后续用户每次发送http请求中都会携带cookie用于身份识别。 cookie信息都携带在请求头中，而且一个cookie的大小一般不超过4KB。 它的内容由名称、值和一些用于控制有效期、安全性、使用范围的可选属性组成。不同域名下的cookie时各自独立的，不能拿一个网站的cookie去另一个网站做身份认证。每当客户端发起请求时，会自动把当前域名下所有未过期的 Cookie 一同发送到服务器。 我们可以在浏览器的设置中查看cookie的内容 因为cookie认证是用户单方面认证，用户完全可以自己伪造一个cookie发送给服务器来欺骗服务器，这使得cookie安全性较低。为了解决cookie的这个缺陷，进一步提高系统的安全性，所以又有了session机制来辅助身份认证。 Session认证session认证即是在服务器上设置一个标识用户的信息，当用户拿cookie来认证时，服务器这边根据cookie拿出相应的session来必对认证。若服务器这边没有对应的session则说明该cookie是伪造的，拒绝响应。 有了session就可以防止用户伪造cookie登录进系统。进一步提高了安全性。 Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持 跨域访问，所以，当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域 Session 认证。 为了解决这个跨域问题，我们又升级了身份认证技术，采用JWT技术可以解决跨域认证的问题。 JWTJWT（英文全称：JSON Web Token）是目前最流行的跨域认证解决方案。针对跨域问题，JWT采用Token加密字符串来实现身份认证。用户的信息通过 Token 字符串的形式，保存在客户端浏览器中。服务器通过还原 Token 字符串的形式来认证用户的身份。 JWT 通常由三部分组成，分别是 Header（头部）、Payload（有效荷载）、Signature（签名）。 三者之间使用英文的“.”分隔，格式如下： 其中： Payload 部分才是真正的用户信息，它是用户信息经过加密之后生成的字符串。 Header 和 Signature 是安全性相关的部分，只是为了保证 Token 的安全性。 客户端收到服务器返回的 JWT 之后，通常会将它储存在 localStorage 或 sessionStorage 中。 此后，客户端每次与服务器通信，都要带上这个 JWT 的字符串，从而进行身份认证。推荐的做法是把 JWT 放在 HTTP 请求头的 Authorization 字段中，格式如下： 三种认证技术的区别与特点 认证技术 工作原理 生命周期 适用场景 cookie 单向认证 未设置expire属性的cookie关闭浏览器即失效 服务器端渲染数据、同源认证 session 双向认证 服务器未清除即一直生效 服务器端渲染数据、同源认证 JWT 密钥认证 服务器未更换secret就一直生效 前后端分离架构、跨域认证 "},{"title":"Git快速上手指北","date":"2021-10-29T11:36:37.000Z","url":"/2021/10/29/2021-10-29-Git%E5%9F%BA%E7%A1%80/","tags":[["tools","/tags/tools/"]],"categories":[["undefined",""]],"content":"Git基础使用用户信息配置 配置信息检查通过 git config –global user.name 和 git config –global user.email 配置的用户名和邮箱地址，会被写入到 C:/Users/用户名文件夹/.gitconfig文件中。这个文件是Git 的全局配置文件，配置一次即可永久生效。 获取帮助 创建仓库在想要创建仓库的目录下启动 git 然后将文件跟踪提交即可在本地创建 git 仓库 忽略文件可以将不想提交的文件设置为忽略，这样文件就不会被 git 跟踪 创建一个名为.gitignore的配置文件，列出要忽略的文件的匹配模式。 文件 .gitignore 的格式规范如下： ① 以# 开头的是注释② 以/结尾的是目录③ 以/开头防止递归④ 以!开头表示取反⑤ 可以使用glob 模式进行文件和文件夹的匹配（glob 指简化了的正则表达式） 所谓的glob 模式是指简化了的正则表达式：① 星号* 匹配零个或多个任意字符② [abc] 匹配任何一个列在方括号中的字符（此案例匹配一个a或匹配一个b 或匹配一个c）③ 问号?只匹配一个任意字符④ 在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如[0-9] 表示匹配所有0 到9 的数字）⑤ 两个星号 ** 表示匹配任意中间目录（比如a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等） 查看操作日志 回滚至指定版本 将本地仓库推送至GitHub仓库基于HTTPS 基于SSH 分支操作"},{"title":"同源与跨域","date":"2021-10-29T08:05:28.000Z","url":"/2021/10/29/2021-10-29-%E5%90%8C%E6%BA%90%E4%B8%8E%E8%B7%A8%E5%9F%9F/","tags":[["BOM","/tags/BOM/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"域在了解什么是同源和跨域之前我们首先要明确在浏览器中什么是域。浏览器中由协议名、服务器地址、端口号组成一个域。 同源指的是两个 URL 的协议、域名、端口一致，反之，则是跨域。 出现跨域的根本原因：浏览器的同源策略不允许非同源的 URL 之间进行资源的交互。 网页访问资源时，只要 url 的协议名、服务器地址、端口号中任何一个发生了改变就会产生跨域问题。 同源策略为了确保用户的上网安全，浏览器采用了同源策略来防止入侵。如果两个页面的协议，域名和端口都相同，则两个页面具有相同的源。。同源策略就是浏览器规定网页请求数据只能在同源站点中请求，不能跨域请求资源。浏览器规定，A 网站的 JavaScript，不允许和非同源的网站 C 之间，进行资源的交互。虽然我们的网络请求可以正常发送，服务器也会正常响应资源，但到浏览器这层资源就会被拦截下来，我们的 js 代码无法得到数据。例如： ①无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB ②无法接触非同源网页的 DOM ③无法向非同源地址发送 Ajax 请求 跨域解决方法现如今，实现跨域数据请求，最主要的两种解决方案，分别是 JSONP 和 CORS。 JSONP：出现的早，兼容性好（兼容低版本IE）。是前端程序员为了解决跨域问题，被迫想出来的一种临时解决方案。缺点是只支持 GET 请求，不支持 POST 请求。 CORS：出现的较晚，它是 W3C 标准，属于跨域 Ajax 请求的根本解决方案。支持 GET 和 POST 请求。缺点是不兼容某些低版本的浏览器。 JSONPJSONP (JSON with Padding) 是 JSON 的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。 由于浏览器同源策略的限制，网页中无法通过 Ajax 请求非同源的接口数据。但是 &lt;script&gt;标签不受浏览器同源策略的影响，可以通过 src 属性，请求非同源的 js 脚本。 因此，JSONP 的实现原理，就是通过 &lt;script&gt; 标签的 src 属性，请求跨域的数据接口，并通过函数调用的形式，接收跨域接口响应回来的数据。 由于 JSONP 是通过 &lt;script&gt; 标签的 src 属性，来实现跨域数据获取的，所以，JSONP 只支持 GET 数据请求，不支持 POST 请求。 JSONP 和 Ajax 之间没有任何关系，不能把 JSONP 请求数据的方式叫做 Ajax，因为 JSONP 没有用到 XMLHttpRequest 这个对象。 CORSCORS （Cross-Origin Resource Sharing，跨域资源共享）由一系列 HTTP 响应头组成，这些 HTTP 响应头决定浏览器是否阻止前端 JS 代码跨域获取资源。 ①CORS 主要在服务器端进行配置。客户端浏览器无须做任何额外的配置，即可请求开启了 CORS 的接口。 ②CORS 在浏览器中有兼容性。只有支持 XMLHttpRequest Level2 的浏览器，才能正常访问开启了 CORS 的服务端接口（例如：IE10+、Chrome4+、FireFox3.5+）。 CORS响应头部- Access-Control-Allow-Origin响应头部中可以携带一个 Access-Control-Allow-Origin 字段，其语法如下: 其中，origin 参数的值指定了允许访问该资源的外域 URL。 例如，下面的字段值将只允许来自  的请求： CORS响应头部- Access-Control-Allow-Headers默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头： Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type （值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一） 如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 Access-Control-Allow-Headers 对额外的请求头进行声明，否则这次请求会失败！ CORS响应头部- Access-Control-Allow-Methods默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。 如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 Access-Control-Alow-Methods来指明实际请求所允许使用的 HTTP 方法。 CORS请求的分类简单请求同时满足以下两大条件的请求，就属于简单请求： ① 请求方式：GET、POST、HEAD 三者之一 ② HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值application/x-www-form-urlencoded、multipart/form-data、text/plain） 预检请求只要符合以下任何一个条件的请求，都需要进行预检请求： ① 请求方式为 GET、POST、HEAD 之外的请求 Method 类型 ② 请求头中包含自定义头部字段 ③ 向服务器发送了 application/json 格式的数据 在浏览器与服务器正式通信之前，浏览器会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求，所以这一次的 OPTION 请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据。 其中OPTION预检请求的请求体为空，若预检成功则服务器返回的响应体也为空 简单请求的特点：客户端与服务器之间只会发生一次请求。 预检请求的特点：客户端与服务器之间会发生两次请求，OPTION 预检请求成功之后，才会发起真正的请求。"},{"title":"防抖与节流","date":"2021-10-29T07:11:24.000Z","url":"/2021/10/29/2021-10-29-%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/","tags":[["BOM","/tags/BOM/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"防抖什么是防抖，在操作系统中如果一块数据在短时间内频繁地由内存换出到外存，再由外存换入内存。这种内存频繁进行换入换出的现象我们称之为内存抖动。类似的在前端中，如果一个页面过于地进行频繁地触发事件我们也将这种行为称之为抖动。 防抖策略（debounce）是当事件被触发后，延迟 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。 防抖最典型的应用例子就是我们在淘宝上进行商品搜索的时候，每当我们输入一个关键字，搜索框下面就会弹出相应关键字的搜索结果。 这里如果我们设置的是每当用户弹起键盘我们就发送一次ajax请求去刷新数据，那么在输入过程中就会导致太多的ajax请求被发送，造成抖动。所以我们需要减少一些不必要的网络请求来减轻服务器压力。 代码实现 节流和防抖类似减少事件触发的概念就是节流，节流的目的是让事件在规定的时间间隔内只能触发一次。和操作系统里同步问题使用互斥锁的思想类似。我们可以在触发某类事件时，先让它判断目前是否可以进入，若可以进入就让它进入后立即将flag置为false使后续事件不能继续进入，退出前在将flag置为true。 节流策略（throttle），顾名思义，可以减少一段时间内事件的触发频率。 节流最典型的应用就是懒加载时要监听计算滚动条的位置，但不必每次滑动都触发，可以降低计算的频率，而不必去浪费 CPU 资源 代码实现 总结防抖：如果事件被频繁触发，防抖能保证只有最后一次触发生效，前面 N 多次的触发都会被忽略！ 节流：如果事件被频繁触发，节流能够减少事件触发的频率，因此，节流是有选择性地执行一部分事件！"},{"title":"http协议","date":"2021-10-28T00:43:22.000Z","url":"/2021/10/28/2021-10-28-http%E5%8D%8F%E8%AE%AE/","tags":[["CN","/tags/CN/"]],"categories":[["计算机网络","/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"]],"content":"什么是HTTP协议HTTP 协议即超文本传送协议 (HyperText Transfer Protocol) ，使用经典的C/S模式交互，它规定了客户端与服务器之间进行网页内容传输时，所必须遵守的传输格式。 在TCP/IP网络模型中，它位于应用层采用传输层采用的是TCP协议，端口号默认是80。虽然它采用的是TCP协议，但它实际上是一个无连接协议，这里的无连接是指服务器每次处理完客户端请求并收到客户端的响应回答后就会马上断开连接，并不会一直维持会话连接状态。同时它是一个无状态协议，即它并不会记录前后报文之间的关系。每一个请求报文在它看来都是独立的，没有上下文联系。这就给我们实际运用的时候带来了一些麻烦，例如在购物网站购买商品时，我们商品加入自己账号的购物车这就需要上下文联系。为了解决这个问题于是就有了cookie-session机制来帮助我们建立上下文联系。 为什么要HTTP协议它是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的，例如现在的电子邮箱流行使用http协议去传输内容。 HTTP报文格式http的报文可以大致分为请求报文和响应报文两种，请求报文即为客户端向服务器发送的请求消息，而响应报文则是服务器根据客户端的请求响应回去的消息。 请求报文HTTP 请求消息由请求行（request line）、请求头部（ header ） 、空行 和 请求体 4 个部分组成。 常见的请求头部 头部字段 说明 Host 要请求的服务器域名 Connection 客户端与服务器的连接方式(close 或 keepalive) Content-Length 用来描述请求体的大小 Accept 客户端可识别的响应内容类型列表 User-Agent 产生请求的浏览器类型 Content-Type 客户端告诉服务器实际发送的数据类型 Accept-Encoding 客户端可接收的内容压缩编码形式 Accept-Language 用户期望获得的自然语言的优先顺序 我们可以在浏览器里具体抓一个请求报头来看看 从上面请求头的对比中里我们可以得知一个结论。GET请求和POST请求的一个重要区别就是GET请求方式中，我们要发送的数据会携带在请求报头中，实际的请求体是为空的。而在POST请求方式中，我们要提交的数据会携带在请求体中，并不会夹带在请求头中。 响应报头HTTP响应消息由状态行、响应头部、空行 和 响应体 4 个部分组成，如下图所示： 实际浏览器中的响应报头 http请求方法 序号 方法 描述 1 GET (查询)发送请求来获得服务器上的资源，请求体中不会包含请求数据，请求数据放在协议头中。 2 POST (新增)向服务器提交资源（例如提交表单或上传文件）。数据被包含在请求体中提交给服务器。 3 PUT (修改)向服务器提交资源，并使用提交的新资源，替换掉服务器对应的旧资源。 4 DELETE (删除)请求服务器删除指定的资源。 5 HEAD HEAD 方法请求一个与 GET 请求的响应相同的响应，但没有响应体。 6 OPTIONS 获取http服务器支持的http请求方法，允许客户端查看服务器的性能，比如ajax跨域时的预检等。 7 CONNECT 建立一个到由目标资源标识的服务器的隧道。 8 TRACE 沿着到目标资源的路径执行一个消息环回测试，主要用于测试或诊断。 9 PATCH 是对 PUT 方法的补充，用来对已知资源进行局部更新 。 http响应状态码http的状态码可以分为5大类型 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作（实际开发中很少遇到 1** 类型的状态码） 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 成功相关的响应状态码2** 范围的状态码，表示服务器已成功接收到请求并进行处理。常见的 2** 类型的状态码如下： 状态码 状态码英文名称 中文描述 200 OK 请求成功。一般用于 GET 与 POST 请求 201 Created 已创建。成功请求并创建了新的资源，通常用于 POST 或 PUT 请求 重定向相关的响应状态码3** 范围的状态码，表示表示服务器要求客户端重定向，需要客户端进一步的操作以完成资源的请求。常见的 3** 类型的状态码如下： 状态码 状态码英文名称 中文描述 301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源（响应消息中不包含响应体）。客户端通常会缓存访问过的资源。 客户端错误相关的响应状态码4** 范围的状态码，表示客户端的请求有非法内容，从而导致这次请求失败。常见的 4** 类型的状态码如下： 状态码 状态码英文名称 中文描述 400 Bad Request 语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 401 Unauthorized 当前请求需要用户验证。 403 Forbidden 服务器已经理解请求，但是拒绝执行它。 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。 408 Request Timeout 请求超时。服务器等待客户端发送的请求时间过长，超时。 服务端错误相关的响应状态码5** 范围的状态码，表示服务器未能正常处理客户端的请求而出现意外错误。前端甩锅码，只要出现5开头的响应码全部甩锅后端哈哈。常见的 5** 类型的状态码如下： 状态码 状态码英文名称 中文描述 500 Internal Server Error 服务器内部错误，无法完成请求。 501 Not Implemented 服务器不支持该请求方法，无法完成请求。只有 GET 和 HEAD 请求方法是要求每个服务器必须支持的，其它请求方法在不支持的服务器上会返回501 503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。 "},{"title":"模板引擎的使用","date":"2021-10-26T09:40:51.000Z","url":"/2021/10/26/2021-10-26-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%9A%84%E4%BD%BF%E7%94%A8/","tags":[["tips","/tags/tips/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"什么是模板引擎在我们要渲染相同的UI结构，如新闻列表、博客的文章列表时，用传统的方法我们需要大量拼接字符串。这使得代码运行效率低，页面加载也慢。不仅如此，当我们需要修改结构时，也需要在字符串中修改这使得代码维护起来十分麻烦而且灵活性非常差。 为了解决传统的方法的缺点，于是我们发明了模板引擎技术。使用模板引擎我们可以快速渲染出UI，同时由于清晰的模板结构我们要修改代码时也十分容易。 art - templateart-template 是一个简约、超快的模板引擎，使用这个模板引擎我们可以很方便地生成一些UI结构。 模板使用步骤①导入 art-template ②定义数据 ③定义模板 ④调用 template 函数 ⑤渲染HTML结构 art-template基础语法输出在标准语法中，可以进行变量的输出、对象属性的输出、三元表达式输出、逻辑或输出、加减乘除等表达式输出。 原文输出如果要输出的 value 值中，包含了 HTML 标签结构，则需要使用原文输出语法，才能保证 HTML 标签被正常渲染。 条件输出如果要实现条件输出，则可以在双花括号中使用 if … else if … /if 的方式，进行按需输出。 循环如果要实现循环输出，则可以在标准语法内，通过 each 语法循环数组，当前循环的索引使用 $index 进行访问，当前的循环项使用 $value 进行访问。 过滤器过滤器语法类似管道操作符，它的上一个输出作为下一个输入。 例子 "},{"title":"JavaScript中的继承","date":"2021-10-23T00:33:54.000Z","url":"/2021/10/23/2021-10-23-JavaScript%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/","tags":[["javascript","/tags/javascript/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"ES6以前在es6以前 js 并没有专门的关键字可以实现继承特性，但是那时候我们又需要使用继承。于是就产生了一些方法可以实现继承的效果 call调用实现继承父属性我们都知道call可以改变函数内this的指向，利用这个特性我们可以在子构造函数里面调用父构造函数，并利用call让父构造函数内的this指向子构造函数。这样就完成了继承操作 利用原型对象实现继承父方法我们还可以通过让子构造函数的prototype指向一个父构造函数的实例的形式实现继承，不过需要注意的是在赋值完成后我们需要让constructor属性重新指回子构造函数 ES6以后es6中引入了class关键字同时也引入了extends关键字，利用这些关键字我们可以很轻易的实现继承。同时若我们想要调用父类的方法和属性只需要使用super关键字。 "},{"title":"ES6新增特性","date":"2021-10-22T00:14:57.000Z","url":"/2021/10/22/2021-10-22-ES6%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7/","tags":[["javascript","/tags/javascript/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"let关键字作用域绑定在最近的{…}块中let在使用时会绑定离它最近的{…}作为作用域。原本在ES6以前是没有块级作用域的概念，在ES6引入了let、const关键字之后就有了块级作用域。实际上这个块级作用域并不是我们平常理解的块级作用域，仅当变量是由let、const关键字声明时，这些关键字声明的变量其作用域会绑定在这个块上，若是使用var关键字声明，其变量依然会成为全局变量。 使用这个特性我们可以很好的解决 for 循环全局变量污染的问题 无变量提升let关键字在使用的时候，不像var那样存在变量提升的情况。它必须先声明再使用。 暂时性死区所谓暂时性死区就是，你在块级作用域使用let声明了一个变量i，同时你在外部作用域也声明的一个同名变量i。若你在let声明这个变量前使用它，它并不会像以前的那样去上级作用域寻找这个变量，仅会在该作用域内寻找变量，又因为变量使用let声明，并且声明在其使用之后，就会抛出ReferenceError。因为使用let在作用域内声明了同名变量，它会屏蔽外界变量，这个块级区域就被称为暂时性死区。 const声明时必须赋值const关键字的特性和let相同，let有的特性const都具有。不同点是它在声明的同时必须赋予一个值，否则抛出SyntaxError。 赋值后不可改变这里const关键字声明的变量能否更改还需要看具体的情况。 若const声明的是一个基本数据类型，则不能更改其值 但是如果const声明的是一个复杂数据类型，则可以更改复杂数据类型变量内部的值，不可更改该复杂数据类型变量本身 箭头函数最初使用箭头函数的目的就是为了简化函数声明的操作，但它的作用不仅如此。我们都知道this指针的指向在不同地方其指向不同，例如在构造函数中其指向就是它的实例化对象，在class中的constructor中也是同样的指向自身的实例化对象，而在普通函数中其指向的是函数的调用者。 箭头函数中的this是根据上下文环境确定的箭头函数this指向的是被声明的作用域里面 多种简写形式当形参只有一个且函数体内仅有一句返回值时 函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号 解构数组的解构在es6中我们可以使用新的方式来命名多个变量，这种新的声明赋值方式就叫解构 剩余参数在es6中新扩展了一种方法可以使函数的形参接收不定数量的实参，那就是使用剩余参数。我们知道在以前js同样支持函数形参和实参数量不匹配，即使定义函数时形参列表为空我们依然可以使用arguments对象获取到实参。但在es6新增的箭头函数中并不支持arguments，所以es6扩展了...args剩余参数来解决这个问题。 "},{"title":"原型与原型链","date":"2021-10-20T00:04:04.000Z","url":"/2021/10/20/2021-10-20-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/","tags":[["javascript","/tags/javascript/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"什么是原型在搞明白什么是原型之前我们首先要明白我们为什么要原型，毕竟语言的设计者不会无缘无故搞出一个完全没有用的东西，它肯定是为了解决某个问题而诞生的。那么原型它解决了什么问题呢？ 我们都知道在es6之前，js是没有关键字class创建类的。那时候我们要使用类就用构造函数这种形式来实现它。在C++这种原生支持类的语言中，同一个类的多个实例里的方法只有一份，也就是说不管我们实例化了多少个对象，在计算机的内存中这个类的方法在内存中只有一份。只有每个实例的属性才会在内存中产生多个副本。例如 在计算机的内存中，a、b这两个实例化对象的内存分布仅有private里的属性才有独立的内存副本，而public里的方法a、b是共享同一片内存的，这样设计就节约了内存空间。 而在es6以前没有class时候，我们通过构造函数实例化的类就会出现上图的第一种情况。每个实例的方法都有独有的内存空间。为了解决这个问题，所以就出现了原型。构造函数通过原型分配的函数是所有对象所共享的，也就实现了第二种内存分布。 如何使用原型JavaScript 规定，每一个构造函数都有一个prototype 属性，指向prototype对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。 我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。 对象原型在构造函数拥有一个原型对象叫prototype，这个原型对象由构造函数内的prototype属性指明，每个构造函数都有一个这样的原型对象。经过上述学习我们知道共享的方法是定义在构造函数的原型prototype中的，但是我们的实例化对象却能使用定义在构造函数里prototype上的方法。这是如何实现的呢？ 实现这个机制的就是我们即将要讲的对象原型。在每个实例化的对象中，都会包含一个属性__proto__。这个__protto__属性就是令我们的实例化对象能够调用构造函数里prototype对象里定义的方法的原因，我们同时也称这个属性为对象原型。__proto__属性指向的是我们的构造函数的prototype原型对象，如上面的man当我们使用实例化的对象调用prototype里的方法时，我们的调用链是：man -&gt; __proto__ -&gt; prototype -&gt; say()。 经过这一层调用，我们的构造函数与实例化对象之间就形成了如下三角关系 constructor构造函数不管我们构造函数里的原型对象Prototype，还是我们实例化的对象里的对象原型__proto__，它们都包含了一个属性constructor。constructor属性的作用就是指明我们引用的构造函数是哪个。例如我们的man、woman它们都是通过构造函数Person创建出来的，所以它们的对象原型里的construtctor属性指向的就应该是Person这个构造函数。按这个指向顺序我们属性指向的关系应该是如下 但事实情况是不是这样的呢？实际上对象原型里的constructor指向是通过构造函数里的prototype.constructor间接指回构造函数的。 一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。 原型链当我们继续打印出prototype这个对象的时候，我们可以看到prototype里面和已经实例化的对象一样里面也有一个__proto__对象原型。那么这个__proto__又指向哪里呢。实际上这个__proto__指向的是js内置的空对象Object的prototype。这个Objerct构造函数的对象原型里的__proto__还会继续往下指向最后的null。所以当我们查找方法时就会延着这条路径链式查找下去返回最先查找到的方法，若最后没找到则返回null。 像上面这种__proto__层层查找构成的链式结构就是我们常说的原型链。 还有一点需要我们注意的是，不管是构造函数里的this 还是构造函数的prototype里的this都是指向我们实例化出来的对象 "},{"title":"sessionStorage 和 localStorage","date":"2021-10-19T00:42:28.000Z","url":"/2021/10/19/2021-10-19-sessionStorage-%E5%92%8C-localStorage/","tags":[["BOM","/tags/BOM/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"背景本文主要围绕What、Why、How这三个方面谈谈sessionStorage 和 localStorage的联系与区别。 WhatsessionStorage 和 localStorage 都是BOM提供给我们在浏览器上进行本地存储数据的API，利用它我们可以实现在本地浏览器存储一些数据。这两个方法都是隶属于 Window这个顶级BOM下的，在需要的时候我们直接调用即可。 Why在某些场合下我们希望能够在用户本地的浏览器上存储一些数据以提高用户体验，所以本地存储技术就应运而生了。典型的应用场景就是我们在登录网站时希望下次登录网站能够记住我们的账号，以免再重新输入。这种时候就可以使用localStorage进行一个本地存储用户名，在用户加载完页面的时候就检测用户浏览器上有无存储相应账号数据，若有则自动填入。 How在使用方式上sessionStorage和localStorage是类似的 window.sessionStorage存储数据： 获取数据： 删除数据： 清空数据：(所有都清除掉) window.localStorage存储数据： 获取数据： 删除数据： 清空数据：(所有都清除掉) sessionStorage 和 localStorage的特点sessionStorage1.存储容量约为5MB 2.同一个页面下可以共享数据 3.生命周期到页面关闭。当页面关闭后存储在浏览器上数据就会被清除，不会保留下来下次打开页面就没有数据了 localStorage1.存储容量约为20MB 2.可以跨页面共享数据 3.生命周期为永久，仅当我们手动删除时才会清除数据，否则下次打开页面或者浏览器数据依然存在 共同点1.数据都存储在用户的浏览器中 2.数据都以键值对的形式存储 3.仅能存取字符串，可以将对象JSON.stringify() 编码后存储 4.读取方便，刷新页面也不会丢失数据"},{"title":"事件对象","date":"2021-10-13T09:53:03.000Z","url":"/2021/10/13/2021-10-13-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/","tags":[["Web API","/tags/Web-API/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"什么是事件对象在浏览器中我们通常都是通过事件触发来实现网页与用户的交互效果的，在这个过程中js会产生一个事件对象。例如我们用常规方法给按钮绑定一个点击事件 事件对象可以干什么在返回的事件对象中包含了很多属性与方法，这些属性可以让我们准确的获取到用户目前的状态，例如用户按下了什么键、鼠标移动坐标、鼠标点击等等。然后我们可以根据用户的状态去设计我们的交互。我们可以打印一下这个对象看看里面都有什么 事件触发的三个阶段一个事件从产生到被触发可以分为三个阶段：捕获阶段、停留阶段、冒泡阶段。在捕获阶段，浏览器查找触发的事件顺序是从顶级DOM依次查找，直到找到源头。如果查找过程中有DOM元素绑定了和事件源头一样的事件，则会被触发。举个例子 这种情况下会先弹出父亲的话，然后在弹出儿子的话。"},{"title":"关于Javascript的作用域","date":"2021-10-13T09:53:03.000Z","url":"/2021/10/13/2021-10-13-%E5%85%B3%E4%BA%8EJavascript%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/","tags":[["javascript","/tags/javascript/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"函数作用域js里若我们包装函数的声明，则该函数会被当做一个函数表达式，而不是一个函数声明。如何理解? 上述例子中，foo函数的作用域仅限于&#123;...&#125;即第五行，foo函数不能再在后续代码被调用。这种情况就是被包装函数声明foo，被编译器当作一个函数表达式而不是一个标准的函数声明。 (function foo()&#123;...&#125;)作为函数表达式意味着，foo只能在&#123;...&#125;所代表的位置中被访问，外部作用域无法访问。但是若是有一个变量去接收该函数表达式的返回值，则该函数依然可以被继续保留调用 变量作用域在js中只有全局作用域和函数作用域这两个基本的单位，块级作用域在js中是不存在的。如何理解呢，请看如下代码 在C++或Java中，i 这个变量其作用域仅在 {…} 中，在 {…} 外调用变量 i 是无法通过编译的，会产生一个报错。而在 js 中，如果你用 var关键字声明的变量不在一个函数中，则其作用域会为上级外部作用域。这就导致了如果我们在后续代码中同样声明一样的变量，使用该变量时就会产生预料外的结果。 很多时候我们希望变量仅在块级作用域里生效，用完以后就被GC回收。例如 为了解决这个问题，es6中引入了 let关键字进行解决。我们使用let关键字对其进行改进，让 i 的作用域限定在for循环内 letlet的作用域会与其最近的{…}绑定，也就是说js在编译let关键字声明的变量时，会将该变量的作用域限定在包含该变量的{…}内。举个例子 这就是var关键字与let关键字的区别。var关键字定义的变量如果不是被包裹在函数体中，那么它就可以被外部作用域所访问。而let关键字声明的变量会将作用域绑定在最近的{…}包裹的块级作用域中。做个小测验 第一题的答案为: 10 ReferenceError，第二题的答案为：10 10 10。这个例子可以很形象的说明let关键字的特性。 constconst关键字的特性与let一样，都是将变量的作用域绑定在最近{…}中，唯一的不同就是当我们在其作用域中不允许修改其变量值，被const定义的变量都为常量，若想修改则会产生 TypeError. 提升我们都知道函数和变量若都声明在调用后面，js依然会通过编译。因为函数和变量的声明会被提升至所在作用域顶部，而赋值却留在原地。若代码中出现多个重复的声明，函数提升会先于变量提升。而且若有多个重复的函数声明，则以最后一个为准 普通块内的函数声明通常会被提升至顶级作用域的顶部，且这个过程不可被条件判断控制 "},{"title":"Javascript的坑","date":"2021-10-10T12:31:38.000Z","url":"/2021/10/10/2021-10-10-js%E7%9A%84%E5%9D%91/","tags":[["javascript","/tags/javascript/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"坑一：变量提升js在解析时，会将所有的变量与函数先声明再进行赋值操作。例如 像这类代码，在执行时等于如下效果 这说明js在执行时，会将变量提至最前面先声明，再进行赋值操作。同理，我们进行函数调用时也是如此进行函数提升 坑二：逻辑中断当出现表达式1 &amp;&amp; 表达式2时，前面的表达式1返回 true 则返回表达式2值，若表达式1返回 false 则返回表达式1的值 当出现表达式1 || 表达式2时，表达式1返回 true 则返回表达式1的值，若表达式1返回 false 则返回表达式2的值 坑三：变量声明在js中我们可以不使用var关键字直接对一个变量名进行赋值，而且该变量还会成为一个全局变量 坑四：函数的形参与实参可以不匹配js的函数在定义时可以不书写形参，但是在调用该函数时，我们却可以传入实参。传入的实参会被一个argument对象保存，在函数内部可以使用该对象获取传入实参的值 arugments的内部结构 坑五：内置Array.sort方法里的比较默认是按第一位大小比较的在js的内置Array.sort方法里，大小默认是为按第一位的大小比较的 若要变成正确的升序办法要传入特定的函数 降序 坑六：所谓的构造函数js里的所谓的构造函数实际上就是一个自定义的用来创建对象的普通函数，只是因为它的功能是用来创建对象所以才叫构造函数。本质上与普通函数并没有区别，不是C++或Java里构造函数的概念。这也就是说，js本质上不是面向对象的，只是实现了类似面向对象的功能 坑七：作用域链因为变量提升导致我们在调用一个在后面定义并赋值的变量时，会先输出这个变量未赋值的状态。作用域链就是，当我们发现在当前作用域寻找不到变量声明时，就会往上一级作用域去寻找，找到为止。若在全局作用域中都未寻找到该变量声明，则报错。 坑八：类没有变量提升前面我们讲到对于函数有函数提升，变量有变量提升，我们可以先使用后声明不会报错。而es6中引入的class关键字就没有类似的提升机制。我们只能先把class的定义放在使用它之前。 坑九：类里面的this指向在es6中引入了class关键字，用于实现类似面向对象的功能。但是这个class里的this指针的指向并不是总是指向实例化对象本身。在constructor函数中，this指针是一直指向实例化对象本身的。而在这个class的方法中，this指针指向的是调用该方法的对象，有时候调用该方法的并不是该实例化对象所以this指向会发生改变。 坑十：supre关键字在子类constructor中的使用我们都知道 supre 不仅可以调用父类的 constructor ，还可以用于调用父类的普通成员函数。 子类在 constructor 中使用 super 关键字, 必须放到 this指针 前面 ，但在普通成员函数中无此规则 (必须先调用父类的构造方法,在使用子类构造方法) "},{"title":"Boostrap初探","date":"2021-10-09T11:35:43.000Z","url":"/2021/10/09/2021-10-09-Boostrap%E5%88%9D%E6%8E%A2/","tags":[["code","/tags/code/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"Boostrap简介Boostrap是一套基于 HTML、CSS 和 Javascript的的响应式前端框架。简单来说就是一套预先定义好的css文件和js文件，当我们需要使用时在html页面中用link标签引入我们需要的文件，然后使用即可。 Boostrap的使用Boostrap的使用极其简单，我们只需要根据它定义好的类名，在我们要引入样式的标签上添加它给的类名就可以使用了。若默认样式不满足我们的需求，我们可以自己使用选择器更改对应属性。 Bootstrap 需要为页面内容和栅格系统包裹一个 .container 容器，它提供了两个作此用处的类：container类和container-fluid类，container-fluid类一般用于移动端页面开发。这个.container容器被预定好响应式样式，当我们定义这个类时，引入的Boostrap文件会对其进行一系列初始化操作。 container和container-fluid的区别container类 响应式布局的容器 固定宽度 大屏 ( &gt;=1200px) 宽度定为 1170px 中屏 ( &gt;=992px) 宽度定为 970px 小屏 ( &gt;=768px) 宽度定为 750px 超小屏 (100%) container-fluid类 流式布局容器百分百宽度 占据全部视口（viewport）的容器 栅格系统Bootstrap 提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加， 系统会自动分为最多12列。 它是指将页面布局划分为等宽的列，然后通 过列数的定义来模块化页面布局。 当我们使用栅格系统时都是通过使用一系列row和column来进行布局操作。例如携程的移动端页面 这种布局我们可以用flex布局，也可用栅格系统快速制作。 container里页面已经被分为十二等份，而这个页面中我们可以很容易知道，先将页面份为三列，再在第二列与第三列中分为上下两行。栅格系统中我们 html 可以这样写 当我们需要进行行切分时，html 中可以这样写 如上我们在row盒子里可以得到一个 3 * 2 布局"},{"title":"flex布局","date":"2021-10-09T09:42:16.000Z","url":"/2021/10/09/2021-10-09-flex%E5%B8%83%E5%B1%80/","tags":[["code","/tags/code/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"什么是flex布局传统布局解决方案主要是依赖display 属性 + float属性 + position属性来控制我们盒模型的位置，用这三个属性相互配合达到将盒子摆放至预期位置的目的。而flex布局主要是利用在父元素中添加display:flex属性，使用与其相关的属性配合达到布局的目的。 在传统布局中有些特殊布局并不好实现，而在flex布局中我们可以轻松实现。例如将三个盒子同时水平对齐和垂直居中对齐。 flex布局原理flex布局里我们可以指定任意一个元素为父元素，即使是行内元素我们也可以设置flex布局。 将父盒子作为一个容器，父盒子的儿子元素作为容器的成员。使用父元素控制属性可以控制儿子元素的排列位置。同时flex布局也提供了儿子元素控制属性，令我们可以单独控制特定子元素的位置。父元素控制属性可以理解为游戏里的群体控制效果，子元素控制属性可以理解单体控制效果。 在flex布局中，我们将页面看作一个二维坐标系，主轴正方向为从左至右，侧轴正方向为从上至下。 利用父元素控制属性我们可以进行切换主轴、设置换行等系列操作。接下来我们可以看看主要的父元素控制元素有哪些。 常见父元素属性 flex-directionflex-direction用于设置主轴为哪个，默认情况下flex主轴为x轴，正方向是从左至右的。 flex-direction:row 效果（默认方向），主轴方向为从左至右 flex-direction:row-reverse 效果，主轴方向为从右至左 flex-direction:column 效果，主轴方向为从上至下 flex-direction:column-reverse 效果，主轴方向为从下至上 justify-contentjustify-content的作用是设置主轴上子元素的排列方式 下列中的示例效果，主轴皆为默认的从左至右 justify-content:flex-start效果（默认） justify-content:flex-end效果（注意和flex-direction:row-reverse的区别） justify-content:center效果 justify-content:space-around效果（平分剩余空间） justify-content:space-between效果（头尾元素贴紧边缘） flex-wrapflex-wrap设置当子元素一行排不下时，是否换行。默认为不换行，将每个子元素宽度压缩至能一行排列。 当flex-wrap:nowrap时，flex子元素都会挤压在一行而不会像float一样空间不够时自动换行 当flex-wrap:wrap时，flex子元素保持原有大小，一行排不下时会像float一样空间不够时自动换行 align-itemsalign-items设置侧轴上子元素排列方式（单行），当子元素不止一行时此属性不生效 align-items:flex-start效果（默认） align-items:flex-end效果，在侧轴顶部排列 align-items:center效果，在侧轴中部排列 align-items:stretch效果（当子元素的height属性不设置时才显示效果），将子元素拉伸到和父元素一样高 align-contentalign-content设置侧轴上的子元素的排列方式（多行） 设置子项在侧轴上的排列方式并且只能用于子项出现换行的情况（多行），在单行下是没有效果的。 align-content:flex-end效果，在侧轴尾部排列 align-content:center效果，在侧轴中间排列 align-content: space-around 效果，平分剩余空闲空间并在侧轴两侧排列 align-content: space-between 效果，首行和尾行紧贴侧轴两端，中间行平分剩余空间 flex-flowflex-flow是flex-direction和flex-wrap的复合写法 常见子元素属性flexflex 属性定义子项目分配剩余空间，用flex来表示占多少份数 设置中的属性为flex:2,空白空间被分为四份，中间的占两份 align-selfalign-self 控制子项自己在侧轴上的排列方式，可以单独控制一个子元素的位置 align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。 默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。 orderorder 属性定义项目的排列顺序,数值越小，排列越靠前，默认值为0。 设置中元素在第一个位置 "},{"title":"Windows terminal 免密码登录Linux服务器","date":"2021-10-08T12:12:16.000Z","url":"/2021/10/08/2021-10-08-%E4%BD%BF%E7%94%A8Windows-terminal-%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95Linux%E6%9C%8D%E5%8A%A1%E5%99%A8/","tags":[["tips","/tags/tips/"]],"categories":[["Linux","/categories/Linux/"]],"content":"Linxu服务器配置登录Linux并生成密钥对首先我们使用putty登录Linux服务器 再让Linux服务器先生成 rsa 密钥对供我们认证。使用如下命令 命令执行后对于弹出的选项我们一路回车就行 密钥对生成后我们要将其中的公钥文件id_rsa.pub更改为 authorized_keys，然后将私钥文件id_rsa下载至本地Windows 更改Linux公钥文件名称我们找到生成密钥的地址 /home/unbuntu/.ssh，因为我们现在就是在当前用户目录下生成的密钥，所以只需要输入cd .ssh即可跳转至密钥存放的文件夹，ls查看一下。确实存在我们刚刚生成的密钥，最后更改公钥文件名称Linux端就大功告成了。再查看一下，文件是否更改成功 Windows端配置从Linux服务器下载私钥Linux服务器已经生成了密钥对，并且我们也成功将Linux中的公钥文件修改成功。接下来我们只要将Linux生成的私钥下载至本地即可。 首先我们需要确定Linux上私钥的存放地址，然后再确定Windows中我们将私钥存放的地址。比如Windows中我就将私钥存放在D:\\ssh_keys\\tencent 找到Linux中文件存放的地址，其实地址之前我们生成密钥对的时候就已经显示过了，我们只需要复制下来即可。私钥文件路径/home/ubuntu/.ssh/id_rsa 使用scp将文件下载至我们指定的位置: scp ubuntu@Linux的IP:/home/ubuntu/.ssh/id_rsa D:\\ssh_keys\\tencent 根据提示输入Linxu用户密码 下载完成后我们可以看见我们的密钥文件 到了这一步我们就可以使用密钥登录啦，在命令行中输入:ssh -i D:\\ssh_keys\\tencent\\id_rsa ubuntu@Linux的IP地址 登录成功 设置私钥文件权限走到这一步我们已经基本完成了，但是还有一个问题就是当我们执行密钥登录时Windows可能会提示我们私钥文件过权限大，忽视这个私钥，导致我们无法使用密钥登录 这时我们需要将私钥文件id_rsa的权限设置为仅所有者控制 在Windows资源管理器中找到id_rsa文件，右键单击该文件，然后选择“属性”。导航到“安全性”选项卡，然后单击“高级”。 将所有者更改为你，禁用继承并删除所有权限，把除了自己以外的权限条目全部删除。然后授予自己“完全控制权”并保存权限。 现在SSH不再抱怨文件权限太开放了。 若原本权限条目中没有拥有者，则去添加中寻找并加入 设置Windows terminal只需要去设置中将我们刚才登录Linux的命令复制一份并保存就可以了 这样以后我们打开Windows terminal选择选项卡就可以登录服务器了，打完收工！"},{"title":"浅谈rem布局","date":"2021-10-07T15:14:23.000Z","url":"/2021/10/07/rem%20+%20less%20+%20%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E5%B8%83%E5%B1%80/","tags":[["code","/tags/code/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"rem + less + 媒体查询布局rem初识rem什么是rem，rem的全称为root em。em我们都知道，1em代表一个字符的大小。而root em顾名思义，我们可以大致猜测出是以某个源为标准的单位。实际上rem代表的是以标签里font-size属性的单位，举个例子 由此可以看出，html标签里设置的字体像素值为多少，其每单位rem就是多少像素的大小。 为什么要rem我们都知道当我们缩放浏览器窗口时，网页的内容会因为我们的而改变缩放。如果我们进行开发时，使用的是rem则采用rem进行设置大小的内容都会进行等比缩放，从而实现自适应效果。但如果我们使用px规定了大小，此时我们进行缩放或者使用不同分辨率的设备查看网页内容时，里面的字体的内容并不会进行一个等比缩放而是依然使用规定的像素值。 rem的出现很好的解决了不同分辨率下查看同一网页字体不会自适应的问题。 相比于em仅依靠父元素来设置文字大小，在实际开发中父元素文字大小可能不一致，但是整个页面只有一个html，使用rem可以很好来控制整个页面的元素大小。 less什么是less为解决css代码冗余，无法使用变量、函数等概念的问题。引入less简化css代码的开发。 Less （Leaner Style Sheets 的缩写） 是一门 CSS 扩展语言，也称为CSS预处理器。 典型场景 基础语法定义变量 注意事项 必须有@为前缀 不能包含特殊字符 不能以数字开头 大小写敏感 嵌套直接选中div里的子元素span 注意事项 如果遇见（交集|伪类|伪元素选择器） 内层选择器的前面没有&amp; 符号，则它被解析为父选择器的后代； 如果有&amp; 符号，它就被解析为父元素自身或父元素的伪类。 如，使用伪类选择器 运算可使用的运算符有 + - * / ，运算符前后左右都要空格 运算优先级为先乘除后加减，从左往右 注意事项 对于两个不同的单位的值之间的运算，运算结果的值取第一个值的单位 如果两个值之间只有一个值有单位，则运算结果就取该单位 媒体查询什么是媒体查询媒体查询（Media Query）是CSS3新语法。 使用媒体查询可以令我们针对不同的设备开发不同的css样式用以适配，当查看网页的设备不同，就可以根据媒体查询的结果去使用不同的css样式以达到最佳的显示效果。 媒体查询使用基础范式 注意事项 用 @media 开头 注意@符号 mediatype 媒体类型 关键字 and not only media feature 媒体特性 必须有小括号包含 属性详解mediatype 查询类型，将不同的终端设备划分成不同的类型，称为媒体类型，一般使用 screen 关键字 and：可以将多个媒体特性连接到一起，相当于“且”的意思。 not：排除某个媒体类型，相当于“非”的意思，可以省略。 only：指定某个特定的媒体类型，可以省略。 媒体特性 每种媒体类型都具体各自不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格。我们暂且了解三个。注意他们要加小括号包含 使用实例 实例分析分析媒体查询的里的css层叠特性 "},{"title":"没出息的一天","date":"2021-09-20T14:21:09.000Z","url":"/2021/09/20/2021-09-20-%E6%B2%A1%E5%87%BA%E6%81%AF%E7%9A%84%E4%B8%80%E5%A4%A9/","tags":[["live","/tags/live/"]],"categories":[["随笔","/categories/%E9%9A%8F%E7%AC%94/"]],"content":"今天又是没出息的一天，晚上在万达吃烤肉等将近两个小时。吃着烤肉不知道怎么的聊起了家事，中午奶奶给我打电话说要怕我没钱要给我打一千块钱当生活费。当时我极力说不要，自己其实有生活费，内心里早已破防。情绪在吃烤肉的时候爆发了，一边忍着不让眼泪流出来一边在吃。旁边的店员走过，向我投来疑惑的目光，真丢人。我的性格从来都是报喜不报忧的，自己本身过的再苦再累也不想让家里人知道让他们担心，习惯了一个人排解。每次一想到奶奶快八十的人了，自己还让她担心这担心那的就觉得对不起他。我知道，自己作为家族里当二个上大学的，一直让她很骄傲。我要承载着她的希望，过的越来越好，不能让她看到自己难过，落魄的一面。 学校心理咨询室的老师说我内心没有力量支撑，仔细想想确实有道理。从八个月大就留守在家，成长过程中最亲近的人就是奶奶还有姑姑。每次遇到困难、面临重要时刻都会想到不能让她们失望。对于父亲母亲心里仅有一点感情，体会不到父爱母爱。对于父亲憎恨的感情更多，90%的苦难都是因为他造成的，可以说毫无责任感。"},{"title":"生即是罪恶","date":"2021-09-10T12:58:06.000Z","url":"/2021/09/10/2021-09-10-%E7%94%9F%E5%8D%B3%E6%98%AF%E6%81%B6/","tags":[["live","/tags/live/"]],"categories":[["随笔","/categories/%E9%9A%8F%E7%AC%94/"]],"content":"当生活的痛苦超越了死亡，你将做何选择？ Live = evil,death is the best destination 今天是教师节，同时也是世界预防自杀日。请务必龃龉地、苟且地，活下去。"},{"title":"开学","date":"2021-09-05T14:46:05.000Z","url":"/2021/09/05/2021-09-05-%E5%BC%80%E5%AD%A6/","tags":[["live","/tags/live/"]],"categories":[["随笔","/categories/%E9%9A%8F%E7%AC%94/"]],"content":"​ 今天是开学的日子，6号就要去生产实习了。对于开学，我既开心又焦虑。开心是开学了大家都会回来，校园里也逐渐有些生气。因为留校两个月让我意识到了与人交流的重要性。日复一日地学习，回到寝室也是只有寥寥几句。我本以为我已经可以和孤独相处，但经历了这个暑假我才发现，原来我是如此害怕孤独。以前上课虽然都是一个人独来独往，但是起码那时还有课程这个纽带让整个专业里的人都联系在一起，总觉得朋友同学们还会聚在一起。暑假的时候，大家都蒙头备考。每天非饭点时期，图书馆的电梯是不动的。一切在默默运行，大家都为了自己的未来各自拼搏着忙碌着，再也没有上课时活跃的氛围，空气中弥漫着无形的压抑。焦虑是因为生产实习要占用三周的时间，而备考的日子已经所剩无几。面对考试，显然我心里是没有底气的。生活令人快乐，也令人痛苦。不管如何，剩下的日子里只管努力便是，不问结果几何但求回首无悔。"},{"title":"认识新朋友","date":"2021-09-03T14:49:44.000Z","url":"/2021/09/03/2021-09-03%20%20%E8%AE%A4%E8%AF%86%E6%96%B0%E6%9C%8B%E5%8F%8B/","tags":[["live","/tags/live/"]],"categories":[["随笔","/categories/%E9%9A%8F%E7%AC%94/"]],"content":" f4411ca0c68ccd1e14d2008ea7b3f1fe61e418eb25744978027663736f4855172fa3c1d890fd2e635bae09ffd1c36d47273690b7f3075f502012ca732c60a5cbb44ed69d041f78755f71164cca016e00d5e367807a51a224be86ceac8119cb1d882b7d338890eea97d95cafe2fc6ca03bbc23546d846582d549646a4213c775bfc2090f2a18394f6619c0125aeb9e8490628fc8218cbba36f78f0c80c34c4c0f55c2811a1af68af9b879917c1f4c650ca7986aa59aed827c50c67ec444259b88e9a35097b00bcfe0a31ee4386a783475d9f6d5d7160184aa0e0f9025deb3228bf17bc188fa3508c4fd1c82f6f0d2d7d4dfc4cbd44abc976d27501e8c73874b6bbd54f62b9b0cdeab603dc857ab1878bdb9724e3bf0f47216252172964340775d79c9e7eab7454c20fe71efae8f373306ef975df2256409cd18d8aca8f2178ef290134dff8e7e0ea17619e73bda890f5d9f47b596206b31d057b033bd7e8b4fa2449a815120b3c4da2975e219215f0f3de1b7eba47cf80ee92c0aae23db4806684476bc2297b90e3c8c5987d3c0493d9ca270257b04322a6d526398f97afc20181df1a15ef00de695a43f0e51829534fcf914f261efc7bea9d8aa6cab6f63941761f5c61eb18335d6636df15ad0b057a1756bda4a07315d5ce36bdcef5737f943ae4273d5b5a143ffe5c535bdb139f25da024dfc5d19fabb709db4117e1c018a7253f63707ede4c07028299ec88d0ddf6392a9fd5ce49c0db36b62c0385f9d30b3ae170f4dd72b7a4ae6726d58c1a5eb1f2f257aed0a55fa5371468bbb8419283aa45ceb047f28bbc3b474785415c6e30ecb076aa28d8a9dc319a21301956a76fbe24c29e35e96ffa83105c56c93cf3748cc57a495e73ce75dd657a927aeee79918161c160a7109f41daad21dd7a479f168e16b3790aec4f8b4704cc86e5bf219f0647e9db0ff5f95a7964976081d6d605b50789de6d8637086392d7a196acd8595a930282aa6fa77fad5e570ceaf86ec72838cca6603d3df299c081a65694e84be400562c8d02a7f37ce973aef702288ad152a98a97c9bc15c548f9979782a9b61c18df8561f621abd6d7a1135fcf9fd3943e73bafb441bc0f2290e96c5ffcc1490784704e97e53c5ef39a10a59ae5bcd54113523a1c0e567567e25350f589e28ee6fbe6b77f96a8b7f3eadd3ed79967760b05824c88ffe412a6ecbfb06a3adab31db415cb7933f681a0ae35932aaeee09a5bec5c1a471fee59456ec95173f5ff081efa36a1093ad647d226acef0e8e3d6002d36e160826cc2562d8c9adc872bb97eb426fdd37d562859e3969919c8215fe8ddf11e4ae3d4d5e8aa12e69240eb48291b495e5f16cd926bdfb5c4d032a3daa8944155539ac8f1f95d5af42767c4eab00ab87c5a1c4601a6ea18adf857a8c9d9fbb993db3d482697f30f77e9bf136935527a16bbf1b63e2e8135f3fbec4cede352e53e788a2cc7a0932238ac74090b001ab16729c8a448b463d7cc17835e3e770b7ce79f050f6b310a1cde86ca3debf218dc1538f8573e228f207713e3a714472a77a8f5cfe3e90ac03d96eba21bf90e90b80a93c483bf31c27445a5f99eb3c377c91b148126ece293b108fcc2cc17a0c5b971f48a6ca6ebd2e0ed6c6b55c1781d4d822512a08f1ca6a58c0d9129a8ea9eef42120abde3db3c468d731f317fc70f20e7605794d876cde32128a6fb6bd59dff97b6754ec10a8c730946b4b2d12aa0413157ad44bdcb07de37aa8ad4ebc67edbfa3f6f7bcdbaf4bc7c82b7279bbb6c08f05099eb1cbde05761b69518666cb4aa99e5837af19dfdc62e93d9199b43729da309cd80a99d4439d1f0852847df75579b4bafb2e1e079b41f67ee9c94d73d89547e52e27aa78204abc3ecd5b402667a47569ec9c5078e53fc2cde5871da576869913266c4ce95a1a615346a7aa86d601db553b1d990d7f93bfdf1c558fc2ccb586e5902b379e43738260884fe1ede3a7b5e22af6285a64a1f819b9d4ed2b791bb6fa5fdf7503040c7a26d380626022a7ba189b89d61f228cf04dd460fe8d64884a69690f726f3ef858b547f59a66b218ef723f077101d62b147c5e243f028ff1c2a38f094b3a37f9c393d632b85bae57da18b183f17aafe7917d57bc4197934c95fa43e15a66e090e0e717109af5d797646ee862e49317f0820e6f815431a9202d1a561c642ccf03edcc8f8a65ee7fd619da194b52640aff552d55c24a7bc0230c85c3fc958da3bcda68e1ad8ff2e8e27461e05f0f04dfc306ffee377650cc5a6537ebb113f104dfadc911e498695ecb039fe28ed47dfd97bfec16ea4686682cee0080b78c12c983eef3fd41f32c80f9ec9c057aadf03bd1a4a8f95b658c50b69de8f3f097ab97de4f0d40fc7508ade2d270e597ecf85fa542e3fbd50dcf2c2ce3a7458a428385d37151ffc5c28ff662bd80f4c924172fbf9574a2643101784876e2d3667f5d78759de97553d27c06da28041e814301166ea30fd8013f26cd6a79891ba2faa8b01aeeedaca857cf0fdc38e7b31881edd400d65815bb62ccdec1f548df862b636be0977584b64ce9dc79ef001514dd4dbb9b370e72bc16f04211771e5cdc2ea43408b1512d996103292526b15867b91b67b84a66b165fb130cada251851655689e8538bb91fc512fe344a5540f233039175117a9e4774b49b32adc1f7615a3f74384001265d141eb49e2071fb4152001c9707740129a262fee2b01ecd3d94b99b95acc8ebbf473641664c7dcbde3cf0ea00eb3026deb27447282c5dbcfc536cae92584b3adc43efd437ea7d9e96224537d3ff2546fced436847bd5111125edc886a0dbda3494fc0c98b2f8a734cecd5944eabf96ebc0c09d31986fbb0ddc31684605aac0ad235e6b67f5cca12e716bc00476320ba7d237df7c856475f49b52e10d385f6470db383674be238b3e4ecdd45c3fad0e1868ba0afebe1e2e3d4dc6632f159ae3d68aa5634cb8dcb8c8b69c5a1cfdf7778706faade4dffedc9ba8f45984f8fc7f49b66d8d3dc72923d76901ef6fafc9463f156c9691e45a201d46cd8a292ccda61f8bdb5029cc816386afd2fa28e216f509ac16a97f396232aeada026cbef9863f687be98a59c93fb269d273228141ad2ab4c71c1d0801c8f45ff26f89c889f1800ad2eba8ef3cb4e2547fb7935729db2cca08f1a0dacd5375134f34e1e1e77813bbe45fcaaa95a41f3f362f4390953369fc4ab7c5eaa0c2761f5e0847da337d5537ec5a7d61265964fd4e57dc014c8ebbc94150ff78b9eaa5d5767322a41ce6b7631b4461a6c2fe4c7ea779a72320cb96609ada7c4399fc7b3595382237ac35d58d368959ad7276178506d920e65ae4ffb2c1f024f310b78017a0150c8c3198a793ddbf02d45e6bcc843691e1ad106013bfb371ec1a6f4f5bcdf5acb6a8a7b5ff56b6a1eb07f7c290547ebef182617948b9f672d3541dcac7ce23c2b82f22ed93ce0ec9030f25372d0d41582c1007bf256bf7c8ee92e79473ed6069212489c691d83d933c8dac2e923e9f2e39822771142ef5ef779007c0a4b61136a5c57a8f662c9f16053907952f8da9eb62f2832e69ae96e1f0d5f38eb403a2e44d8f111714aaaaa4129af6b9c664eaf23c6b2708f7f0b9966dd1ba12d35479f64e3ac10d00c0b833061282ca29a6bbe4e68ed4e1acf3a36c4bebddb65ff52d429320d39982d5af89aa1256cfb82d0d2c592b703fd51f329df41b82d9b23a8adc41d0342a943430a3cb980afe02874df38f955e4c5dbba5e00a8ec142d5846640f28d6b4095385e2f98a09ff16568ba840ddb42c07b3f90ff91e944d2254d60158e5e019daa4de1c64aee491fa131a47678931cc403d9a7abd75ae9e6a69ae8c9b20b28a3455f48182bc301d92e418f45b6ef4eb54e301ffaa0ff8ea25baf8f85df9b5eefe5d1d921649292473e0f0e79371622dd27685e57f71bb41ca7e32116869710d53a6fdf50cf8d23a962ddc5331b7ebed58d57ff481e8a5726d40c07546044a994fabb2abdd35563dbb74d67df55eba478927acf15462d686123a086427ab8caa9e80a6276f1c10cc742a2254133bbc55ca797718302ce3b7f7df463f2df27b115b4b10195a327afc8aa75b6076ee1175530e8982ecfb9c31ce9fa8a1dac65f75300a3624760da018b17019ea217450f3b9f90186c483f03d85ee1a1004fc10450a011d59c3a1cf5dc5754ec0bfad4e76861a58d5c34b45f18a7cf095e0f2c8b4b937d236b83109bf15337626e78f1e69bea0eb8d2f66497a65954a668ed2287e4e4b7a23021484a8a710a54606e8baabb60c584844aa6fe77cb3bbca72485423372892500c764494482083fa69c4152b39e6b331aaeac57093cca2d4bd7fe714361ebdf4a7b13edd79335b58f0bec000058adc69aa72bb468238a099b6abf0b6084800add39b858af603780bff2b4da6cc054029cdd5f82436cf9148145a7171bdb2c1190c1007e99ed597c13ab6dac2ea11c8a975ede0521d7d1877acbe6d64ebb0a79f61e3860efa2c8828e2e3b8c13d49de02601245f93139f912aaef4379a93b60b7ea05a88633ac1716ce7b3536c86f4f919e3e40c526ef97fb34eaecb78e344162185afe85fa4a3df743ad50979d3eb5638ef6c3690aa1a0363246cf11924531cb0d1d981a25811bfbcdc63602c29ad2dfbb08f2da559195a333b9b8e467ab1f4b2978804b0cae9bda3e7f3a27349e2ea193f475ecba968bae9496084a2f6ea525bee9f8c8afe1003ab2962c43ba93e7f10382d61d0dd014e9bf655aaa0e3b76f9cbd310edebc02acadf28cb6989061963eb724e4a92d0d4052f4574b4b4f92b1db56f49dc20e5ebc91b6f95b20219da3e75acb855590466fc6d16874c1172b2f464eed35c9612d7dce9d2c7bed56e3d97a8f65f39c7cb2dbf309da7b6990123bf34c28c41d7f560712ef311266fa453e1a6f77e510dd5b73a9e8e1270a452648b9b815f351097dc5b0a36460ec74f24aa1945ce2f56fde9d99fab0ee1fe60ebc9c69191cb72365c4b3a9f60d16a5cf4aba580cc02cf594319c504bc5a2fbdaad3dc52277d59416b61c7d0c9ad339f01ee4ed89a64dabf96f8197b129dc00b4183d12cfea1f34785591b1bc7bb1ba5bed321aa7f55173767f4d3edec76bdfdf7ad2a877270a5db72afc2f79e2c46449ae53660c04a686eb16dfa5288696042bb1cc087bb22313e6cef3740c9889cb624d749d46590fe5bfb5fe7ef41a309870fd47d6dfac15c6fc60238835c3a293b8af7c8494852df3223cb95a472d65659adf8ca4bd819bf6fb454ba8154a7a13d08c3f296b29b2e559f97fdb28dfd9ea8d5a6bc498a003d327c251674eb3880461718feaeffdc4ea74b46de1534890090679b303be996d39eadca7d1ba3263dd7da3b5316e2aa84449496bc8fd63e2378fe56d60f1b5dec2bbfd8bb13e8928c0f42f40515781db450cfdd6d479e3f5d176a1454e14233d6dfd5abae13970e2b75c582efe8da1f914dfbbc54f255f4066893fe02e2489902a34fd7c6e0b1d8a58a1db2c2a37e3b504d5d38f976ba4f116db047055923f866b45cf4db9fc9d64cb18a8d8c1cc5a0d5628708cf622caa10d9b540747c8f6d9a0d59744c39e2526932d96a6d62c8e7bbfa393660d707e84e9fe9563dab0de75e08ae7f02c5daa318550fd99d47c9bec9741ee7fd49a18fad3cd6ba51ac5ac6ecdf0acb276a5cf1fea8331439cd5b53fe741a865c08294adc6e191246f0b06fe6162c504899bc77668dfe3fff06d5bd61e7290e91ff20be8e782827b6828311cb2edced53b66fe8c565498dd432fbe1640b80dcbe3272f919eb6d1a19882789905f12b729807e3450f7313b264ef912de2d33384040e78956f6f89d33ae1e0ad73cc47e9e10914edc48f6a509391cd420b97e0e45f5a79247ececd1684e4cdc484fd05e4b2d5085ce83e8c72c87b2ffd59fa9c3b9560193323b79f97498d574c20f5d7a75ee19d9b625268f05e186f9de6c4880ba348339da31e70ff54dbb16946d3e0f695bab9cb898b817120344010a8a313810b06f1c80d3d4bc3db2daf190c5aafb880cf8fd70140f02ce1179cee2ed73bf2bdbaa062a97f2fb1698f9a47c4b497bf1c8b1ae2d52dd2ccdaf6ae14357def10534cb2a81e8c79995d6854a8c95dabefe4d17d682d8ebe7e07d84818b0cd34cbb9cdbe25fd77c18d0125602779b849a67bae48867a6c7b07bb1b7c91538dce484a6fb0299569b7c8ffc11d7a33f303a5ec375c6cb658bc6be4bcc1d9e7f65db02128adf8ffdb33015531ae331595e9918eb8f5b137c88a2b8c6c43e11e8ed893eb31e8da7bd221bef9b2b30e3272c2fa58d00334bbf0b44c6e440eb1fc9ed5de637e538c6c69951a90b3a68230a5322bcc7612de9c5901a2dbe8f73b4cc0b2c326edcb5042dfa290af1c607c7f6df3997f2e8db51a29fa11ac5b82bba90d9fd295962d2fa987544d06f8eb3e7b301d3aa1929870fb35ae7c245cadb0eea78da11cd203fd7c282aaf65dbbc518eb1229ffbdc0cc52446ecd2e5854af70630919efbbf46a4e73ad6b7870277c56616ca0867052f05346111450175d80c0e6283178efcbd6fe0256cf3f480cc3cff4579f05260a4c9eb1169b69c9e37581e6d772ac885bdfa9a6d889e2d058ce6905540d6e4ceaf06db6299793d58c7919ab9bcb7b62b560491e480752d0eddaf6f35f9c401c534169df21b9172dcac64239755b50852424455fa3eada46e7dcbc9f572fbe4bc3b56109e90181e0b0f8cfbe65188d351bdaa5c7eec28964be57ca1bcb1e80f9af31df12518baf32ce17633914ca19dbf07f505ee0a78cb7f7330934e285599cb25eea017c1029eaad613af50efa7f474845717401dcb6425a32fcd7b490efe249eb17f1fea2dd8886e72c4136dcac0b0282827bf4df2c518a550a639c322c155a9df4806b8d1200a8a4caa96209ef29d5d739825605c8734e893f968090d0e0a992ff80d74858c4177e8a85f0f54988f1b7f1d0c9eb1642d5456d0f686136dc30c27ee685b778970080a22882ac185cefab73d7ef0edc1ff33031970e1249b08b225dbba 请输入密码 "},{"title":"依然恐惧未来","date":"2021-08-15T12:47:04.000Z","url":"/2021/08/15/2021-08-15/","tags":[["live","/tags/live/"]],"categories":[["随笔","/categories/%E9%9A%8F%E7%AC%94/"]],"content":"​ 只要一停下来，脑子里就会焦虑。焦虑未来，焦虑人生，好像这辈子就这样了。自从上大学，可以说没有哪年是过得比较顺心的。别人的大学的生活似乎多姿多彩，而自己却总是多灾多难的样子。每个失眠的夜里反思着自己的人生，或许在家里人看来我考上大学似乎是一件非常成功的事情，但只有当自己上了大学。逐渐明白社会的残酷性后才懂得，你拼尽一切得到的这一切在别人眼里不过如此。你迄今为止所有的一切，其实并不值得一提。现实的毒打直接否定了你一直以来的努力，信念崩塌的痛苦强烈地撕扯着。所有的一切都没有发生根本改变，这个世界是现实的，只有你用努力和自我，令它柔软。 ​ 越长大就越能感觉到自己的渺小，努力挣扎只为能做个普通人，过着普通的生活，做着普通的事情。从小听着要努力出人头地，就天真的以为只要努力就能出人头地，现在明白以为努力便能做到一切那是一种傲慢，只有努力才能过上别人唾手可得的普通人的生活。面对命运时常感到绝望，干脆就这样被命运拍死在沙滩上算了。等自己还完了所有的恩情，除去心里的牵挂就可以随时准备死去了。 ​ 人真是一种神奇的生物，有时候会自己一个人咬着牙走了很长一段路，有时候却会因为几句话而泪流满面。我曾以为自己已经正视了自己的懦弱，但是最近发现其实并没有。我依然是那个懦弱的，遇到困难首先想着如何逃避的人。心里非常清楚，逃避解决不了任何问题反而会让问题愈发严重，即便如此还是会想着逃避以获取当下短暂的、虚假的安宁。 ​ 对未来的恐惧总是如影随形，惧怕未知，惧怕失败，害怕得不到一个好结果。内心已经被对未来的恐惧所占据，想要行动起来去抵抗，发现身体动不起来。恐惧在内心已经占据太多分量，一路以来诚惶诚恐、患得患失。明明知道这样下去不行，行动上还是放任自己。 ​ 就像一株浮萍，只能随着命运的长河漂流。无论昨夜发生了什么，清晨醒来这个城市依旧车水马龙。"},{"date":"2021-07-26T14:09:16.000Z","url":"/2021/07/26/2021-07-26/","categories":[["undefined",""]],"content":"时不时的失眠令人憔悴，无论选择哪条路，在路上遇到挫折时抑或是未来遭受打击时，都会怀疑当初自己的选择。 只能安慰自己，硬着头皮走下去。欲壑难填，人是环境的产物。当大环境鼓吹焦虑时，不受其影响的终归是少数人。而我显然是大多数，只能被环境裹挟着往前走，什么时候才能独辟蹊径呢。终归是难有坚韧的毅力以及决心，当外界逼迫时才愿意动一动。 愿最终都有一个好结果"},{"title":"计算机总线系统概述","date":"2021-06-14T13:34:31.000Z","url":"/2021/06/14/%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/","tags":[["CS","/tags/CS/"]],"categories":[["计算机组成原理","/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"]],"content":"总线系统基础概念总线用于将计算机各个部件连接起来，成为一个整体，是多个系统功能部件之间进行数据传输的公共通道 单处理器系统中总线分为三大类 内部总线：CPU内部连接寄存器、运算部件 系统总线：计算机系统用于连接其它高速设备，存储器、通道等 I/O总线：用于连接中、低速 I/O 设备 总线的特性 物理特性：指总线的物理连接方式，包括总线的根数，总线插头、引脚数等 功能特性：描述总线中每一根线的功能 电气特性：定义每根线上信号的传递方向以及有效的电平范围 时间特性：定义了每根线在何时有效 总线连接方式通常采用适配器部件来完成 单总线系统：要总线上的所有逻辑部件都高速运行，以便某些设备需要使用总线时能迅速获得总线控制权 多总线系统：将高速设备（北桥）和低速设备（南桥）分开，用不同类型的桥扩展出不同层次的总线 总线内部结构 地址线：单向，用于传送主存与设备的地址 数据线：双向，用来传送数据 控制线：对每根线是单向（CPU发向接口，或接口发向CPU），用来指明数据传送的方向（存储器读写、I/O读写）、中断控制和定时控制等 总体总线分类数据传送总线由地址线、数据线、控制线组成 仲裁总线包括总线请求线和总线授权线 中断和同步总线用于处理带优先级的中断操作，包括中断请求线和中断认可线 公用线包括时钟信号线、电源线、地线、系统复位线以及加电或断电的时序信号线 总线仲裁集中式仲裁 链式查询 菊花链式查询，授权信号串行地从一个接口发送到下一个接口，若中间有设备请求总线则获得授权，信号不再传递。离CPU越近的设备优先级越高 该种方式优点是简单、节省线路；其缺点是优先级不能改变，不灵活，可能存在优先级低的设备饿死，对电路故障十分敏感，若中间设备故障则后面的设备都无法工作 计数器定时查询 设备通过BR线发出请求，总线仲裁器接受到请求后，在BS线为0的情况下计数，计数值通过地址线发往各设备。每个设备都有设备地址判别电路，当地址线计数值与设备地址一致时，该设备获得总线使用权，BS置1，终止计数 该种方式优点是可以通过决定是否从上次终止点开始继续计数还是从0计数来改变各个设备的优先级；其缺点是要增加线的数量 独立请求 每个设备都有一对独立的总线请求线和授权线，请求的信号在排队电路中被总线仲裁器以优先级次序处理授权 该种方式优点是响应快，优先级次序控制灵活；其缺点是线数大量增加 现代计算机基本采用独立请求方式 分布式仲裁不需要集中的总线仲裁器，每个设备都有自己的总线仲裁器。请求总线时，将它们唯一的仲裁号发送到共享的仲裁总线上，每个仲裁器将从仲裁总线上得到的号与自己比较。若仲裁总线上的号大，则不予响应并撤销其仲裁号，最后获胜者的仲裁号保留在仲裁总线上获得授权"},{"date":"2021-06-01T15:29:08.000Z","url":"/2021/06/01/%E6%9D%82%E8%B0%88/","categories":[["undefined",""]],"content":"六一快乐！"},{"title":"PSW寄存器分析","date":"2021-05-31T23:51:22.000Z","url":"/2021/06/01/FLAG%E5%AF%84%E5%AD%98%E5%99%A8/","tags":[["CS","/tags/CS/"]],"categories":[["计算机组成原理","/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"]],"content":"FLAG寄存器 存储程序状态字（PSW，program status word），存储相关指令的执行结果，为相关指令提供行为依据，用来控制CPU的相关工作方式。flag寄存器是按位起作用的，每一位都有专门的含义记录特定信息。 在32位CPU中称为为EFLAGS寄存器，64为CPU中称为RFLAGS寄存器，它们扩展出的高位地址都不使用。现代计算机中一般也叫做PSW寄存器。下面以8086为基础处理器分析该寄存器的功能 ZF（Zero Flag） 第6位标志位，零标志位。计算指令执行后，若结果为0，则zf=1，否则zf=0 PF（Parity Flag） 第2位标志位，奇偶标志位。指令执行后，若所有bit位中1的个数为偶数，则pf=1，否则pf=0 SF（Symbol Flag） 第7位标志位，符号标志位。指令执行后，若结果为负，则sf=1，否则sf=0 CF（Carry Flag） 第0位标志位，进位标志位。无符号运算中指令执行后，若产生进位，则cf=1，否则cf=0，同时也可以用作表示借位。若其值被add设置则表示进位，被sub设置则表示借位 OF（Overflow Flag） 第11位标志位，溢出标志位。有符号运算时，若产生溢出，则of=1，否则of=0 AF（Auxiliary Flag） 第4位标志位，辅助进位标志位。若操作中发生了进位或借位，则af=1，否则af=0mov al，0Fhadd al，1计算过程0000111100000001——————00010000 位3中发生了进位，af=1 IF（Interrupt-Enable Flag） 第9位标志位，中断允许标志位。决定CPU是否能够响应外部可屏蔽中断请求，若响应则if=1，否则if=0 DF（Direction Flag） 第10位标志位，方向标志位。控制SI和DI自增还是自减。若自减，则df=1，否则df=0 TF（Trap Flag） 第8位标志位，追踪标志位。若CPU进入单步调试，则tf=1，否则tf=0 "},{"title":"CSMA/CD中重传时机的确定","date":"2021-05-29T15:14:31.000Z","url":"/2021/05/29/%E6%88%AA%E6%96%AD%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8C%87%E6%95%B0%E8%A7%84%E9%81%BF%E7%AE%97%E6%B3%95/","tags":[["CN","/tags/CN/"]],"categories":[["计算机网络","/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"]],"content":"截断二进制指数规避算法什么是截断二进制指数规避算法在CSMA/CD协议中，检测到碰撞我们要重传数据。那么如何选择碰撞后数据的重传的时机呢？该算法就是为了解决这个问题而提出的 如何使用该算法计算重传时机首先，发生碰撞后我们要确定一个基本的退避时间来延迟发送。假设从A发送到B的传播时延是 t ，我们将基本退避时间设置为 2t 。 其次，定义参数 k ，用于记录重传的次数。 k = min[ 重传次数，10 ]。当检测到数据碰撞时，在 0 ~ 2k - 1 的范围中随机取出一个数 r ，重传时间 R 即为 r 倍的基本退避时间 ， R = 2tr 最后，若重传 16 次仍然不能成功发送数据则向网络层发出错误信息表示网络拥挤并抛弃此帧"},{"title":"数据链路层中最小帧长问题","date":"2021-05-20T15:12:19.000Z","url":"/2021/05/20/%E6%9C%80%E5%B0%8F%E5%B8%A7%E9%95%BF/","tags":[["CN","/tags/CN/"]],"categories":[["计算机网络","/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"]],"content":"数据链路层中的最小帧长是如何计算出来的众所周知，Ethernet的最小帧长是64 Byte。那么这个最小帧长是如何得到的呢？ 数据碰撞问题当多个主机挂载在bus型半双工信道上时我们都会存在一个信道争用问题，为解决这个问题我们发明了CSMA/CD协议。 当两个主机同时在bus型半双工信道上发送数据就会产生数据碰撞。数据发送过程如图所示 我们假设单向传播时延为 t ，图中发生数据碰撞时，A知道碰撞检测的时间为 2 t1 ，而B检测到碰撞的时间为 2 t2。 t = t1 + t2 最差的情况下，当A即将到达B时，B才发送数据，此时发生碰撞。所以最迟我们检测到数据碰撞的时间是 2t 如何确定最小帧长因为如果我们自身数据全部发完后才检测到数据则数据会被误认为是正常的数据而被接收，所以我们要确保我们还没有发完数据时就检测到碰撞。 因此根据上面的时延计算，我们可以得出 帧长 / 数据传输速率 &gt;= 2 t 最小帧长 = 数据传输速率 x 传播时延 x 2"},{"title":"Cache设计","date":"2021-05-07T15:06:08.000Z","url":"/2021/05/07/Cache%E8%AE%BE%E8%AE%A1/","tags":[["CS","/tags/CS/"]],"categories":[["计算机组成原理","/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"]],"content":"Cache设计Cache原理 利用程序的局部性原理，缩减CPU的访存时间，让CPU能够更好的发挥性能 空间局部性：最近被访问的块邻近的块很有可能被访问 时间局部性：最近被的访问的块很有可能被再次访问 Cache设计的两大原则 高命中率，要求高命中率减少块的置换操作 对CPU透明，即CPU访问内存和访问Cache为同一种方式，无需改变 Cache设计的四个问题 从主存取得的块如何在Cache中存放 如何访问主存放入Cache中的块 当Cache未命中时置换数据块的策略 怎样保持Cache块中数据与主存块的数据同步 三种Cache与主存地址映射策略 通常Cache相对于主存都十分小，所以主存块的哪些部分放入有限的Cache空间中是一个很重要的问题。下面有三种策略用于解决主存块在Cache中的存放位置问题 全相联映射 Cache数据块称为行，主存数据块称为块，其中行大小==块大小。全相联映射中，主存一个块地址、块号、块内容都被一起存于Cache的行中 主存中的块被复制到Cache的任意行中 CPU访问一个主存地址时，为了快速检索，指令中的块号与Cache所有行号的标记同时在比较器中比较，若命中则从Cache中读取一个字，否则在主存地址中读取 全相联映射其主要缺点是高速比较器电路难于设计和实现，因此适合小容量Cache 直接映射主存被划分为n个和Cache大小相同的区，区内的块只能存入对应Cache行内 Cache行号 i 和主存块号 j 关系为 i = j mode m，其中m为Cache的大小 直接映射其优点是硬件简单，成本低，地址变换速度快，但其缺点是每个主存块有一个固定行号可以存放。 当连续两个访存指令要求访问块号相距m整数倍的两个块时，因两个块同时映射到同一个Cache行内，所以会产生冲突，需要置换行块，导致置换操作频繁，降低Cache效率 组相联将Cache划分为若干个大小相同的组，而主存不同区内，区内的对应块可以换入Cache对应的组中，在组中可以存放在任意行 当Cache分组的大小为1时，组内只有一个块，此时为直接映射；当Caceh分组大小为整个Cache大小时，只有一个分组，此时为全相联 组相联模式结合了适度兼顾了全相联和直接映射的优点，被普遍采用 Cache替换策略 当Cache存满需要换入新块时，有三种主流的替换算法分别是 LFU算法LFU，最不经常使用算法，将一段时间内被访问次数最少的行换出。每行设置一个计数器，当新行调入Cache，该新行计数器为0。当某个行被读取一次，该行的计数器+1，需要换出行时寻找到计数器最低的行将其换出。 LRU算法LRU，近期最少使用算法，将近期内最长久未被访问过的行换出。同样如LFU为每行设置一个计数器，但是Cache行每次被命中其计数器清零，其它各行计数器+1，与LFU算法相反，需要置换出行时将计数器值最高的行换出 随机替换随机换出行，无固定规则。研究表明随机替换的性能只是稍稍逊于前两种算法 Cache写操作策略 因为Cache中的数据时主存块中的副本，在任何系统中只要存在副本就存在各副本之间数据同步的问题。当前Cache中普遍采用的同步策略有以下三种： 写回法 write back,copy back：CPU命中Cache时，只修改Cache行中的数据内容，仅当Cache该块被换出时，将数据写回主存；CPU未命中Cache时，将该块从主存复制到Cache行中，再对其修改。Cache中每行都置一个修改位，记录该块是否被修改，若该行被换出是修改位为0，则直接抛弃 写回法优点是减少访问主存的次数，但是写回法会导致Cache行中的数据与对应主存块中的数据不一致，产生隐患 全写法 write through：CPU命中Cache时，同时修改Cache行和主存块中的内容，主存和Cache同步；当CPU未命中Cache时，有两种策略，一是WTWA法，将主存块置换如Cache行中，对Cache行修改，另一种是WTNWA法，直接修改主存块，不置换入Cache中 全写法的优点是简单，Cache和主存同步，不会发生数据不一致，但是其频繁的访问主存操作导致Cache性能降低 写一次法 write once：CPU第一次命中Cache时，同时修改Cache行中和主存块中的内容，后面再命中时采用写回法的策略；CPU未命中时采用写回法策略 写一次法结合了写回法和全写法"}]